:sectnums!:
== Jakarta Server Pages Specification, Version 3.0

Copyright (c) 2013, 2019 Oracle and/or its affiliates and others.
All rights reserved.

Eclipse is a registered trademark of the Eclipse Foundation. Jakarta
is a trademark of the Eclipse Foundation. Oracle and Java are
registered trademarks of Oracle and/or its affiliates. Other names
may be trademarks of their respective owners. 

The Jakarta Server Pages Team - {revdate}

Comments to: jsp-dev@eclipse.org

== Preface

This is the Server Pages specification
version 3.0, developed by the Jakarta Server Pages Team under the Eclipse
Foundation Specification Process.

=== Who Should Read This Document

This document is the authoritative JSP 3.0
specification. It is intended to provide requirements for
implementations of JSP page processing, and support by web containers in
web servers and application servers. As an authoritative document, it
covers material pertaining to a wide audience, including Page Authors,
Tag Library Developers, Deployers, Container Vendors, and Tool Vendors.

This specification includes chapters that are
derived directly from the Javadoc comments in the API classes, but, were
there to be any discrepancies, this specification has precedence over
the Javadoc comments.

This document is not intended to be a user’s
guide. We expect other documents will be created that will cater to
different readerships.

=== Organization of This Document

This document comprises of a number of
Chapters and Appendices that are organized into 3 parts. In addition,
the document contains a link:jsp-1.html#a11[See Preface.]”
(this section), a link:jsp-1.html#a1[See Status.], and an
link:jsp-1.html#a77[See Overview.].

link:jsp.html#a189[See Part I.]
contains several chapters intended for all JSP Page Authors. These
chapters describe the general structure of the language, including the
expression language, fragments, and scripting.

link:jsp.html#a2871[See Part II.]
contains detailed chapters on the JSP container engine and API in full
detail. The information in this part is intended for advanced JSP users.

Finally, link:jsp.html#a3016[See Part
III.] contains all the appendices.

=== Historical Note

Prior to version 3.0, this specification was developed in the Java
Community Process as part of JSR 245.

== Overview

=== The JavaServer Pages™ Technology

JavaServer™ Pages (JSP) is the Java™
Platform, Enterprise Edition (Java EE) technology for building
applications for generating dynamic web content, such as HTML, DHTML,
XHTML, and XML. JSP technology enables the easy authoring of web pages
that create dynamic content with maximum power and flexibility.

=== General Concepts

JSP technology provides the means for textual
specification of the creation of a dynamic response to a request. The
technology builds on the following concepts:

*  _Template Data_

A substantial portion of most dynamic content
is fixed or _template_ content. Text or XML fragments are typical
template data. JSP technology supports natural manipulation of template
data.

*  _Addition of Dynamic Data_

JSP technology provides a simple, yet
powerful, way to add dynamic data to template data.

*  _Encapsulation of Functionality_

JSP technology provides two related
mechanisms for the encapsulation of functionality: JavaBeans™ component
architecture, and tag libraries delivering custom actions, functions,
listener classes, and validation.

*  _Good Tool Support_

Good tool support leads to significantly
improved productivity. Accordingly, JSP technology has features that
enable the creation of good authoring tools. +
 +
Careful development of these concepts yields a flexible and powerful
server-side technology.

=== Benefits of JavaServer Pages Technology

JSP technology offers the following benefits:

*  _Write Once, Run Anywhere_ ™ _properties_

JSP technology is platform independent in its
dynamic web pages, its web servers, and its underlying server
components. JSP pages may be authored on any platform, run on any web
server or web enabled application server, and accessed from any web
browser. Server components can be built on any platform and run on any
server.

*  _High quality tool support_

Platform independence allows the JSP user to
choose best-of-breed tools. Additionally, an explicit goal of the
JavaServer Pages design is to enable the creation of high quality
portable tools.

*  _Separation of Roles_

JSP supports the separation of developer and
author roles. Developers write components that interact with server-side
objects. Authors put static data and dynamic content together to create
presentations suited for their intended audience.

Each group may do their job without knowing
the job of the other. Each role emphasizes different abilities and,
although these abilities may be present in the same individual, they
most commonly will not be. Separation allows a natural division of
labor.

A subset of the developer community may be
engaged in developing reusable components intended to be used by
authors.

*  _Reuse of components and tag libraries_

JavaServer Pages technology emphasizes the
use of reusable components such as JavaBeans components, Enterprise
JavaBeans™ components, and tag libraries. These components can be used
with interactive tools for component development and page composition,
yielding considerable development time savings. In addition, they
provide the cross-platform power and flexibility of the Java programming
language or other scripting languages.

*  _Separation of dynamic and static content_

JavaServer Pages technology enables the
separation of static content in a template from dynamic content that is
inserted into the static template. This greatly simplifies the creation
of content. The separation is supported by beans specifically designed
for the interaction with server-side objects, and by the tag extension
mechanism.

*  _Support for actions, expressions, and
scripting_

JavaServer Pages technology supports
scripting elements as well as actions. Actions encapsulate useful
functionality in a convenient form that can be manipulated by tools.
Expressions are used to access data. Scripts can be used to glue
together this functionality in a per-page manner.

The JSP 2.0 specification added a simple
expression language (EL) to Java-based scripts. Expressions in the EL
directly express page author concepts like properties in beans and
provide more controlled access to the Web Application data. Functions
defined through the tag library mechanism can be accessed in the EL.

The JSP 2.0 specification also added a
mechanism by which page authors can write actions using the JSP
technology directly. This greatly increases the ease with which action
abstractions can be created.

*  _Web access layer for N-tier enterprise
application architecture(s)_

JavaServer Pages technology is an integral
part of Java EE. The Java EE platform brings Java technology to
enterprise computing. One can now develop powerful middle-tier server
applications that include a web site using JavaServer Pages technology
as a front end to Enterprise JavaBeans components in a Java EE compliant
environment.

=== Basic Concepts

This section introduces basic concepts that
will be defined formally later in the specification.

=== What Is a JSP Page?

A JSP page is a text-based document that
describes how to process a request to create a response. The description
intermixes template data with dynamic actions and leverages the Java
Platform. JSP technology supports a number of different paradigms for
authoring dynamic content. The key features of JavaServer Pages are:

* Standard directives
* Standard actions
* Scripting elements
* Tag Extension mechanism
* Template content

=== Web Applications

The concept of a web application is inherited
from the servlet specification. A web application can be composed of:

* Java Runtime Environment(s) running on the
server (required)
* JSP page(s) that handle requests and
generate dynamic content
* Servlet(s) that handle requests and
generate dynamic content
* Server-side JavaBeans components that
encapsulate behavior and state
* Static HTML, DHTML, XHTML, XML, and similar
pages.
* Client-side Java Applets, JavaBeans
components, and arbitrary Java class files
* Java Runtime Environment(s) running in
client(s) (downloadable via the Plugin and Java™ Web Start technology)

The JavaServer Pages specification inherits
from the servlet specification the concepts of web applications,
_ServletContexts_ , sessions, and requests and responses. See the Java
Servlet 2.5 specification for more details.

=== Components and Containers

JSP pages and servlet classes are
collectively referred to as web components. JSP pages are delivered to a
container that provides the services indicated in the JSP Component
Contract.

The separation of components from containers
allows the reuse of components, with quality-of-service features
provided by the container.

=== Translation and Execution Steps

JSP pages are textual components. They go
through two phases: a translation phase, and a request phase.
Translation is done once per page. The request phase is done once per
request.

The JSP page is translated to create a
servlet class, the JSP page implementation class, that is instantiated
at request time. The instantiated JSP page object handles requests and
creates responses.

JSP pages may be translated prior to their
use, providing the web application, with a servlet class that can serve
as the textual representation of the JSP page.

The translation may also be done by the JSP
container at deployment time, or on-demand as the requests reach an
untranslated JSP page.

=== Deployment Descriptor and Global Information

The JSP pages delivered in a web application
may require some JSP configuration information. This information is
delivered through JSP-specific elements in the _web.xml_ deployment
descriptor, rooted on the _<jsp-config>_ element. Configuration
information includes _<taglib>_ elements in mapping of tag libraries and
_<jsp-property-group>_ elements used to provide properties of
collections of JSP files. The properties that can be indicated this way
include page encoding information, EL evaluation activation, automatic
includes before and after pages, and whether scripting is enabled in a
given page.

=== Role in the Java Platform, Enterprise Edition

With a few exceptions, integration of JSP
pages within the Java EE 6.0 platform is inherited from the Servlet 2.5
specification since translation turns JSPs into servlets.

=== Users of JavaServer Pages

There are six classes of users that interact
with JavaServer Pages technology. This section describes each class of
user, enumerates the technologies each must be familiar with, and
identifies which sections of this specification are most relevant to
each user class. The intent is to ensure that JavaServer Pages remains a
practical and easy-to-use technology for each class of user, even as the
language continues to grow.

=== Page Authors

Page Authors are application component
providers that use JavaServer Pages to develop the presentation
component of a web application. It is expected that they will not make
use of the scripting capabilities of JavaServer Pages, but rather limit
their use to standard and custom actions. Therefore, it is assumed that
they know the target language, such as HTML or XML, and basic XML
concepts, but they need not know Java at all.

The following sections are most relevant to
this class of user:

* link:jsp.html#a204[See Core Syntax
and Semantics.], except for link:jsp.html#a944[See Scripting
Elements.] and link:jsp.html#a1001[See Tag Attribute
Interpretation Semantics.], which both talk about scripting.
* link:jsp.html#a1054[See Expression
Language.]
* link:jsp.html#a1210[See JSP
Configuration.]
* link:jsp.html#a1339[See
Internationalization Issues.]
* link:jsp.html#a1403[See Standard
Actions.]
* link:jsp.html#a1794[See JSP
Documents.], except for sections that discuss declarations, scriptlets,
expressions, and request-time attributes.
* link:jsp.html#a2006[See Goals.] and
link:jsp.html#a2013[See Overview.] of
link:jsp.html#a1991[See Tag Extensions.].
* link:jsp.html#a2322[See Tag
Files.].
* Appendices link:jsp.html#a3028[See
Packaging JSP Pages.], link:jsp.html#a5908[See Changes.], and
link:jsp.html#a6526[See Glossary.].

=== Advanced Page Authors

Like Page Authors, Advanced Page Authors are
also application component providers that use JavaServer Pages to
develop the presentation component of a web application. These authors
have a better understanding of XML and also know Java. Though they are
recommended to avoid it where possible, these authors do have scripting
at their disposal and should be able to read and understand JSPs that
make use of scripting.

The following sections are most relevant to
this class of user:

* Chapters link:jsp.html#a204[See
Core Syntax and Semantics.], link:jsp.html#a1054[See Expression
Language.], link:jsp.html#a1210[See JSP Configuration.],
link:jsp.html#a1339[See Internationalization Issues.] and
link:jsp.html#a1403[See Standard Actions.].
* link:jsp.html#a1794[See JSP
Documents.].
* link:jsp.html#a2605[See Valid JSP
Page.] and link:jsp.html#a2607[See Reserved Names.] of
link:jsp.html#a2599[See Scripting.].
* link:jsp.html#a2006[See Goals.] and
link:jsp.html#a2013[See Overview.] of
link:jsp.html#a1991[See Tag Extensions.].
* link:jsp.html#a2322[See Tag Files.]
* link:jsp.html#a2967[See
Precompilation.] of link:jsp.html#a2881[See JSP Container.]
* link:jsp.html#UNKNOWN[See Core API.]
* Appendices link:jsp.html#a3028[See
Packaging JSP Pages.], link:jsp.html#a3054[See JSP Elements of
web.xml.], link:jsp.html#a5908[See Changes.], and
link:jsp.html#a6526[See Glossary.].

=== Tag Library Developers

Tag Library Developers are application
component providers who write tag libraries that provide increased
functionality to Page Authors and Advanced Page Authors. They have an
advanced understanding of the target language, XML, and Java.

The following sections are most relevant to
this class of user:

* Chapters link:jsp.html#a204[See
Core Syntax and Semantics.], link:jsp.html#a1054[See Expression
Language.], link:jsp.html#a1210[See JSP Configuration.],
link:jsp.html#a1339[See Internationalization Issues.] and
link:jsp.html#a1403[See Standard Actions.].
* link:jsp.html#a1794[See JSP
Documents.].
* link:jsp.html#a2605[See Valid JSP
Page.] and link:jsp.html#a2607[See Reserved Names.] of
link:jsp.html#a2599[See Scripting.].
* link:jsp.html#a1991[See Tag
Extensions.]
* link:jsp.html#a2322[See Tag Files.]
* link:jsp.html#a2967[See
Precompilation.] of link:jsp.html#a2881[See JSP Container.]
* link:jsp.html#UNKNOWN[See Core API.]
and link:jsp.html#UNKNOWN[See Tag Extension API.]
* All Appendices.

=== Deployers

A deployer is an expert in a specific
operational environment who is responsible for configuring a web
application for, and deploying the web application to, that environment.
The deployer does not need to understand the target language or Java,
but must have an understanding of XML or use tools that provide the
ability to read deployment descriptors.

The following sections are most relevant to
this class of user:

* link:jsp.html#a206[See What Is a
JSP Page.] and link:jsp.html#a255[See Web Applications.] of
link:jsp.html#a204[See Core Syntax and Semantics.]
* link:jsp.html#a1210[See JSP
Configuration.]
* link:jsp.html#a1339[See
Internationalization Issues.]
* link:jsp.html#a2881[See JSP
Container.]
* All Appendices.

=== Container Developers and Tool Vendors

Container Developers develop containers that
host JavaServer Pages. Tool Vendors write development tools to assist
Page Authors, Advanced Page Authors, Tag Library Developers, and
Deployers. Both Container Developers and Tool Vendors must know XML and
Java, and must know all the requirements and technical details of
JavaServer Pages. Therefore, this entire specification is relevant to
both classes of user.

'''''

[.footnoteNumber]# 1.# The character sequence
'#\{' is now reserved by JSP. So If you are using '#\{' in template text
or as a literal in an attribute value for a 1.2-based taglib, the
sequence will have to be escaped.

=== [[a189]]Part I

 __ 

The next chapters form the core of the
JSP specification. These chapters provide information for Page authors,
Tag Library developers, deployers and Container and Tool vendors.

The chapters of this part are:

* Core Syntax and Semantics
* Expression Language
* Configuration Information
* Internationalization Issues
* Standard Actions
* JSP Documents
* Tag Extensions
* Tag Files
* Scripting
* XML Views

=== CHAPTER[[a203]]

=== [[a204]]Core Syntax and Semantics

This chapter describes the core syntax
and semantics for the JavaServer Pages 2.2 specification (JSP 2.2).

=== [[a206]]What Is a JSP Page

A JSP page is a textual document that
describes how to create a response object from a request object for a
given protocol. The processing of the JSP page may involve creating
and/or using other objects.

A JSP page defines a JSP page implementation
class that implements the semantics of the JSP page. This class
implements the _javax.servlet.Servlet_ interface (see
/C:/jspspec/JSP_Engine.html#57518[] for details). At request time a
request intended for the JSP page is delivered to the JSP page
implementation object for processing.

HTTP is the default protocol for requests and
responses. Additional request/response protocols may be supported by JSP
containers. The default _request_ and _response_ objects are of type
_HttpServletRequest_ and _HttpServletResponse_ respectively.

=== Web Containers and Web Components

A JSP container is a system-level entity that
provides life-cycle management and runtime support for JSP pages and
servlet components. Requests sent to a JSP page are delivered by the JSP
container to the appropriate JSP page implementation object. The term
web container is synonymous with JSP container.

A web component is either a servlet or a JSP
page. The _servlet_ element in a _web.xml_ deployment descriptor is used
to describe both types of web components. JSP page components are
defined implicitly in the deployment descriptor through the use of an
implicit _.jsp_ extension mapping, or explicitly through the use of a
_jsp-group_ element.

=== Generating HTML

A traditional application domain of the JSP
technology is HTML content. The JSP specification supports well this use
through a syntax that is friendly to HTML and XML although it is not
HTML-specific; for instance, HTML comments are treated no differently
than other HTML content. The JSP Standard Tag Library has specific
support for HTML though some specific custom actions.

=== Generating XML

An increasingly important application domain
for JSP technology is dynamic XML content using formats like XHTML, SVG
and the Open Office format, and in applications like content publishing,
data representation and Web Services. The basic JSP machinery (JSP
syntax) can be used to generate XML content, but it is also possible to
tag a JSP page as a JSP document and get additional benefits.

A JSP document is an XML document; this means
that a JSP document is a well-formed, structured document and that this
will be validated by the JSP container. Additionally, this structure
will be available to the JSP validation machinery, the
TagLibraryValidators. A JSP document is a namespace-aware XML document,
with namespaces reflecting the structure of both content and custom
actions and with some additional care, a JSP page can reflect quite
accurately the structure of the resulting content. A JSP document can
also use machinery like entity definitions.

The JSP 1.2 specification made a stronger
distinction between JSP documents and non-XML JSP pages. For instance
standard actions like <jsp:expression> were only available in JSP
documents. The difference proved to be confusing and distracting and the
distinction has been relaxed in JSP 2.0 to facilitate the transition
from the JSP syntax to XML syntax.

=== Translation and Execution Phases

A JSP container manages two phases of a JSP
page’s lifecycle. In the translation phase, the container validates the
syntactic correctness of the JSP pages and tag files and determines a
JSP page implementation class that corresponds to the JSP page. In the
execution phase the container manages one or more instances of this
class in response to requests and other events.

During the translation phase the container
locates or creates the JSP page implementation class that corresponds to
a given JSP page. This process is determined by the semantics of the JSP
page. The container interprets the standard directives and actions, and
the custom actions referencing tag libraries used in the page. A tag
library may optionally provide a validation method acting on the XML
View of a JSP page, see below, to validate that a JSP page is correctly
using the library.

A JSP container has flexibility in the
details of the JSP page implementation class that can be used to address
quality-of-service--most notably performance-- issues.

During the execution phase the JSP container
delivers events to the JSP page implementation object. The container is
responsible for instantiating request and response objects and invoking
the appropriate JSP page implementation object. Upon completion of
processing, the response object is received by the container for
communication to the client. The details of the contract between the JSP
page implementation class and the JSP container are described in
/C:/jspspec/JSP_Engine.html#57518[].

The translation of a JSP source page into its
implementation class can occur at any time between initial deployment of
the JSP page into the JSP container and the receipt and processing of a
client request for the target JSP page. link:jsp.html#a242[See
Compiling JSP Pages.] describes how to perform the translation phase
ahead of deployment.

=== Validating JSP pages

All JSP pages, regardless of whether they are
written in the traditional JSP syntax or the XML syntax of JSP documents
have an equivalent XML document, the XML view of a JSP page, that is
presented to tag library validators in the translation phase for
validation.

The structure of the custom actions in a JSP
page is always exposed in the XML view. This means that a tag library
validator can check that, for instance, some custom actions are only
used within others.

The structure of the content used in a JSP
page is exposed in greater or lesser detail depending on whether the XML
syntax or the traditional JSP syntax is used. When using XML syntax a
tag library validator can use that extra structure to, for example,
check that some actions are only used with some content, or within some
content, and, using knowledge of the semantics of the custom actions,
make assertions on the generated dynamic content.

=== Events in JSP Pages

A JSP page may indicate how some events are
to be handled.

As of JSP 1.2 only _init_ and _destroy_
events can be described in the JSP page. When the first request is
delivered to a JSP page, a _jspInit()_ method, if present, will be
called to prepare the page. Similarly, a JSP container invokes a JSP’s
_jspDestroy()_ method to reclaim the resources used by the JSP page at
any time when a request is not being serviced. This is the same
life-cycle as for servlets.

=== JSP Configuration Information

JSP pages may be extended with configuration
information that is delivered in the JSP configuration portion of the
_web.xml_ deployment description of the web application. The JSP
configuration information includes interpretation for the tag libraries
used in the JSP files and different property information for groups of
JSP files. The property information includes: page encoding information,
whether the EL evaluation and the scripting machinery is enabled, and
prelude and coda automatic inclusions. The JSP configuration information
can also be used to indicate that some resources in the web application
are JSP files even if they do not conform to the default _.jsp_
extension, and to modify the default interpretation for _.jspx_ .

=== Naming Conventions for JSP Files

A JSP page is packaged as one or more JSP
files, often in a web application, and delivered to a tool like a JSP
container, a Java EE container, or an IDE. A complete JSP page may be
contained in a single file. In other cases, the top file will include
other files that contain complete JSP pages, or included segments of
pages.

It is common for tools to need to
differentiate JSP files from other files. In some cases, the tools also
need to differentiate between top JSP files and included segments. For
example, a segment may not be a legal JSP page and may not compile
properly. Determining the type of file is also very useful from a
documentation and maintenance point of view, as people familiar with the
_.c_ and _.h_ convention in the C language know.

By default the extension _.jsp_ means a
top-level JSP file. We recommend, but do not mandate, to differentiate
between top-level JSP files (invoked directly by the client or
dynamically included by another page or servlet) and statically included
segments so that:

*  _The .jsp_ extension is used only for
files corresponding to top level JSP files, forming a JSP page when
processed.
* Statically included segments use any other
extension. As included segments were called ‘JSP fragments’ in past
versions of this specification, the extension _.jspf_ was offered as a
suggestion. This extension is still suggested for consistency reasons,
despite that they are now called ‘jsp segments’.

JSP documents, that is, JSP pages that are
delivered as XML documents, use the extension _.jspx_ by default.

The _jsp-property-group_ element of _web.xml_
can be used to indicate that some group of files, perhaps not using
either of the extensions above, are JSP pages, and can also be used to
indicate which ones are delivered as XML documents.

=== [[a242]]Compiling JSP Pages

A JSP page may be compiled into its
implementation class plus deployment information during development (a
JSP page can also be compiled at deployment time). In this way JSP page
authoring tools and JSP tag libraries may be used for authoring
servlets. The benefits of this approach include:

* Removal of the start-up lag that occurs
when a container must translate a JSP page upon receipt of the first
request.
* Reduction of the footprint needed to run a
JSP container, as the Java compiler is not needed.

Compilation of a JSP page in the context of a
web application provides resolution of relative URL specifications in
include directives and elsewhere, tag library references, and
translation-time actions used in custom actions.

A JSP page can also be compiled at deployment
time.

=== JSP Page Packaging

When a JSP page implementation class depends
on support classes in addition to the JSP 2.2 and Servlet 2.5 classes,
the support classes are included in the packaged WAR, as defined in the
Servlet 2.5 specification, for portability across JSP containers.

/C:/jspspec/JSP_Compiling_JSPs.html#57437[]
contains two examples of JSP pages packaged in WARs:

.  A JSP page delivered in source form (the
most common case).
. A JSP page translated into an
implementation class plus deployment information. The deployment
information indicates support classes needed and the mapping between the
original URL path to the JSP page and the URL for the JSP page
implementation class for that page.

=== [[a253]]Debugging JSP Pages

In the past debugging tools provided by
development environments have lacked a standard format for conveying
source map information allowing the debugger of one vendor to be used
with the JSP container of another. As of JSP 2.0, containers must
support JSR-045 (“Debugging Support for Other Languages”). Details can
be found in /C:/jspspec/JSP_Engine.html#64050[].

=== [[a255]]Web Applications

A web application is a collection of
resources that are available at designated URLs. A web application is
made up of some of the following:

* Java runtime environment(s) running in the
server (required)
* JSP page(s) that handle requests and
generate dynamic content
* Servlet(s) that handle requests and
generate dynamic content
* Server-side JavaBeans components that
encapsulate behavior and state
* Static HTML, DHTML, XHTML, XML and similar
pages.
* Resource files used by Java classes.
* Client-side Java Applets, JavaBeans
components, and Java class files
* Java runtime environment(s) (downloadable
via the Plugin and Java Web Start) running in client(s)

Web applications are described in more detail
in the Servlet 2.5 specification.

A web application contains a deployment
descriptor _web.xml_ that contains information about the JSP pages,
servlets, and other resources used in the web application. The
deployment descriptor is described in detail in the Servlet 2.5
specification.

JSP 2.2 requires that these resources be
implicitly associated with and accessible through a unique
_ServletContext_ instance available as the implicit _application_ object
(see link:jsp.html#a684[See Objects.]).

The application to which a JSP page belongs
is reflected in the _application_ object, and has impact on the
semantics of the following elements:

* The _include_ directive (see
link:jsp.html#a894[See The include Directive.]).
* The _taglib_ directive (see
link:jsp.html#a864[See The taglib Directive.]).
* The _jsp:include_ action element (see
/C:/jspspec/JSP_StandardActions.html#39949[]).
* The _jsp:forward_ action (see
/C:/jspspec/JSP_StandardActions.html#23283[]).

JSP 2.2 supports portable packaging and
deployment of web applications through the Servlet 2.5 specification.
The JavaServer Pages specification inherits from the servlet
specification the concepts of applications, _ServletContexts_ ,
Sessions, Requests and Responses.

=== [[a274]]Relative URL Specifications

Elements may use relative URL specifications,
called URI paths, in the Servlet 2.5 specification. These paths are as
described in RFC 2396. We refer to the path part of that specification,
not the scheme, nor authority parts. Some examples are:

* A context-relative path is a path that
starts with a slash (/). It is to be interpreted as relative to the
application to which the JSP page or tag file belongs. That is, its
_ServletContext_ object provides the base context URL.
* A page relative path is a path that does
not start with a slash (/). It is to be interpreted as relative to the
current JSP page, or the current JSP file or tag file, depending on
where the path is being used. For an _include_ directive (see
link:jsp.html#a894[See The include Directive.]) where the path
is used in a _file_ attribute, the interpretation is relative to the JSP
file or tag file. For a _jsp:include_ action (see
/C:/jspspec/JSP_StandardActions.html#39949[]) where the path is used in a
_page_ attribute, the interpretation is relative to the JSP page. In
both cases the current page or file is denoted by some path starting
with _/_ that is then modified by the new specification to produce a
path starting with _/_ . The new path is interpreted through the
_ServletContext_ object. See link:jsp.html#a907[See Including
Data in JSP Pages.] for exact details on this interpretation.

The JSP specification uniformly interprets
paths in the context of the web container where the JSP page is
deployed. The specification goes through a mapping translation. The
semantics outlined here apply to the translation-time phase, and to the
request-time phase.

=== Syntactic Elements of a JSP Page

This section describes the basic syntax rules
of JSP pages.

=== Elements and Template Data

A JSP page has elements and template data. An
element is an instance of an element type known to the JSP container.
Template data is everything else; that is, anything that the JSP
translator does not know about.

The type of an element describes its syntax
and its semantics. If the element has attributes, the type describes the
attribute names, their valid types, and their interpretation. If the
element defines objects, the semantics includes what objects it defines
and their types.

=== [[a284]]Element Syntax

There are three types of elements: directive
elements, scripting elements, and action elements.

=== Directives

Directives provide global information that is
conceptually valid independent of any specific request received by the
JSP page. They provide information for the translation phase.

Directive elements have a syntax of the form
_<%@ directive...%>_ .

=== Actions

Actions provide information for the request
processing phase. The interpretation of an action may, and often will,
depend on the details of the specific request received by the JSP page.
An Actions can either be standard (that is. defined in this
specification), or custom (that is, provided via the portable tag
extension mechanism).

Action elements follow the syntax of an XML
element. They have a start tag including the element name, and may have
attributes, an optional body, and a matching end tag, or may be an empty
tag, possibly with attributes:

 _<mytag attr1=”attribute
value”...>body</mytag>_

And:

 _<mytag attr1=”attribute value”.../> +
<mytag attr1=”attribute value” ...></mytag>_

An element has an element type describing its
tag name, its valid attributes and its semantics. We refer to the type
by its tag name.

JSP tags are case-sensitive, as in XML and
XHTML.

An action may create objects and may make
them available to the scripting elements through scripting-specific
variables.

=== Scripting Elements

Scripting elements provide “glue” around
template text and actions.



The Expression Language (EL) can be used to
simplify accessing data from different sources. EL expressions can be
used in JSP standard and custom actions and template data. EL
expressions use the syntax _$\{expr}_ and _#\{expr};_ For example:

 _<mytag attr1=”$\{bean.property}”.../> +
$\{map[entry]} +
<lib:myAction>$\{3+counter}</lib:myAction>_

/C:/jspspec/JSP_Expression_Language.html#98642[]
provides more details on the EL.



There are three language-based types of
scripting elements: declarations, scriptlets, and expressions.
Declarations follow the syntax _<%! ... %>._ Scriptlets follow the
syntax _<% ... %>_ . Expressions follow the syntax _<%= ... %>_ .

=== [[a306]]Start and End Tags

Elements that have distinct start and end
tags (with enclosed body) must start and end in the same file. The start
tag cannot be on one file while the end tag is in another.

The same rule applies to elements in the
alternate syntax. For example, a scriptlet has the syntax _<% scriptlet
%>_ . Both the opening _<%_ __ characters and the closing _%>_
characters must be in the same physical file.

A scripting language may also impose
constraints on the placement of start and end tags relative to specific
scripting constructs. For example, /C:/jspspec/JSP_Scripting.html#68206[]
shows that Java language blocks cannot separate a start and an end tag.
See /C:/jspspec/JSP_Scripting.html#33172[] for details.

=== Empty Elements

Following the XML specification, an element
described using an empty tag is indistinguishable from one using a start
tag, an empty body, and an end tag

As examples, the following are all empty
tags:

<x:foo></x:foo> +
<x:foo /> +
<x:foo/> +
<x:foo><%-- any comment --%></x:foo>

While the following are all non-empty tags:

<foo> </foo> +
<foo><%= expression %></foo> +
<foo><% scriptlet %></foo> +
<foo><bar/></foo> +
<foo><!-- a comment --></foo>

=== Attribute Values

Following the XML specification, attribute
values always appear quoted. Either single or double quotes can be used
to reduce the need for escaping quotes; the quotation conventions
available are described in link:jsp.html#a639[See Quoting and
Escape Conventions.]. There are two types of attribute values, literals
and request-time expressions (link:jsp.html#a1004[See Request
Time Attribute Values.]), but the quotation rules are the same.

=== The jsp:attribute, jsp:body and jsp:element Elements

Until JSP 2.0, tag handlers could be passed
input two ways: through attribute values and through the element body.
Attribute values were always evaluated once (if they were specified as
an expression) and the result was passed to the tag handler. The body
could contain scripting elements and action elements and be evaluated
zero or more times on demand by the tag handler.

As of JSP 2.0, page authors can provide input
in new ways using the _<jsp:attribute>_ __ standard action element.
Based on the configuration of the action being invoked, the body of the
element either specifies a value that is evaluated once, or it specifies
a “JSP fragment,” which represents the body in a form that makes it
possible for a tag handler to evaluate it as many times as needed. The
_<jsp:attribute>_ action must only be used to specify an attribute value
for standard or custom actions. A translation error must occur if it is
used in any other context, for example to specify the value of template
text that looks like an XML element.

It is illegal JSP syntax, which must result
in a translation error, to use both an XML element attribute and a
_<jsp:attribute>_ standard action to pass the value of the same
attribute. See /C:/jspspec/JSP_StandardActions.html#29033[] for more
details on the _<jsp:attribute>_ standard action.

The following example uses an XML element
attribute to define the value of the _param1_ attribute, and uses an
attribute standard action to define the value of the _param2_ attribute.
In this example, the value of _param2_ comes from the result of a custom
action invocation.

 <mytag:paramTag param1=”value1”> +
<jsp:attribute name=”param2”> +
<mymath:add x=”2” y=”2”/> +
</jsp:attribute> +
</mytag:paramTag>

If a page author wishes to pass both an
attribute standard action and a tag body, the _<jsp:body>_ standard
action must be used to specify the body. A translation error will result
if the custom action invocation has _<jsp:attribute>_ elements but does
not define the body using a _<jsp:body>_ element. See
/C:/jspspec/JSP_StandardActions.html#89308[] for more details on the
_<jsp:body>_ standard action.

The following example shows two equivalent
tag invocations to the hypothetical _<mytag:formatBody>_ custom action.
The first invocation uses an XML element attribute to pass the values of
the _color_ and _size_ attributes. The second example uses an attribute
standard action to pass the value of the _color_ attribute. Both
examples have tag body containing simply the words “Template Text”.

 <mytag:tagWithBody color=”blue” size=”12”> +
Template Text +
</mytag:tagWithBody>

 <mytag:tagWithBody size=”12”> +
<jsp:attribute name=”color”>blue</jsp:attribute> +
<jsp:body> +
Template Text +
</jsp:body> +
</mytag:tagWithBody>

 _<jsp:attribute>_ can be used with the
_<jsp:element>_ standard action to generate dynamic content in a well
structured way. The example below generates an HTML head of some type
unknown at page authoring time:

 <jsp:element name=”H$\{headLevel}”> +
<jsp:attribute name=”size”>$\{headSize}</jsp:attribute> +
<jsp:body>$\{headText}<jsp:body> +
</jsp:element>

=== Valid Names for Actions and Attributes

The names for actions must follow the XML
convention (i.e. must be an _NMTOKEN_ as indicated in the XML 1.0
specification). The names for attributes must follow the conventions
described in the JavaBeans specification.

Attribute names that start with _jsp_ ,
__jsp_ , _java_ , or _sun_ are reserved in this specification.

=== [[a333]]White Space

In HTML and XML white space is usually not
significant, but there are exceptions. For example, an XML file may
start with the characters _<?xml_ , and, when it does, it must do so
with no leading whitespace characters.

This specification follows the whitespace
behavior defined for XML. White space within the body text of a document
is not significant, but is preserved. This default behavior can be
modified for JSP pages in standard syntax as described in
link:jsp.html#a1316[See Removing whitespaces from template
text.].

Next are two examples of JSP code with their
associated output. Note that directives generate no data and apply
globally to the _JSP_ page.

=== Example 1 - Input

LineNo

Source Text

=== 1

<?xml version=”1.0” ?>

=== 2

<%@ page buffer=”8kb” %>

=== 3

The rest of the document goes here

The result is

=== Example 1 - Output

LineNo

Output Text

=== 1

<?xml version=”1.0” ?>

=== 2



=== 3

The rest of the document goes here

The next two tables show another example,
with input and output.,

=== Example 2 - Input

LineNo

Source Text

=== 1

 _<% response.setContentType(“....”);_

=== 2

 _whatever... %><?xml version=”1.0” ?>_

=== 3

 _<%@ page buffer=”8kb” %>_

=== 4

The rest of the document goes here

The result is

=== Example 2 - Output

LineNo

Output Text

=== 1

 _<?xml version=”1.0” ?>_

=== 2



=== 3

The rest of the document goes here

As of JSP 2.1, it is possible to have
extraneous whitespaces removed from template text through element
_trim-directive-whitespaces_ of JSP Property Groups (See
/C:/jspspec/JSP_Configuration.html#70753[]), or the page and tag file
directive attribute _trimDirectiveWhitespaces_ (See
link:jsp.html#a770[See The page Directive.],
/C:/jspspec/JSP_Tag_Files.html#79361[]).

=== JSP Documents

A JSP page is usually passed directly to a
JSP container. A JSP Document is a JSP page that is also an XML
document. When a JSP document is encountered by the JSP container, it is
interpreted as an XML document first and after that as a JSP page. Among
the consequences of this are:

* The document must be well-formed
* Validation, if indicated
* Entity resolution will apply, if indicated
*  _<%_ style syntax cannot be used

JSP documents are often a good match for the
generation of dynamic XML content as they can preserve much of the
structure of the generated document.

The default convention for JSP documents is
_.jspx_ . There are configuration elements that can be used to indicate
that a specific file is a JSP document.

See /C:/jspspec/JSP_Documents.html#64789[] for
more details on JSP documents, and
/C:/jspspec/JSP_Configuration.html#43756[] for more details on
configuration.

=== [[a388]]JSP Syntax Grammar

This section presents a simple EBNF grammar
for the JSP syntax. The grammar is intended to provide a concise syntax
overview and to resolve any syntax ambiguities present in this
specification. Other sections may apply further restrictions to this
syntax, for example to restrict what represents a valid attribute value
for a page directive. In all other cases the grammar takes precedence in
resolving syntax questions.

The notation for this grammar is identical to
that described by Chapter 6 of the XML 1.0 specification, available at
the following URL:

http://www.w3c.org/TR/2000/REC-xml-20001006#sec-notation

In addition, the following notes and rules
apply:

* The root production for a JSP page is
_JSPPage_ .
* The prefix _XML::_ is used to refer to an
EBNF definition in the XML 1.0 specification. Refer to
_http://www.w3.org/TR/REC-xml_ .
* Where applicable, to resolve grammar
ambiguities, the first matching production must always be followed. This
is commonly known as the “greedy” algorithm.
* If the _<TRANSLATION_ERROR>_ production is
followed, the page is invalid, and the result will be a translation
error.
* Many productions make use of XML-style
attributes. These attributes can appear in any order, separated from
each other by whitespace, but no attribute can be repeated more than
once. To make these XML-style attribute specifications more concise and
easier to read, the syntax _ATTR[_ _attrset_ _]_ is used in the EBNF to
define a set of XML attributes that are recognized in a particular
production.

Within the square brackets ( _attrset_ ) is
listed a comma-separated list of case-sensitive attribute names that are
valid. Each attribute name represents a single XML attribute. If the
attribute name is prefixed with an _=_ , the production _Attribute_
(defined below) must be matched (either a _rtexprvalue_ or a static
value is accepted). If not, the production _NonRTAttribute_ must be
matched (only static values are accepted). If the attribute name is
prefixed with a _!_ , the attribute is required and must appear in order
for this production to be matched. If an attribute that matches the
_Attribute_ production with a name not listed appears adjacent to any of
the other attributes, the production is not matched.

For example, consider a production that
contains _ATTR[ !name, =value, =!repeat ]_ . This production is matched
if and only if all of the following hold true:

* The _name_ attribute appears exactly once
and matches the _NonRTAttribute_ production.
* The _value_ attribute appears at most once.
If it appears, the _Attribute_ production must be matched.
* The _repeat_ attribute appears exactly once
and matches the _Attribute_ production.

=== There must be no other attributes aside from _name_ , _value_ , or _repeat_ .

For example, the following sample strings
match the above:

*  _name=”somename” value=”somevalue”
repeat=”2”_

===  _repeat=”$\{ x + y }” name=”othername”_

=== EBNF Grammar for JSP Syntax

===  _JSPPage ::= Body_

JSPTagDef ::= Body

 _Body ::= AllBody | ScriptlessBody +
[ vc: ScriptingEnabled ] +
[ vc: ScriptlessBody ]_

 _AllBody ::= ( ( ‘<%--’ JSPCommentBody ) +
| ( ‘<%@’ DirectiveBody ) +
| ( ‘<jsp:directive.’ XMLDirectiveBody ) +
| ( ‘<%!’ DeclarationBody ) +
| ( ‘<jsp:declaration’ XMLDeclarationBody ) +
| ( ‘<%=’ ExpressionBody ) +
| ( ‘<jsp:expression’ XMLExpressionBody ) +
| ( ‘<%’ ScriptletBody ) +
| ( ‘<jsp:scriptlet’ XMLScriptletBody ) +
| ( ‘$\{‘ ELExpressionBody ) +
| ( ‘#\{‘ ELExpressionBody ) +
| ( ‘<jsp:text’ XMLTemplateText ) +
| ( ‘<jsp:’ StandardAction ) +
| ( ‘</’ ExtraClosingTag ) +
| ( ‘<‘ CustomAction +
CustomActionBody ) +
| TemplateText +
)*_

 _ScriptlessBody ::= ( ( ‘<%--’
JSPCommentBody ) +
| ( ‘<%@’ DirectiveBody ) +
| ( ‘<jsp:directive.’ XMLDirectiveBody ) +
| ( ‘<%!’ <TRANSLATION_ERROR> ) +
| ( ‘<jsp:declaration’ +
<TRANSLATION_ERROR> ) +
| ( ‘<%=’ <TRANSLATION_ERROR> ) +
| ( ‘<jsp:expression’ +
<TRANSLATION_ERROR> ) +
| ( ‘<%’ <TRANSLATION_ERROR> ) +
| ( ‘<jsp:scriptlet’ +
<TRANSLATION_ERROR> ) +
| ( ‘$\{‘ ELExpressionBody ) +
| ( ‘#\{‘ ELExpressionBody ) +
| ( ‘<jsp:text’ XMLTemplateText ) +
| ( ‘<jsp:’ StandardAction ) +
( ( ‘</’ ExtraClosingTag ) +
| ( ‘<‘ CustomAction +
CustomActionBody ) +
| TemplateText +
)* +
[ vc: ELEnabled ]_

 _TemplateTextBody ::= ( ( ‘<%--’
JSPCommentBody ) +
| ( ‘<%@’ DirectiveBody ) +
| ( ‘<jsp:directive.’ XMLDirectiveBody ) +
| ( ‘<%!’ <TRANSLATION_ERROR> ) +
| ( ‘<jsp:declaration’ +
<TRANSLATION_ERROR> ) +
| ( ‘<%=’ <TRANSLATION_ERROR> ) +
| ( ‘<jsp:expression’ +
<TRANSLATION_ERROR> ) +
| ( ‘<%’ <TRANSLATION_ERROR> ) +
| ( ‘<jsp:scriptlet’ +
<TRANSLATION_ERROR> ) +
| ( ‘$\{‘ <TRANSLATION_ERROR> ) +
| ( ‘#\{‘ <TRANSLATION_ERROR> ) +
| ( ‘<jsp:text’ <TRANSLATION_ERROR> ) +
| ( ‘<jsp:’ <TRANSLATION_ERROR> ) +
| ( ‘<‘ CustomAction +
<TRANSLATION_ERROR> ) +
| TemplateText +
)* +
[ vc: ELEnabled ]_

 _JSPCommentBody ::= ( Char* - ( Char* ‘--%>’
) ) ‘--%>’ +
| <TRANSLATION_ERROR>_

 _DirectiveBody ::= JSPDirectiveBody |
TagDefDirectiveBody +
[ vc: TagFileSpecificDirectives ]_

 _XMLDirectiveBody ::= XMLJSPDirectiveBody |
XMLTagDefDirectiveBody +
[ vc: TagFileSpecificXMLDirectives ]_

 _JSPDirectiveBody ::= S? +
( ( ‘page’ S PageDirectiveAttrList ) +
| ( ‘taglib’ S TagLibDirectiveAttrList ) +
| ( ‘include’ S IncludeDirectiveAttrList ) +
) +
S? ‘%>’ +
| <TRANSLATION_ERROR>_

 _XMLJSPDirectiveBody ::= S? +
( ( ‘page’ S PageDirectiveAttrList S? +
( ‘/>’ | ( ‘>’ S? ETag ) ) +
) +
| ( ‘include’ S IncludeDirectiveAttrList S? +
( ‘/>’ | ( ‘>’ S? ETag ) ) +
) +
) +
| <TRANSLATION_ERROR>_

TagDefDirectiveBody ::= S? +
( ( ‘tag’ S TagDirectiveAttrList ) +
| ( ‘taglib’ S TagLibDirectiveAttrList ) +
| ( ‘include’ S IncludeDirectiveAttrList ) +
| ( ‘attribute’ S AttributeDirectiveAttrList ) +
| ( ‘variable’ S VariableDirectiveAttrList ) +
) +
S? ‘%>’ +
| <TRANSLATION_ERROR>

XMLTagDefDirectiveBody ::= ( ( ‘tag’ S
TagDirectiveAttrList S? +
( ‘/>’ | ( ‘>’ S? ETag ) ) +
) +
| ( ‘include’ S IncludeDirectiveAttrList S? +
( ‘/>’ | ( ‘>’ S? ETag ) ) +
) +
| ( ‘attribute’ S AttributeDirectiveAttrList S? +
( ‘/>’ | ( ‘>’ S? ETag ) ) +
) +
| ( ‘variable’ S VariableDirectiveAttrList S? +
( ‘/>’ | ( ‘>’ S? ETag ) ) +
) +
) +
| <TRANSLATION_ERROR>

 _PageDirectiveAttrList ::= ATTR[ language,
extends, import, session, +
buffer, autoFlush, isThreadSafe, +
info, errorPage, isErrorPage, +
contentType, pageEncoding, +
isELIgnored ] +
[ vc: PageDirectiveUniqueAttr ]_

 _TagLibDirectiveAttrList ::= ATTR[ !uri,
!prefix ] +
| ATTR[ !tagdir, !prefix ] +
[ vc: TagLibDirectiveUniquePrefix ]_

 _IncludeDirectiveAttrList ::= ATTR[ !file ]_

{empty}TagDirectiveAttrList ::= ATTR[
display-name, body-content, +
dynamic-attributes, small-icon, large-icon, +
description, example, language, +
import, pageEncoding, isELIgnored ] +
[ vc: TagDirectiveUniqueAttr ]

{empty}AttributeDirectiveAttrList ::= ATTR[
!name, required, fragment, rtexprvalue, +
type, description ] +
[ vc: UniqueAttributeName ]

{empty}VariableDirectiveAttrList ::= ATTR[
!name-given, variable-class, +
scope, declare, description ] +
| ATTR[ !name-from-attribute, !alias, +
variable-class, +
scope, declare, description ] +
[ vc: UniqueVariableName ]

 _DeclarationBody ::= ( Char* - ( Char* ‘%>’
) ) ‘%>’ +
| <TRANSLATION_ERROR>_

 _XMLDeclarationBody ::= ( S? ‘/>’ ) +
| ( S? ‘>’ +
( ( Char* - ( Char* ‘<‘ ) ) CDSect? )* +
ETag +
) +
| <TRANSLATION_ERROR>_

 _ExpressionBody ::= ( Char* - ( Char* ‘%>’ )
) ‘%>’ +
| <TRANSLATION_ERROR> +
[ vc: ExpressionBodyContent ]_

 _XMLExpressionBody ::= ( S? ‘/>’ ) +
| ( S? ‘>’ +
( ( Char* - ( Char* ‘<’ ) ) CDSect? )* +
ETag +
) +
| <TRANSLATION_ERROR> +
[ vc: ExpressionBodyContent ]_

 _ELExpressionBody ::= ELExpression ‘}’ +
| <TRANSLATION_ERROR>_

{empty}ELExpression ::= [See EL spec
document, production Expression]

 _ScriptletBody ::= ( Char* - ( Char* ‘%>’ )
) ‘%>’ +
| <TRANSLATION_ERROR>_

 _XMLScriptletBody ::= ( S? ‘/>’ ) +
| ( S? ‘>’ +
( ( Char* - ( Char* ‘<’ ) ) CDSect? )* +
ETag +
) +
| <TRANSLATION_ERROR>_

 _StandardAction ::= ( ‘useBean’
StdActionContent ) +
| ( ‘setProperty’ StdActionContent ) +
| ( ‘getProperty’ StdActionContent ) +
| ( ‘include’ StdActionContent ) +
| ( ‘forward’ StdActionContent ) +
| ( ‘plugin’ StdActionContent ) +
| ( ‘invoke’ StdActionContent ) +
| ( ‘doBody’ StdActionContent ) +
| ( ‘element’ StdActionContent ) +
| ( ‘output’ StdActionContent ) +
| <TRANSLATION_ERROR> +
[ vc: TagFileSpecificActions ]_

{empty}StdActionContent ::= Attributes
StdActionBody +
[ vc: StdActionAttributesValid ]

{empty}StdActionBody ::= EmptyBody +
| OptionalBody +
| ParamBody +
| PluginBody +
[ vc: StdActionBodyMatch ]

EmptyBody ::= ‘/>’ +
| ( ‘>’ ETag ) +
| ( ‘>’ S? ‘<jsp:attribute’ NamedAttributes ETag )

 _TagDependentActionBody ::=
JspAttributeAndBody +
| ( ‘>’ TagDependentBody ETag )_

TagDependentBody ::= _Char* - ( Char* ETag )_

 _JspAttributeAndBody ::= ( ‘>’ S? (
‘<jsp:attribute’ NamedAttributes )? +
‘<jsp:body’ +
( JspBodyBody | <TRANSLATION_ERROR> ) +
S? ETag +
)_

 _ActionBody ::= JspAttributeAndBody +
| ( ‘>’ Body ETag )_

 _ScriptlessActionBody ::=
JspAttributeAndBody +
| ( ‘>’ ScriptlessBody ETag )_

OptionalBody ::= _EmptyBody | ActionBody_

ScriptlessOptionalBody ::= EmptyBody |
ScriptlessActionBody

TagDependentOptionalBody ::= EmptyBody |
TagDependentActionBody

ParamBody ::= EmptyBody +
| ( ‘>’ S? ( ‘<jsp:attribute’ NamedAttributes )? +
‘<jsp:body’ +
(JspBodyParam | <TRANSLATION_ERROR>) +
S? ETag +
) +
| ( S? ‘>’ Param* ETag )

PluginBody ::= EmptyBody +
| ( ‘>’ S? ( ‘<jsp:attribute’ NamedAttributes )? +
‘<jsp:body’ +
( JspBodyPluginTags +
| <TRANSLATION_ERROR> +
) +
S? ETag +
) +
| ( ‘>’ S? PluginTags ETag )

NamedAttributes ::= AttributeBody S? (
‘<jsp:attribute’ AttributeBody S? )*

AttributeBody ::= ATTR[ !name, trim ] S? +
( ‘/>’ +
| ‘></jsp:attribute>’ +
| ‘>’ AttributeBodyBody ‘</jsp:attribute>’ +
| <TRANSLATION_ERROR> +
)

{empty}AttributeBodyBody ::= AllBody +
| ScriptlessBody +
| TemplateTextBody +
[ vc: AttributeBodyMatch ]

JspBodyBody ::= ( S? JspBodyEmptyBody ) +
| ( S? ‘>’ ( JspBodyBodyContent - ‘’ ) ‘</jsp:body>’ )

{empty}JspBodyBodyContent ::= ScriptlessBody
| Body | TagDependentBody +
[ vc: JspBodyBodyContent ]

JspBodyEmptyBody ::= ‘/>’ +
| ‘></jsp:body>’ +
| <TRANSLATION_ERROR>

JspBodyParam ::= S? ‘>’ S? Param*
‘</jsp:body>’

JspBodyPluginTags ::= S? ‘>’ S? PluginTags
‘</jsp:body>’

PluginTags ::= ( ‘<jsp:params’ Params S? )? +
( ‘<jsp:fallback’ Fallback S? )?

Params ::= ‘>’ S? +
( ( ‘<jsp:body>’ +
( ( S? Param+ S? ‘</jsp:body>’ ) +
| <TRANSLATION_ERROR> +
) +
) +
| Param+ +
) +
’</jsp:params>’

Fallback ::= ’/>’ +
| ( ‘>’ S? ‘<jsp:body>’ +
( ( S? +
( Char* - ( Char* ‘</jsp:body>’ ) ) +
‘</jsp:body>’ S? +
) +
| <TRANSLATION_ERROR> +
) +
‘</jsp:fallback>’ +
) +
| ( ’>’ +
( Char* - ( Char* ’</jsp:fallback>’ ) ) +
’</jsp:fallback>’ +
)

Param ::= ’<jsp:param’ StdActionContent

 _Attributes ::= ( S Attribute )* S? +
[ vc: UniqueAttSpec ]_

{empty}CustomAction ::= TagPrefix ’:’
CustomActionName +
[vc: CustomActionMatchesAndValid]

 _TagPrefix ::= Name_

 _CustomActionName ::= Name_

 _CustomActionBody ::= ( Attributes
CustomActionEnd ) +
| <TRANSLATION_ERROR>_

 _CustomActionEnd ::=
CustomActionTagDependent +
| CustomActionJSPContent +
| CustomActionScriptlessContent_

{empty} _CustomActionTagDependent ::=
TagDependentOptionalBody +
_ [vc: CustomActionTagDependentMatch]

{empty}CustomActionJSPContent ::=
OptionalBody +
[ vc: CustomActionJSPContentMatch ]

{empty}CustomActionScriptlessContent ::=
ScriptlessOptionalBody +
[ vc: CustomActionScriptlessContentMatch ]

 _TemplateText ::= ( ‘<‘ | ‘$\{‘ | ‘#\{‘ ) +
| ( TemplateChar* - +
( TemplateChar* ( ‘<‘ | ‘$\{‘ | ‘#\{‘ ) ) )_

{empty}TemplateChar ::= ‘\$’ +
| ‘\#’ +
| ‘<\%’ +
| Char +
[ vc : QuotedDollarMatched ]

 _XMLTemplateText ::= ( S? ‘/>’ ) +
| ( S? ‘>’ +
( ( Char* - ( Char* ( ‘<’ | ‘$\{‘ | ‘#\{‘ ) ) ) +
( ( ‘$\{‘ ELExpressionBody )? +
| ( ‘#\{‘ ELExpressionBody )? +
) +
CDSect? +
)* ETag +
) +
| <TRANSLATION_ERROR> +
[ vc: ELEnabled ]_

 _ExtraClosingTag ::= ETag +
[ vc: ExtraClosingTagMatch ]_

 _ETag ::= ‘</’ TagPrefix ‘:’ Name S? ‘>’ +
[ vc: ETagMatch ]_

Attribute ::= Name Eq +
( ( ‘”<%=’ RTAttributeValueDouble ) +
| ( “‘<%=” RTAttributeValueSingle ) +
| ( ‘”’ AttributeValueDouble ) +
| ( “‘” AttributeValueSingle ) +
)

NonRTAttribute ::= Name Eq +
( ( ‘”’ AttributeValueDouble ) +
| ( “‘” AttributeValueSingle ) +
)

AnyAttributeValue ::= AttributeValue |
RTAttributeValue

AttributeValue ::= AttributeValueDouble |
AttributeValueSingle

RTAttributeValue ::= RTAttributeValueDouble |
RTAttributeValueSingle

AttributeValueDouble ::= ( QuotedChar - ‘”’
)* +
( ‘”’ | <TRANSLATION_ERROR> )

AttributeValueSingle ::= ( QuotedChar - “‘”
)* +
( “‘” | <TRANSLATION_ERROR> )

{empty}RTAttributeValueDouble ::= ( (
QuotedChar - ‘”’ )* - +
( ( QuotedChar - ’"’ )* ’%>’ ) +
) +
( ’%>"’ | <TRANSLATION_ERROR> ) +
[ vc: RTAttributeScriptingEnabled ] +
[ vc: ExpressionBodyContent ]

{empty}RTAttributeValueSingle ::= ( (
QuotedChar - “‘” )* - +
( ( QuotedChar - “‘” )* ’%>’ ) +
) +
( "%>’" | <TRANSLATION_ERROR> ) +
[ vc: RTAttributeScriptingEnabled ] +
[ vc: ExpressionBodyContent ]

 _Name ::= XML::Name_

 _Char ::= XML::Char_

{empty} _QuotedChar ::=_ ’&apos;’ +
| ’&quot;’ +
| ’\\’ +
| ‘\”’ +
| "\’" +
| ‘\$’ +
| ‘\#’ +
| ( ‘$\{‘ ELExpressionBody ) +
| ( ‘#\{‘ ELExpressionBody ) +
| Char +
[ vc: QuotedDollarMatched ]

 _S ::= XML::S_

 _Eq ::= XML::Eq_

CDSect ::= XML::CDSect

=== Validity Constraints

The following validity constraints are
referenced in the above grammar using the syntax _[ vc:
ValidityConstraint ]_ , and must be followed:

*  _ScriptingEnabled_ - The _ScriptlessBody_
production must be followed if scripting is disabled for this
translation unit. See the _scripting-invalid_ JSP Configuration element
(/C:/jspspec/JSP_Configuration.html#77067[]).
*  _ScriptlessBody_ - The _AllBody_
production cannot be followed if one of our parent nodes in the parse
tree is a _ScriptlessBody_ production. That is, once we have followed
the _ScriptlessBody_ production, until that production is complete we
cannot choose the _AllBody_ production.
*  _ELEnabled_ - The token _$\{_ or _#\{_ is
not followed if expressions are disabled for this translation unit. See
the _isELIgnored_ page and tag directive
(link:jsp.html#a770[See The page Directive.] and
/C:/jspspec/JSP_Tag_Files.html#79361[] respectively) and the _el-ignored_
JSP Configuration element (/C:/jspspec/JSP_Configuration.html#57050[]).
*  _TagFileSpecificDirectives_ - The
_JSPDirectiveBody_ production must be followed if the root production is
_JSPPage_ (i.e. this is a JSP page). The _TagDefDirectiveBody_
production must be followed if the root production is _JSPTagDef_ (i.e.
this is a tag file).
*  _TagFileSpecificXMLDirectives_ - The
_XMLJSPDirectiveBody_ production must be followed if the root production
is _JSPPage_ (i.e. this is a JSP page). The _XMLTagDefDirectiveBody_
production must be followed if the root production is _JSPTagDef_ (i.e.
this is a tag file).
*  _PageDirectiveUniqueAttr_ - A translation
error will result if there is more than one occurrence of any attribute
defined by this directive in a given translation unit, and if the value
of the attribute is different than the previous occurrence. No
translation error results if the value is identical to the previous
occurrence. In addition, the _import_ and _pageEncoding_ attributes are
excluded from this constraint (see link:jsp.html#a770[See The
page Directive.]).
*  _TagLibDirectiveUniquePrefix_ - A
translation error will result if the prefix _AttributeValue_ has already
previously been encountered as a potential _TagPrefix_ in this
translation unit.
*  _TagDirectiveUniqueAttr_ - A translation
error will result if the prefix of this tag directive is already defined
in the current scope, and if that prefix is bound to a namespace other
than that specified by the _uri_ or _tagdir_ attribute.
*  _UniqueAttributeName_ - A translation
error will result if there are two or more _attribute_ directives with
the same value for the _name_ attribute in the same translation unit. A
translation error will result if there is a _variable_ directive with a
_name-given_ attribute equal to the value of the _name_ attribute of an
_attribute_ directive in the same translation unit.
*  _UniqueVariableName_ - A translation error
must occur if more than one _variable_ directive appears in the same
translation unit with the same value for the _name-given_ attribute or
the same value for the _name-from-attribute_ attribute. A translation
error must occur if there is a _variable_ directive with a _name-given_
attribute equal to the value of the _name_ attribute of an _attribute_
directive in the same translation unit. A translation error must occur
if there is a _variable_ directive with a _name-from-attribute_
attribute whose value is not equal to the _name_ attribute of an
_attribute_ directive in the same translation unit that is also of type
_java.lang.String_ , that is _required_ and that is not an _rtexprvalue_
. A translation error must occur if the value of the _alias_ attribute
is equal to the value of a _name-given_ attribute of a _variable_
directive, or the value of the _name_ attribute of an _attribute_
directive in the same translation unit.
*  _TagFileSpecificActions_ - The _invoke_
and _doBody_ standard actions are only matched if the _JSPTagDef_
production was followed (i.e. if this is a tag file instead of a JSP
page).
*  _RTAttributeScriptingEnabled_ - If the
_RTAttributeValueDouble_ or _RTAttributeValueSingle_ productions are
visited during parsing and scripting is disabled for this page, a
translation error must be produced. See the _scripting-invalid_ JSP
Configuration element (/C:/jspspec/JSP_Configuration.html#77067[]).
*  _ExpressionBodyContent_ - A translation
error will result if the body content minus the closing delimiter ( _%>_
, or _</jsp:expression>_ , depending on how the expression started) does
not represent a well-formed expression in the scripting language
selected for the JSP page.
*  _StdActionAttributesValid_ - An attribute
is considered “provided” for this standard action if either the
_Attribute_ production or the _AttributeBody_ production is followed in
the context of the enclosing _StandardAction_ production. A translation
error will result if any of the following conditions is true:
* The set of attributes “provided” for this
standard action does not match one of the valid attribute combinations
specified in link:jsp.html#a534[See Valid body content and
attributes for Standard Actions.].
* The same attribute is “provided” more than
once, as determined by the attribute name.
* An attribute is “provided” using the
AttributeBody production that does not accept a request-time expression
value, as indicated by the = prefix in link:jsp.html#a534[See
Valid body content and attributes for Standard Actions.].
*  _StdActionBodyMatch_ - The _StdActionBody_
production will only be matched if the production listed for this
standard action in the “Body Production” column in
link:jsp.html#a534[See Valid body content and attributes for
Standard Actions.] is followed.
*  _AttributeBodyMatch_ - The type of element
being specified determines which production is followed (see
/C:/jspspec/JSP_StandardActions.html#29033[]for details):
* If a custom action that specifies an
attribute of type _JspFragment_ , _ScriptlessBody_ must be followed.
* If a standard or custom action that accepts
a request-time expression value, _AllJspBody_ must be followed.
* If a standard or custom action that does
not accept a request-time expression value, _TemplateTextBody_ must be
followed.
*  _JspBodyBodyContent_ - The
_ScriptlessBody_ production must be followed if the body content for
this tag is _scriptless_ . The _Body_ production must be followed if the
body content for this tag is _JSP_ . The TagDependentBody production
must be followed if the body content for this tag is _tagdependent_ .
*  _UniqueAttSpec_ - A translation error will
result if the same attribute name appears more than once.
*  _CustomActionMatchesAndValid_ - Following
the rules in /C:/jspspec/JSP_Tag_Extensions.html#45090[] for determining
the relevant set of tags and tag libraries, assume the following:
* Let _U_ be the URI indicated by the _uri_
_AttributeValue_ of the previously encountered _TagLibDirectiveAttrList_
with _prefix_ matching the _TagPrefix_ for this potential custom action,
or _nil_ if no such _TagLibDirectiveAttrList_ was encountered in this
translation unit.
* If _U_ is not _nil_ , let _L_ be the
_<taglib>_ element in the relevant TLD entry such that _L.uri_ is equal
to _U_ .

Then:

* If, after being parsed, the _CustomAction_
production is matched (not yet taking into account the following rules),
_TagPrefix_ is considered a potential _TagPrefix_ in this translation
unit for the purposes of the _TagLibDirectiveUniquePrefix_ validity
constraint.
* The _CustomAction_ production will not be
matched if _U_ is _nil_ or if the _TagPrefix_ does not match the
_prefix_ _AttributeValue_ of a _TagLibDirectiveAttrList_ previously
encountered in this translation unit.
* Otherwise, if the _CustomAction_ production
is matched, a translation error will result if there does not exist a
_<tag>_ element _T_ in a relevant TLD such that _L.T.name_ is equal to
_CustomActionName._
*  _CustomActionTagDependentMatch_ - Assume
the definition of _L_ from the _CustomActionMatchesAndValid_ validity
constraint above. The _CustomActionTagDependent_ production is not
matched if there does not exist a _<tag>_ element _T_ in a relevant TLD
such that _L.T.body-content_ contains the value _tagdependent_ .
*  _CustomActionJSPContentMatch_ - Assume the
definition of _L_ from the _CustomActionMatchesAndValid_ validity
constraint above. The _CustomActionJSPContent_ production is not matched
if there exists a _<tag>_ element _T_ in a relevant TLD such that
_L.T.body-content_ does not contain the value _JSP_ .
*  _CustomActionScriptlessContentMatch_ -
Assume the definition of _L_ from the _CustomActionMatchesAndValid_
validity constraint above. The _CustomActionScriptlessContent_
production is not matched if there does not exist a _<tag>_ element _T_
in a relevant TLD such that _L.T.body-content_ contains the value
_scriptless_ .
*  _QuotedDollarMatch -_ The ‘\$’ or ‘\#’
token is only matched if EL is enabled for this translation unit. See
/C:/jspspec/JSP_Configuration.html#57050[].
*  _ETagMatch_ - Assume the definition of _U_
from the _CustomActionMatchesAndValid_ validity constraint. If
_TagPrefix_ is not ‘ _jsp_ ’ and _U_ is _nil_ , the _ETag_ production is
not matched. Otherwise, the _ETag_ production is matched and a
translation error will result if the prefix and name of this closing tag
does not match the prefix and name of the starting tag at the
corresponding nesting level, or if there is no corresponding nesting
level (i.e. too many closing tags). This is similar to the way XML is
defined, except that template text that looks like a closing element
with an unrecognized prefix is allowed in the body of a custom or
standard action. In the following example, assuming ‘my’ is a valid
prefix and ‘indent’ is a valid tag, the _</ul>_ tag is considered
template text, and no translation error is produced:

 <my:indent level=”2”> +
</ul> +
</my:indent>

* The following example, however, would
produce a translation error, assuming ‘my’ is a valid prefix and
‘indent’ is a valid tag, and regardless of whether ‘othertag’ is a valid
tag or not.

 <my:indent level=”2”> +
</my:othertag> +
</my:indent>

*  _ExtraClosingTagMatch_ - The
_ExtraClosingTag_ production is not matched if encountered within two or
more nested _Body_ productions (e.g. if encountered inside the body of a
standard or custom action).

=== Standard Action Attributes

link:jsp.html#a534[See Valid body
content and attributes for Standard Actions.] specifies, for each
standard action element, the bodies and the attribute combinations that
are valid. The value in the “Body Production” column specifies a
production name that must be matched for the body of the standard action
to be considered valid. The value in the “Valid Attribute Combinations”
column uses the same syntax as the _attrset_ notation described at the
start of link:jsp.html#a388[See JSP Syntax Grammar.], and
indicates which attributes can be provided. Note that for some valid
attribute combinations, there are differing body productions. The first
attribute combination to be matched selects the valid body production
for this standard action invocation.

=== [[a534]]Valid body content and attributes for Standard Actions

Element



Body Production



Valid Attribute Combinations



 _jsp:useBean_

 _OptionalBody_

 _OptionalBody_

 _OptionalBody_

 _OptionalBody_

 _( !id, scope, !class )_

 _( !id, scope, !type )_

 _( !id, scope, !class, !type )_

 _( !id, scope, =!beanName, !type )_

 __ 

 _jsp:setProperty_

 _EmptyBody_

 _EmptyBody_

 __ 

 _( !name, !property, param )_

 _( !name, !property, =!value )_

 __ 

 _jsp:getProperty_

 _EmptyBody_

 _( !name, !property )_

 __ 

 _jsp:include_

 _ParamBody_

 _( =!page, flush )_

 __ 

 _jsp:forward_

 _ParamBody_

 _( =!page )_

 __ 

 _jsp:plugin_

 _PluginBody_

 _( !type, !code, !codebase, align, archive,
=height, hspace, jreversion, name, vspace, title, =width, nspluginurl,
iepluginurl, mayscript )_

 __ 

 _jsp:invoke_

 _EmptyBody_

 _EmptyBody_

 _EmptyBody_

 __ 

 _( !fragment, !var, scope )_

 _( !fragment, !varReader, scope )_

 _( !fragment )_

 __ 

 _jsp:doBody_

 _EmptyBody_

 _EmptyBody_

 _EmptyBody_

 __ 

 _( !var, scope )_

 _( !varReader, scope )_

 _()_

 __ 

jsp:element

OptionalBody

( =!name )



jsp:output

EmptyBody

EmptyBody



( omit-xml-declaration )

( omit-xml-declaration, +
!doctype-root-element, +
!doctype-system, doctype-public )

 _jsp:param_

 _EmptyBody_

 _( !name, =!value ) +
_

=== Error Handling

Errors may occur at translation time or at
request time. This section describes how errors are treated by a
compliant implementation.

=== [[a607]]Translation Time Processing Errors

The translation of a JSP page source into a
corresponding JSP page implementation class by a JSP container can occur
at any time between initial deployment of the JSP page into the JSP
container and the receipt and processing of a client request for the
target JSP page. If translation occurs prior to the receipt of a client
request for the target JSP page, error processing and notification is
implementation dependent and not covered by this specification. In all
cases, fatal translation failures shall result in the failure of
subsequent client requests for the translation target with the
appropriate error specification: For HTTP protocols the error status
code _500 (Server Error)_ is returned.

=== Request Time Processing Errors

During the processing of client requests,
errors can occur in either the body of the JSP page implementation
class, or in some other code (Java or other implementation programming
language) called from the body of the JSP page implementation class.
Runtime errors occurring are realized in the page implementation, using
the Java programming language exception mechanism to signal their
occurrence to caller(s) of the offending behaviorlink:#a6611[1].

These exceptions may be caught and handled
(as appropriate) in the body of the JSP page implementation class.

Any uncaught exceptions thrown in the body of
the JSP page implementation class result in the forwarding of the client
request and uncaught exception to the errorPage URL specified by the JSP
page (or the implementation default behavior, if none is specified).

Information about the error is passed as
_javax.servlet.ServletRequest_ attributes to the error handler, with the
same attributes as specified by the Servlet specification. Names
starting with the prefixes _java_ and _javax_ are reserved by the
different specifications of the Java platform. The _javax.servlet_
prefix is reserved and used by the servlet and JSP specifications.

=== [[a614]]Using JSPs as Error Pages

A JSP is considered an Error Page if it sets
the _page_ directive’s _isErrorPage_ attribute to _true_ . If a page has
_isErrorPage_ set to _true_ , then the “exception” implicit scripting
language variable (see link:jsp.html#a748[See Implicit Objects
Available in Error Pages.]) of that page is initialized. The variable is
set to the value of the _javax.servlet.error.exception request_
attribute value if present, otherwise to the value of the
_javax.servlet.jsp.jspException_ request attribute value (for backwards
compatibility for JSP pages pre-compiled with a JSP 1.2 compiler).

In addition, an _ErrorData_ instance must be
initialized based on the error handler _ServletRequest_ attributes
defined by the Servlet specification, and made available through the
_PageContext_ to the page. This has the effect of providing easy access
to the error information via the Expression Language. For example, an
Error Page can access the status code using the syntax
_$\{pageContext.errorData.statusCode}_ . See
/C:/jspspec/javax.servlet.jsp.html#91781[] for details.

By default, a JSP error page sets the status
code of the response to the value of
_$\{pageContext.errorData.statusCode}_ (which is equal to 500 by
default), but may set it to a different value (including 200) as it sees
fit.

A JSP container must detect if a JSP error
page is self-referencing and throw a translation error.

=== [[a619]]Comments

There are different types of comments
available in JSP pages in standard syntax and JSP documents (in XML
syntax).

=== Comments in JSP Pages in Standard Syntax

There are two types of comments in a JSP
page: comments to the JSP page itself, documenting what the page is
doing; and comments that are intended to appear in the generated
document sent to the client.

=== Generating Comments in Output to Client

In order to generate comments that appear in
the response output stream to the requesting client, the HTML and XML
comment syntax is used, as follows:

<!-- comments ... -->

These comments are treated as uninterpreted
template text by the JSP container. Dynamic content that appears within
HTML/XML comments, such as actions, scriptlets and expressions, is still
processed by the container. If the generated comment is to have dynamic
data, this can be obtained through an expression syntax, as in:

<!-- comments <%= expression %> more comments
... -->

=== JSP Comments

A JSP comment is of the form

<%-- anything but a closing --%> ... --%>

The body of the content is ignored
completely. Comments are useful for documentation but also are used to
“comment out” some portions of a JSP page. Note that JSP comments do not
nest.

An alternative way to place a comment in JSP
is to use the comment mechanism of the scripting language. For example:

<% /** this is a comment ... **/ %>

=== Comments in JSP Documents

Comments in JSP documents use the XML syntax,
as follows:

<!-- comments ... ->

The body of the content is ignored
completely. Comments in JSP documents may be used for documentation
purposes and for “commenting out” portions of a JSP page.

Comments in JSP documents do not nest.

=== [[a639]]Quoting and Escape Conventions

The following quoting conventions apply to
JSP pages.

* 

=== Quoting in EL Expressions

* There is no special quoting mechanism
within EL expressions; use a literal _‘$\{‘_ if the literal _$\{_ is
desired and expressions are enabled for the page (similarly, use a
literal _‘#\{‘_ if the literal _#\{_ is desired).For example, the
evaluation of _$\{‘$\{‘}_ is _‘$\{‘_ . Note that _$\{‘}’}_ is legal, and
simply evaluates to _‘}’_ .

=== Quoting in Scripting Elements

* A literal _%>_ is quoted by _%\>_

=== Quoting in Template Text

* A literal _<%_ is quoted by _<\%_
* Only when the EL is enabled for a page (see
/C:/jspspec/JSP_Configuration.html#57050[]), a literal _$_ can be quoted
by _\$, and a literal # can be quoted by \#_ . This is not required but
is useful for quoting EL expressions.

=== Quoting in Attributes

Quotation is done consistently regardless of
whether the attribute value is a literal or a request-time attribute
expression. Quoting can be used in attribute values regardless of
whether they are delimited using single or double quotes. It is only
required as described below.

* A _‘_ is quoted as _\’_ . This is required
within a single quote-delimited attribute value.
* A _“_ is quoted as _\”_ . This is required
within a double quote-delimited attribute value.
* A _\_ is quoted as _\\_
* Only when the EL is enabled for a page (see
/C:/jspspec/JSP_Configuration.html#57050[]), a literal _$_ can be quoted
by _\$_ . Similarly, a literal _#_ can be quoted by _\#_ . This is not
required but is useful for quoting EL expressions.
* A _%>_ is quoted as _%\>_
* A _<%_ is quoted as _<\%_
* The entities _&apos;_ and _&quot;_ are
available to describe single and double quotes.

=== Examples

The following line shows an illegal attribute
values.

<mytags:tag value="<%= "hi!" %>" />

The following line shows a legal scriptlet,
but perhaps with an intended value. The result is _Joe said %\>_ not
_Joe said %>_ .

<%= "Joe said %\\>" %>

The next lines are all legal quotations.

<%= "Joe said %/>" %>

<%= "Joe said %\>" %>

<% String joes_statement = "hi!"; %> +
<%= "Joe said \"" + joes_statement + "\"." %> +
<x:tag value='<%="Joe said \\"" + joes_statement + "\\"."%>'/>

<x:tag value='<%= "hi!" %>' />

<x:tag value="<%= \"hi!\" %>" />

<x:tag value='<%= \"name\" %>' />

<x:tag value="<%= \"Joe said 'hello'\" %>"/>

<x:tag value="<%= \"Joe said \\\"hello\\\" \"
%>"/>

<x:tag value="end expression %\>"/>

<% String s="abc"; %> +
<x:tag value="<%= s + \"def\" + \"jkl\" + 'm' + \'n\' %>" /> +
<x:tag value='<%= s + \"def\" + "jkl" + \'m\' + \'n\' %>' />

=== XML Documents

The quoting conventions are different from
those of XML. See /C:/jspspec/JSP_Documents.html#64789[].

=== Overall Semantics of a JSP Page

A JSP page implementation class defines a
__jspService()_ method mapping from the request to the response object.
Some details of this transformation are specific to the scripting
language used (see /C:/jspspec/JSP_Scripting.html#68206[]). Most details
are not language specific and are described in this chapter.

The content of a JSP page is devoted largely
to describing the data that is written into the output stream of the
response. (The JSP container usually sends this data back to the
client.) The description is based on a _JspWriter_ object that is
exposed through the implicit object _out_ (see
link:jsp.html#a702[See Implicit Objects.]). Its value varies:

* Initially, _out_ is a new _JspWriter_
object. This object may be different from the stream object returned
from _response.getWriter()_ , and may be considered to be interposed on
the latter in order to implement buffering (see
link:jsp.html#a770[See The page Directive.]). This is the
initial _out_ object. JSP page authors are prohibited from writing
directly to either the _PrintWriter_ or _OutputStream_ associated with
the _ServletResponse_ .
* The JSP container should not invoke
_response.getWriter()_ until the time when the first portion of the
content is to be sent to the client. This enables a number of uses of
JSP, including using JSP as a language to “glue” actions that deliver
binary content, or reliably forwarding to a servlet, or change
dynamically the content type of the response before generating content.
See /C:/jspspec/JSP_I18N.html#77284[].
* Within the body of some actions, _out_ may
be temporarily re-assigned to a different (nested) instance of a
_JspWriter_ object. Whether this is the case depends on the details of
the action’s semantics. Typically the content of these temporary streams
is appended to the stream previously referred to by _out_ , and _out_ is
subsequently re-assigned to refer to the previous (nesting) stream. Such
nested streams are always buffered, and require explicit flushing to a
nesting stream or their contents will be discarded.
* If the initial _out_ _JspWriter_ object is
buffered, then depending upon the value of the _autoFlush_ attribute of
the _page_ directive, the content of that buffer will either be
automatically flushed out to the _ServletResponse_ output stream to
obviate overflow, or an exception shall be thrown to signal buffer
overflow. If the initial _out_ _JspWriter_ is unbuffered, then content
written to it will be passed directly through to the _ServletResponse_
output stream.

A JSP page can also describe what should
happen when some specific events occur. In JSP 2.2, the only events that
can be described are the initialization and the destruction of the page.
These events are described using “well-known method names” in
declaration elements. (See /C:/jspspec/JSP_Engine.html#15380[]).

=== [[a684]]Objects

A JSP page can access, create, and modify
server-side objects. Objects can be made visible to actions, EL
expressions and to scripting elements. An object has a scope describing
what entities can access the object.

Actions can access objects using a name in
the _PageContext_ object.

An object exposed through a scripting
variable has a scope within the page. Scripting elements can access some
objects directly via a scripting variable. Some implicit objects are
visible via scripting variables and EL expressions in any JSP page.

=== Objects and Variables

An object may be made accessible to code in
the scripting elements through a scripting language variable. An element
can define scripting variables that will contain, at process
request-time, a reference to the object defined by the element, although
other references may exist depending on the scope of the object.

An element type indicates the name and type
of such variables although details on the name of the variable may
depend on the Scripting Language. The scripting language may also affect
how different features of the object are exposed. For example, in the
JavaBeans specification, properties are exposed via getter and setter
methods, while these properties are available directly as variables in
the JavaScript™ programming language.

The exact rules for the visibility of the
variables are scripting language specific.
link:JSP_Syntax.html#UNKNOWN[See .] defines the rules for when the
_language_ attribute of the _page_ directive is _java_ .

=== [[a692]]Objects and Scopes

A JSP page can create and/or access some Java
objects when processing a request. The JSP specification indicates that
some objects are created implicitly, perhaps as a result of a directive
(see link:jsp.html#a702[See Implicit Objects.]). Other objects
are created explicitly through actions, or created directly using
scripting code. Created objects have a scope attribute defining where
there is a reference to the object and when that reference is removed.

The created objects may also be visible
directly to scripting elements through scripting-level variables (see
link:jsp.html#a702[See Implicit Objects.]).

Each action and declaration defines, as part
of its semantics, what objects it creates, with what scope attribute,
and whether they are available to the scripting elements.

Objects are created within a JSP page
instance that is responding to a request object. There are several
scopes:

*  _page_ - Objects with _page_ scope are
accessible only within the page where they are created. All references
to such an object shall be released after the response is sent back to
the client from the JSP page or the request is forwarded somewhere else.
References to objects with _page_ scope are stored in the _pageContext_
object.
*  _request_ - Objects with _request_ scope
are accessible from pages processing the same request where they were
created. References to the object shall be released after the request is
processed. In particular, if the request is forwarded to a resource in
the same runtime, the object is still reachable. References to objects
with _request_ scope are stored in the _request_ object.
*  _session_ - Objects with _session_ scope
are accessible from pages processing requests that are in the same
session as the one in which they were created. It is not legal to define
an object with session scope from within a page that is not
session-aware (see link:jsp.html#a770[See The page
Directive.]). All references to the object shall be released after the
associated session ends. References to objects with _session_ scope are
stored in the _session_ object associated with the page activation.
*  _application_ - Objects with _application_
scope are accessible from pages processing requests that are in the same
application as they one in which they were created. Objects with
application scope can be defined (and reached) from pages that are not
session-aware. References to objects with _application_ scope are stored
in the _application_ object associated with a page activation. The
_application_ object is the servlet context obtained from the servlet
configuration object. All references to the object shall be released
when the runtime environment reclaims the _ServletContext_ .

A _name_ should refer to a unique object at
all points in the execution; that is, all the different scopes really
should behave as a single name space. A JSP container implementation may
or may not enforce this rule explicitly for performance reasons.

=== [[a702]]Implicit Objects

JSP page authors have access to certain
implicit objects that are always available for use within scriptlets and
scriptlet expressions through scripting variables that are declared
implicitly at the beginning of the page. All scripting languages are
required to provide access to these objects. See
/C:/jspspec/JSP_Expression_Language.html#77288[] for the implicit objects
available within EL expressions. Implicit objects are available to tag
handlers through the pageContext object, see below.

Each implicit object has a class or interface
type defined in a core Java technology or Java Servlet API package, as
shown in _link:jsp.html#a705[See Implicit Objects Available in
JSP Pages.]_ .

=== [[a705]]Implicit Objects Available in JSP Pages

Variable Name

Type

Semantics & Scope

 _request_

 __ 

protocol dependent subtype of:
_javax.servlet.ServletRequest_

e.g:

 _javax.servlet.http.HttpServletRequest_

The request triggering the service
invocation.

 _request_ scope.

 _response_

protocol dependent subtype of:
_javax.servlet.ServletResponse,_ e.g:

 _javax.servlet.http.HttpServletResponse_

The response to the request.

 _page_ scope.

 _pageContext_

 _javax.servlet.jsp.PageContext_

The page context for this JSP page.

 _page_ scope.

 _session_

 _javax.servlet.http.HttpSession_

The session object created for the requesting
client (if any).

This variable is only valid for HTTP
protocols.

 _session_ scope

 _application_

 _javax.servlet.ServletContext_

The servlet context obtained from the servlet
configuration object

(as in the call _getServletConfig(). +
getContext()_ )

 _application_ scope

 _out_

 _javax.servlet.jsp.JspWriter_

An object that writes into the output stream.

 _page_ scope

 _config_ __

 _javax.servlet.ServletConfig_

The _ServletConfig_ for this JSP page

 _page_ scope

 _page_

 _java.lang.Object_

{empty}The instance of this page’s
implementation class processing the current
requestlink:#a6612[2]

 _page_ scope

In addition, the _exception_ implicit object
can be accessed in an error page, as described in
_link:jsp.html#a748[See Implicit Objects Available in Error
Pages.]_ .

=== [[a748]]Implicit Objects Available in Error Pages

Variable Name

Type

Semantics & Scope

 _exception_

 _java.lang.Throwable_

The uncaught _Throwable_ that resulted in the
error page being invoked.

 _page_ scope.

Object names with prefixes _jsp_ , __jsp_ ,
_jspx_ and __jspx_ , in any combination of upper and lower case, are
reserved by the JSP specification.

See
/C:/jspspec/JSP_Tag_Extensions.html#40979[] for some non-normative
conventions for the introduction of new implicit objects.

=== The pageContext Object

A _PageContext_ is an object that provides a
context to store references to objects used by the page, encapsulates
implementation-dependent features, and provides convenience methods. A
JSP page implementation class can use a _PageContext_ to run unmodified
in any compliant JSP container while taking advantage of
implementation-specific improvements like high performance _JspWriters_
.

See /C:/jspspec/javax.servlet.jsp.html#91781[]
for more details.

=== Template Text Semantics

The semantics of template (or uninterpreted)
Text is very simple: the template text is passed through to the current
_out_ _JspWriter_ implicit object, after applying the substitutions of
link:jsp.html#a639[See Quoting and Escape Conventions.].

=== [[a763]]Directives

Directives are messages to the JSP container.
Directives have this syntax:

<%@ directive \{ attr=”value” }* %>

There may be optional white space after the
_<%@_ and before _%>_ .

This syntax is easy to type and concise but
it is not XML-compatible. /C:/jspspec/JSP_Documents.html#64789[]
describes equivalent alternative mechanisms that are consistent with XML
syntax.

Directives do not produce any output into the
current _out_ stream.

There are three directives: the _page_ and
the _taglib_ directives are described next, while the _include_
directive is described in link:jsp.html#a894[The include
Directive].

=== [[a770]]The _page_ Directive

The _page_ directive defines a number of page
dependent properties and communicates these to the JSP container.

This _<jsp:directive.page>_ element
(/C:/jspspec/JSP_Documents.html#16408[]) describes the same information
following the XML syntax.

A translation unit (JSP source file and any
files included via the _include_ directive) can contain more than one
instance of the _page_ directive, all the attributes will apply to the
complete translation unit (i.e. page directives are position
independent). An exception to this position independence is the use of
the _pageEncoding_ and _contentType_ attributes in the determination of
the page character encoding; for this purpose, they should appear at the
beginning of the page (see /C:/jspspec/JSP_I18N.html#41392[]). There
shall be only one occurrence of any attribute/value pair defined by this
directive in a given translation unit, unless the values for the
duplicate attributes are identical for all occurrences. The _import_ and
_pageEncoding_ attributes are exempt from this rule and can appear
multiple times. Multiple uses of the _import_ attribute are cumulative
(with ordered set union semantics). The _pageEncoding_ attribute can
occur at most once per file (or a translation error will result), and
applies only to the file in which it appears. Other such multiple
attribute/value (re)definitions result in a fatal translation error if
the values do not match.

The attribute/value namespace is reserved for
use by this, and subsequent, JSP specification(s).

Unrecognized attributes or values result in
fatal translation errors.

=== Examples

The following directive provides some
user-visible information on this JSP page:

 _<%@ page info=”my latest JSP Example” %>_

The following directive requests no
buffering, and provides an error page.

<%@ page buffer=”none” errorPage=”/oops.jsp”
%>

The following directive indicates that the
scripting language is based on Java, that the types declared in the
package _com.myco_ are directly available to the scripting code, and
that a buffering of 16KB should be used.

<%@ page language=”java” import=”com.myco.*”
buffer=”16kb” %>

=== Syntax

<%@ page page_directive_attr_list %>

page_directive_attr_list ::= \{
language=”scriptingLanguage” } +
\{ extends=”className” } +
\{ import=”importList” } +
\{ session=”true|false” } +
\{ buffer=”none|sizekb” } +
\{ autoFlush=”true|false” } +
\{ isThreadSafe=”true|false” } +
\{ info=”info_text” } +
\{ errorPage=”error_url” } +
\{ isErrorPage=”true|false” } +
\{ contentType=”ctinfo” } +
\{ pageEncoding=”peinfo” } +
\{ isELIgnored=”true|false” }

 \{ _deferredSyntaxAllowedAsLiteral_
=”true|false” } +
\{ trimDirectiveWhitespaces=”true|false” }



The details of the attributes are as follows:

=== [[a789]]Page Directive Attributes

 _language_



Defines the scripting language to be used in
the scriptlets, expression scriptlets, and declarations within the body
of the translation unit (the JSP page and any files included using the
_include_ directive below).

In JSP 2.2, the only defined and required
scripting language value for this attribute is _java_ (all lowercase,
case-sensitive).

This specification only describes the
semantics of scripts for when the value of the language attribute is
_java_ .

When _java_ is the value of the scripting
language, the Java Programming Language source code fragments used
within the translation unit are required to conform to the Java
Programming Language Specification in the way indicated in
/C:/jspspec/JSP_Scripting.html#68206[].

All scripting languages must provide some
implicit objects that a JSP page author can use in declarations,
scriptlets, and expressions. The specific objects that can be used are
defined in link:jsp.html#a702[See Implicit Objects.].”

All scripting languages must support the Java
Runtime Environment (JRE). All scripting languages must expose the Java
technology object model to the script environment, especially implicit
variables, JavaBeans component properties, and public methods.

Future versions of the JSP specification may
define additional values for the language attribute and all such values
are reserved.

It is a fatal translation error for a
directive with a non- _java_ language attribute to appear after the
first scripting element has been encountered.

Default is _java_ .

 _extends_

The value is a fully qualified Java
programming language class name, that names the superclass of the class
to which this JSP page is transformed (see
/C:/jspspec/JSP_Engine.html#57518[]).

This attribute should not be used without
careful consideration as it restricts the ability of the JSP container
to provide specialized superclasses that may improve on the quality of
rendered service. See /C:/jspspec/JSP_Tag_Extensions.html#40979[] for an
alternate way to introduce objects into a JSP page that does not have
this drawback.

 _import_

An _import_ attribute describes the types
that are available to the scripting environment. The value is as in an
import declaration in the Java programming language, a (comma separated)
list of either a fully qualified Java programming language type name
denoting that type, or of a package name followed by the _.*_ string,
denoting all the public types declared in that package. The import list
shall be imported by the translated JSP page implementation and is thus
available to the scripting environment.

Packages java.lang.*, javax.servlet.*,
javax.servlet.jsp.*, and javax.servlet.http.* are imported implicitely
by the JSP container. No other packages may be part of this implicitely
imported list. Page authors may use the include-prelude feature (see
link:jsp.html#a1299[See Defining Implicit Includes.]) in order
to have additional packages imported transparently into their pages.

This attribute is currently only defined when
the value of the _language_ directive is _java_ .

 _session_

Indicates that the page requires
participation in an (HTTP) session.

If _true_ then the implicit script language
variable named _session_ of type _javax.servlet.http.HttpSession_
references the current/new session for the page.

If _false_ then the page does not participate
in a session; the _session_ implicit variable is unavailable, and any
reference to it within the body of the JSP page is illegal and shall
result in a fatal translation error.

Default is _true_ .

 _buffer_

Specifies the buffering model for the initial
_out_ _JspWriter_ to handle content output from the page.

If _none_ , then there is no buffering and
all output is written directly through to the _ServletResponse_
_PrintWriter_ .

The size can only be specified in kilobytes.
The suffix _kb_ is mandatory or a translation error must occur.

If a buffer size is specified then output is
buffered with a buffer size not less than that specified.

Depending upon the value of the _autoFlush_
attribute, the contents of this buffer is either automatically flushed,
or an exception is raised, when overflow would occur.

The default is buffered with an
implementation buffer size of not less than _8kb_ .

The corresponding JSP configuration element
is buffer (seelink:jsp.html#a1330[See Setting Default Buffer
Size.])

 _autoFlush_

Specifies whether the buffered output should
be flushed automatically ( _true_ value) when the buffer is filled, or
whether an exception should be raised ( _false_ value) to indicate
buffer overflow. It is illegal, resulting in a translation error, to set
_autoFlush_ to _false_ when _buffer=none_ . The default value is _true_
.

 _isThreadSafe_

Note: The Servlet 2.4 specification
deprecates SingleThreadModel, which is the most common mechanism for JSP
containers to implement isThreadSafe. Page authors are advised against
using isThreadSafe, as the generated Servlet may contain deprecated
code.



Indicates the level of thread safety
implemented in the page.

If _false_ then the JSP container shall
dispatch multiple outstanding client requests, one at a time, in the
order they were received, to the page implementation for processing.

If _true_ then the JSP container may choose
to dispatch multiple outstanding client requests to the page
simultaneously.

Page authors using _true_ must ensure that
they properly synchronize access to the shared state of the page.

Default is _true_ .

Note that even if the _isThreadSafe_
attribute is _false_ the JSP page author must ensure that accesses to
any shared objects are properly synchronized., The objects may be shared
in either the _ServletContext_ or the _HttpSession_ .

 _info_

Defines an arbitrary string that is
incorporated into the translated page, that can subsequently be obtained
from the page’s implementation of _Servlet.getServletInfo_ method.

 _isErrorPage_

Indicates if the current JSP page is intended
to be the URL target of another JSP page’s _errorPage_ .

If _true_ , then the implicit script language
variable _exception_ is defined and its value is a reference to the
offending Throwable from the source JSP page in error.

If _false_ then the _exception_ implicit
variable is unavailable, and any reference to it within the body of the
JSP page is illegal and shall result in a fatal translation error.

Default is _false._

 _errorPage_

Defines a URL to a resource to which any Java
programming language _Throwable_ object(s) thrown but not caught by the
page implementation are forwarded for error processing.

The provided URL spec is as in
link:jsp.html#a274[See Relative URL Specifications.].

If the URL names another JSP page then, when
invoked that JSP page’s _exception_ implicit script variable shall
contain a reference to the originating uncaught _Throwable_ .

The default URL is implementation dependent.

Note the _Throwable_ object is transferred by
the throwing page implementation to the error page implementation by
saving the object reference on the common _ServletRequest_ object using
the _setAttribute_ method, with a name of

 _javax.servlet.jsp.jspException_ (for
backwards-compatibility) and also _javax.servlet.error.exception_ (for
compatibility with the servlet specification). See
link:jsp.html#a614[See Using JSPs as Error Pages.] for more
details).

Note: if _autoFlush=true_ then if the
contents of the initial _JspWriter_ has been flushed to the
_ServletResponse_ output stream then any subsequent attempt to dispatch
an uncaught exception from the offending page to an _errorPage_ may
fail.

If the page defines an error page via the
_page_ directive, any error pages defined in _web.xml_ will not be used.

 _contentType_

Defines the MIME type and the character
encoding for the response of the JSP page, and is also used in
determining the character encoding of the JSP page.

Values are either of the form “ _TYPE_ ” or “
_TYPE;charset=CHARSET_ ”with an optional white space after the “ _;_ ”.
“ _TYPE_ ” is a MIME type, see the IANA registry at
_http://www.iana.org/assignments/media-types/index.html_ for useful
values. “ _CHARSET_ ”, if present, must be the IANA name for a character
encoding.

The default value for “ _TYPE_ ” is “
_text/html_ ” for JSP pages in standard syntax, or “ _text/xml_ ” for
JSP documents in XML syntax. If “ _CHARSET_ ” is not specified, the
response character encoding is determined as described in
/C:/jspspec/JSP_I18N.html#52032[].

The corresponding JSP configuration element
is default-content-type (see
link:jsp.html#a1327[See Declaring Default Content
Type.]). See /C:/jspspec/JSP_I18N.html#77284[] for complete details on
character encodings.

 _pageEncoding_

Describes the character encoding for the JSP
page. The value is of the form “ _CHARSET_ ”, which must be the IANA
name for a character encoding. For JSP pages in standard syntax, the
character encoding for the JSP page is the charset given by the
_pageEncoding_ attriute if it is present, otherwise the charset given by
the _contentType_ attribute if it is present, otherwise “ _ISO-8859-1_
”.

For JSP documents in XML syntax, the
character encoding for the JSP page is determined as described in
section 4.3.3 and appendix F.1 of the XML specification. The
_pageEncoding_ attribute is not needed for such documents. It is a
translation-time error if a document names different encodings in its
XML prolog / text declaration and in the _pageEncoding_ attribute. The
corresponding JSP configuration element is _page-encoding_ (see
/C:/jspspec/JSP_Configuration.html#29469[]).

See /C:/jspspec/JSP_I18N.html#77284[] for
complete details on character encodings.

 _isELIgnored_

Defines whether EL expressions are ignored or
recognized for this page and translation unit. If _true_ , EL
expressions (of the form _$\{...}_ and _#\{...}_ ) are ignored by the
container. If _false_ , EL expressions (of the form _$\{...}_ and
_#\{...}_ ) are recognized when they appear in template text or action
attributes. The corresponding JSP configuration element is _el-ignored_
(see /C:/jspspec/JSP_Configuration.html#57050[]). The default value
varies depending on the _web.xml_ version - see
/C:/jspspec/JSP_Expression_Language.html#64032[].

 _deferredSyntaxAllowedAsLiteral_

Indicates if the character sequence #\{ is
allowed or not when used as a String literal in this page and
translation unit. If false (the default value), a translation error
occurs when the character sequence is used as a String literal. The
corresponding JSP configuration element is
_deferred-syntax-allowed-as-literal_ (see
/C:/jspspec/JSP_Configuration.html#52904[]). See
/C:/jspspec/JSP_Preface.html#49688[] for more information.

 _trimDirectiveWhitespaces_

Indicates how whitespaces in template text
should be handled. If true, template text that contains only whitespaces
is removed from the output. The default is not to trim whitespaces. This
attribute is useful to remove the extraneous whitespaces from the end of
a directive that is not followed by template text. The corresponding JSP
configuration element is _trim-directive-whitespaces_ (see
/C:/jspspec/JSP_Configuration.html#70753[]). The attribute is ignored by
JSP documents (XML syntax).

=== [[a864]]The _taglib_ Directive

The set of significant tags a JSP container
interprets can be extended through a tag library.

The _taglib_ directive in a JSP page declares
that the page uses a tag library, uniquely identifies the tag library
using a URI and associates a tag prefix that will distinguish usage of
the actions in the library.

If a JSP container implementation cannot
locate a tag library description, a fatal translation error shall
result.

It is a fatal translation error for the
_taglib_ directive to appear after actions or functions using the
prefix.

A tag library may include a validation method
that will be consulted to determine if a JSP page is correctly using the
tag library functionality.

See
/C:/jspspec/JSP_Tag_Extensions.html#43756[] for more specification
details. And see /C:/jspspec/JSP_Tag_Extensions.html#64303[] for an
implementation note.

/C:/jspspec/JSP_Documents.html#80254[]
describes how the functionality of this directive can be exposed using
XML syntax.

=== Examples

In the following example, a tag library is
introduced and made available to this page using the _super_ prefix; no
other tag libraries should be introduced in this page using this prefix.
In this particular case, we assume the tag library includes a _doMagic_
element type, which is used within the page.

<%@ taglib uri=”http://www.mycorp/supertags”
prefix=”super” %>

...

<super:doMagic>

...

</super:doMagic>

=== Syntax

<%@ taglib ( uri=”tagLibraryURI” |
tagdir=”tagDir” ) prefix=”tagPrefix” %>

where the attributes are:

=== 

 _uri_

Either an absolute URI or a relative URI
specification that uniquely identifies the tag library descriptor
associated with this prefix.

The URI is used to locate a description of
the tag library as indicated in
/C:/jspspec/JSP_Tag_Extensions.html#43756[].

 _tagdir_

Indicates this prefix is to be used to
identify tag extensions installed in the _/WEB-INF/tags/_ directory or a
subdirectory. An implicit tag library descriptor is used (see
/C:/jspspec/JSP_Tag_Files.html#21695[] for details). A translation error
must occur if the value does not start with _/WEB-INF/tags_ . A
translation error must occur if the value does not point to a directory
that exists. A translation error must occur if used in conjunction with
the _uri_ attribute.

 _prefix_

Defines the prefix string in
_<prefix>:<tagname>_ that is used to distinguish a custom action, e.g
_<myPrefix:myTag>_ .

Prefixes starting with _jsp:_ , _jspx:_ ,
_java:_ , _javax:_ , _servlet:_ , _sun:_ , and _sunw:_ are reserved.

A prefix must follow the naming convention
specified in the XML namespaces specification.

Empty prefixes are illegal in this version of
the specification, and must result in a translation error.

A fatal translation-time error will result if
the JSP page translator encounters a tag with name _prefix: Name_ using
a prefix that is introduced using the taglib directive, and _Name_ is
not recognized by the corresponding tag library.

=== [[a894]]The _include_ Directive

The _include_ directive is used to substitute
text and/or code at JSP page translation-time. The _<%@ include
file=”relativeURLspec” %>_ directive inserts the text of the specified
resource into the page or tag file. The included file is subject to the
access control available to the JSP container. The _file_ attribute is
as in link:jsp.html#a274[See Relative URL Specifications.].

With respect to the standard and XML
syntaxes, a file included via the _include_ directive can use either the
same syntax as the including page, or a different syntax. the semantics
for mixed syntax includes are described in
link:jsp.html#a907[See Including Data in JSP Pages.].

A JSP container can include a mechanism for
being notified if an included file changes, so the container can
recompile the JSP page. However, the JSP 2.2 specification does not have
a way of directing the JSP container that included files have changed.

The _<jsp:directive.include>_ element
(/C:/jspspec/JSP_Documents.html#41999[]) describes the same information
following the XML syntax.

=== Examples

The following example requests the inclusion,
at translation time, of a copyright file. The file may have elements
which will be processed too.

<%@ include file=”copyright.html” %>

=== Syntax

<%@ include file="relativeURLspec" %>

=== Implicit Includes

Many JSP pages start with a list of taglib
directives that activate the use of tag libraries within the page. In
some cases, these are the only tag libraries that are supposed to be
used by the JSP page authors. These, and other common conventions are
greately facilitated by two JSP configuration elements:
_include-prelude_ and _include-coda_ . A full description of the
mechanism is in /C:/jspspec/JSP_Configuration.html#41204[].

With respect to the standard and XML
syntaxes, just as with the _include_ directive, implicit includes can
use either the same syntax as the including page, or a different syntax.
The semantics for mixed syntax includes are described in
link:jsp.html#a907[See Including Data in JSP Pages.].

=== [[a907]]Including Data in JSP Pages

Including data is a significant part of the
tasks in a JSP page. Accordingly, the JSP 2.2 specification has two
include mechanisms suited to different tasks. A summary of their
semantics is shown in _link:jsp.html#a909[See Summary of
Include Mechanisms in JSP 2.2.]_ .

=== [[a909]]Summary of Include Mechanisms in JSP 2.2

Syntax

Spec

Object

Description

Section

 _Include Directive - Translation-time_

 _<%@ include file=... %>_

file-relative

static

Content is parsed by JSP container.

{empty}link:jsp.html#a894[See The
include Directive.]

I _nclude Action - Request-time_

 _<jsp:include page= />_

page-relative

static +
and dynamic

Content is not parsed; it is included in
place.

/C:/jspspec/JSP_StandardActions.html#39949[]

The Spec column describes what type of
specification is valid to appear in the given element. The JSP
specification requires a relative URL spec. The reference is resolved by
the web/application server and its URL map is involved. Include
directives are interpreted relative to the current JSP file;
_jsp:include_ actions are interpreted relative to the current JSP page.

An include directive regards a resource like
a JSP page as a static object; i.e. the text in the JSP page is
included. An include action regards a resource like a JSP page as a
dynamic object; i.e. the request is sent to that object and the result
of processing it is included.

Implicit include directives can also be
requested for a collection of pages through the use of the
_<include-prelude>_ and _<include-coda>_ elements of the JSP
configuration section of _web.xml_ .

For translation-time includes, included
content can use either the same syntax as the including page, or a
different syntax. For example, a JSP file written in the standard JSP
syntax can include a JSP file written using the XML syntax. The
following semantics for translation-time includes apply:

* The JSP container must detect the syntax
for each JSP file individually and parse each JSP file according to the
syntax in which it is written.
* A JSP file written using the XML syntax
must be well-formed according to the "XML" and "Namespaces in XML"
specifications, otherwise a translation error must occur.
* When including a JSP document (written in
the XML syntax), in the resulting XML View of the translation unit the
root element of the included segment must have the default namespace
reset to "". This is so that any namespaces associated with the empty
prefix in the including document are not carried over to the included
document.
* When a _taglib_ directive is encountered in
a standard syntax page, the namespace is applied globally, and is added
to the _<jsp:root>_ element of the resulting XML View of the translation
unit.
* If a _taglib_ directive is encountered in a
standard syntax page that attempts to redefine a prefix that is already
defined in the current scope (by a JSP segment in either syntax), a
translation error must occur unless that prefix is being redefined to
the same namespace URI.

See /C:/jspspec/JSP_XML_Views.html#14490[] for
examples of how these semantics are applied to actual JSP pages and
documents.

=== Additional Directives for Tag Files

Additional directives are available when
editing a tag file. See /C:/jspspec/JSP_Tag_Files.html#62326[] for
details.

=== EL Elements

EL expressions can appear in template data
and in attribute values. EL expressions are defined in more detail in
/C:/jspspec/JSP_Expression_Language.html#98642[].

EL expressions can be disabled through the
use of JSP configuration elements and page directives; see
link:jsp.html#a770[See The page Directive.] and
/C:/jspspec/JSP_Configuration.html#57050[].

EL expressions, when not disabled, can be
used anywhere within template data.

EL expressions can be used in any attribute
of a standard action that this specification indicates can accept a
run-time expression value, and in any attribute of a custom action that
has been indicated to accept run-time expressions (i.e. their associated
_<rtexprvalue>_ in the TLD is _true_ ; see
/C:/jspspec/JSP_TLD.html#29000[]).

=== [[a944]]Scripting Elements

Scripting elements are commonly used to
manipulate objects and to perform computation that affects the content
generated.

JSP 2.0 adds EL expressions as an alternative
to scripting elements. These are described in more detail in
/C:/jspspec/JSP_Expression_Language.html#98642[]. Note that scripting
elements can be disabled through the use of the _scripting-invalid_
element in the web.xml deployment descriptor (see
/C:/jspspec/JSP_Configuration.html#77067[]).

There are three other classes of scripting
elements: declarations, scriptlets and expressions. The scripting
language used in the current page is given by the value of the
_language_ directive (see link:jsp.html#a770[See The page
Directive.]). In JSP 2.2, the only value defined is _java_ .

Declarations are used to declare scripting
language constructs that are available to all other scripting elements.
Scriptlets are used to describe actions to be performed in response to
some request. Scriptlets that are program fragments can also be used to
do things like iterations and conditional execution of other elements in
the JSP page. Expressions are complete expressions in the scripting
language that get evaluated at response time; commonly, the result is
converted into a string and inserted into the output stream.

All JSP containers must support scripting
elements based on the Java programming language. Additionally, JSP
containers may also support other scripting languages. All such
scripting languages must support:

* Manipulation of Java objects.
* Invocation of methods on Java objects.
* Catching of Java language exceptions.

The precise definition of the semantics for
scripting done using elements based on the Java programming language is
given in /C:/jspspec/JSP_Scripting.html#68206[].

The semantics for other scripting languages
are not precisely defined in this version of the specification, which
means that portability across implementations cannot be guaranteed.
Precise definitions may be given for other languages in the future.

Each scripting element has a _<%_ -based
syntax as follows:

<%! this is a declaration %> +
<% this is a scriptlet %> +
<%= this is an expression %>

White space is optional after _<%!_ , _<%_ ,
and _<%=_ , and before _%>_ .

The equivalent XML elements for these
scripting elements are described in
/C:/jspspec/JSP_Documents.html#82973[].

=== [[a959]]Declarations

Declarations are used to declare variables
and methods in the scripting language used in a JSP page. A declaration
must be a complete declarative statement, or sequence thereof, according
to the syntax of the scripting language specified.

Declarations do not produce any output into
the current _out_ stream.

Declarations are initialized when the JSP
page is initialized and are made available to other declarations,
scriptlets, and expressions.

The _<jsp:declaration>_ element
(/C:/jspspec/JSP_Documents.html#82973[]) describes the same information
following the XML syntax.

=== Examples

For example, the first declaration below
declares an integer, global to the page. The second declaration does the
same and initializes it to zero. This type of initialization should be
done with care in the presence of multiple requests on the page. The
third declaration declares a method global to the page.

<%! int i; %>

<%! int i = 0; %>

<%! public String f(int i) \{ if (i<3)
return(“...”); ... } %>

=== Syntax

<%! declaration(s) %>

=== [[a971]]Scriptlets

Scriptlets can contain any code fragments
that are valid for the scripting language specified in the _language_
attribute of the _page_ directive. Whether the code fragment is legal
depends on the details of the scripting language (see
/C:/jspspec/JSP_Scripting.html#68206[]).

Scriptlets are executed at request-processing
time. Whether or not they produce any output into the _out_ stream
depends on the code in the scriptlet. Scriptlets can have side-effects,
modifying the objects visible to them.

When all scriptlet fragments in a given
translation unit are combined in the order they appear in the JSP page,
they must yield a valid statement, or sequence of statements, in the
specified scripting language.

To use the _%>_ character sequence as literal
characters in a scriptlet, rather than to end the scriptlet, escape them
by typing _%\>_ .

The _<jsp:scriptlet>_ element
(/C:/jspspec/JSP_Documents.html#82973[]) describes the same information
following the XML syntax.

=== Examples

Here is a simple example where the page
changed dynamically depending on the time of day.

 _<% if
(Calendar.getInstance().get(Calendar.AM_PM) == Calendar.AM) \{%> +
Good Morning +
<% } else \{ %> +
Good Afternoon +
<% } %>_

A scriptlet can also have a local variable
declaration, for example the following scriptlet just declares and
initializes an integer, and later increments it.

<% int i; i= 0; %> +
About to increment i... +
<% i++; %>

=== Syntax

<% scriptlet %>

=== [[a984]]Expressions

An expression element in a JSP page is a
scripting language expression that is evaluated and the result is
coerced to a _String_ . The result is subsequently emitted into the
current _out_ _JspWriter_ object.

If the result of the expression cannot be
coerced to a _String_ the following must happen: If the problem is
detected at translation time, a translation time error shall occur. If
the coercion cannot be detected during translation, a
_ClassCastException_ shall be raised at request time.

A scripting language may support side-effects
in expressions when the expression is evaluated. Expressions are
evaluated left-to-right in the JSP page. If an expression appears in
more than one run-time attribute, they are evaluated left-to-right in
the tag. An expression might change the value of the _out_ object,
although this is not something to be done lightly.

The expression must be a complete expression
in the scripting language in which it is written, or a translation error
must occur.

Expressions are evaluated at request
processing time. The value of an expression is converted to a String and
inserted at the proper position in the _.jsp_ file.

The _<jsp:expression>_ element
(/C:/jspspec/JSP_Documents.html#82973[]) describes the same information
following the XML syntax.

=== Examples

This example inserts the current date.

<%= (new java.util.Date()).toLocaleString()
%>

=== Syntax

<%= expression %>

=== Actions

Actions may affect the current _out_ stream
and use, modify and/or create objects. Actions may depend on the details
of the specific request object received by the JSP page.

The JSP specification includes some actions
that are standard and must be implemented by all conforming JSP
containers; these actions are described in
/C:/jspspec/JSP_StandardActions.html#55184[].

New actions are defined according to the
mechanisms described in /C:/jspspec/JSP_Tag_Extensions.html#43756[] and
/C:/jspspec/javax.servlet.jsp.tagext.html#20465[] and are introduced
using the _taglib_ directive.

The syntax for action elements is based on
XML. Actions can be empty or non-empty.

=== [[a1001]]Tag Attribute Interpretation Semantics

The interpretation of all actions start by
evaluating the values given to its attributes left to right, and
assigning the values to the attributes. In the process some conversions
may be applicable; the rules for them are described in
link:jsp.html#a1018[See Type Conversions.].

Many values are fixed translation-time
values, but JSP 2.2 also provides a mechanism for describing values that
are computed at request time, the rules are described in
link:jsp.html#a1004[See Request Time Attribute Values.].

=== [[a1004]]Request Time Attribute Values

An attribute value of the form _“<%=
scriptlet_expr %>”_ or _‘<%= scriptlet_expr %>’_ denotes a request-time
attribute value. The value denoted is that of the scriptlet expression
involved. If Expression Language evaluation is not deactivated for the
translation unit (see /C:/jspspec/JSP_Configuration.html#57050[]) then
request-time attribute values can also be specified using the EL through
the syntax _‘$\{el_expr}’_ or _“$\{el_expr}”_ (as well as
_‘#\{el_expr}’_ or _“#\{el_expr}”_ ). Containers must also recognize
multiple EL expressions mixed with optional string constants. For
example, “Version $\{major}.$\{minor} Installed” is a valid request-time
attribute value.

Request-time attribute values can only be
used in actions. If a request-time attribute value is used in a
directive, a translation error must occur. If there are more than one
such attribute in a tag, the expressions are evaluated left-to-right.

Quotation is done as in any other attribute
value (link:jsp.html#a639[See Quoting and Escape
Conventions.]).

Only attribute values can be denoted this way
(the name of the attribute is always an explicit name). When using
scriptlet expressions, the expression must appear by itself (multiple
expressions, and mixing of expressions and string constants are not
permitted). Multiple operations must be performed within the expression.
Type conversions are described in link:jsp.html#a1018[See Type
Conversions.].

By default, except in tag files, all
attributes have page translation-time semantics. Attempting to specify a
scriptlet expression or EL expression as the value for an attribute that
(by default or otherwise) has page translation time semantics is
illegal, and will result in a fatal translation error. The type of an
action element indicates whether a given attribute will accept
request-time attribute values.

Most attributes in the standard actions from
/C:/jspspec/JSP_StandardActions.html#55184[] have page translation-time
semantics, but the following attributes accept request-time attribute
expressions:

* The _value_ attribute of _jsp:setProperty_
(/C:/jspspec/JSP_StandardActions.html#22442[]).
* The _beanName_ attribute of _jsp:useBean_
(/C:/jspspec/JSP_StandardActions.html#41392[]).
* The _page_ attribute of _jsp:include_
(/C:/jspspec/JSP_StandardActions.html#39949[]).
* The _page_ attribute of _jsp:forward_
(/C:/jspspec/JSP_StandardActions.html#23283[]).
* The _value_ attribute of _jsp:param_
(/C:/jspspec/JSP_StandardActions.html#80377[]).
* The _height_ and _width_ attributes of
_jsp:plugin_ (/C:/jspspec/JSP_StandardActions.html#18155[]).
* The _name_ attribute of _jsp:element_
(/C:/jspspec/JSP_StandardActions.html#37936[]).

=== [[a1018]]Type Conversions

We describe two cases for type conversions

=== [[a1020]]Conversions from String values

A string value can be used to describe a
value of a non-String type through a conversion. Whether the conversion
is possible, and, if so, what is it, depends on a target type.

String values can be used to assign values to
a type that has a _PropertyEditor_ class as indicated in the JavaBeans
specification. When that is the case, the _setAsText(String)_ method is
used. A conversion failure arises if the method throws an
_IllegalArgumentException_ .

String values can also be used to assign to
the types as listed in _link:jsp.html#a1025[See Conversions from
string values to target type.]_ . The conversion applied is that shown
in the table.

A conversion failure leads to an error,
whether at translation time or request-time.

=== [[a1025]]Conversions from string values to target type

Target Type

Source String Value

Bean Property

As converted by the corresponding
PropertyEditor, if any, using PropertyEditor. _setAsText(string-literal)
and PropertyEditor.getValue()._ If there is no corresponding
_PropertyEditor_ or the _PropertyEditor_ throws an exception, ‘ _null_ ’
if the string is empty, otherwise error.

boolean or Boolean

As indicated in
_java.lang.Boolean.valueOf(String). This results in ‘false’ if the
String is empty._

byte or Byte

As indicated in
_java.lang.Byte.valueOf(String), or ‘(byte) 0’ if the string is empty._

char or Character

As indicated in _String.charAt(0), or ‘(char)
0’ if the string is empty._

double or Double

As indicated in
_java.lang.Double.valueOf(String), or 0 if the string is empty._

int or Integer

As indicated in
_java.lang.Integer.valueOf(String), or 0 if the string is empty._

float or Float

As indicated in
_java.lang.Float.valueOf(String), or 0 if the string is empty._

long or Long

As indicated in
_java.lang.Long.valueOf(String), or 0 if the string is empty._

short or Short

As indicated in
_java.lang.Short.valueOf(String), or 0 if the string is empty._

Object

As if new _String(string-literal). This
results in new String( ““ ) if the string is empty._

These conversions are part of the generic
mechanism used to assign values to attributes of actions: when an
attribute value that is not a request-time attribute is assigned to a
given attribute, the conversion described here is used, using the type
of the attribute as the target type. The type of each attribute of the
standard actions is described in this specification, while the types of
the attributes of a custom action are described in its associated Tag
Library Descriptor.

A given action may also define additional
ways where type/value conversions are used. In particular,
/C:/jspspec/JSP_StandardActions.html#22442[] describes the mechanism used
for the setProperty standard action.

=== [[a1050]]Conversions from request-time expressions

Request-time expressions can be assigned to
properties of any type. In the case of scriptlet expressions, no
automatic conversions will be performed. In the case of EL expressions,
the rules in /C:/elspec/language.html#39918[] of the EL specification
document must be followed.



== CHAPTER 1 - 

=== [[a1054]]Expression Language

As of JSP 2.1, the expression languages
of JSP 2.0 and JSF 1.1 have been merged into a single _unified_
expression language (EL 2.1) for the benefit of all Java based web-tier
technologies.

While the expression language is still
defined within the JSP 2.1 specification, it however now has its own
independent specification document. This makes the intent clear that the
Expression Language is generally applicable to a variety of technologies
and does not carry a dependency on the JSP specification. Having the EL
defined in its own specification document will also make it easier in
the future should the decision be made to move it into its own JSR.
Please consult the EL specification document for details on the
Expression Language supported by JSP 2.1.

The addition of the EL to the JSP technology
facilitates much the writing of script-less JSP pages. These pages can
use EL expressions but can’t use Java scriptlets, Java expressions, or
Java declaration elements. This usage pattern can be enforced through
the _scripting-invalid_ JSP configuration element.

The EL is available in attribute values for
standard and custom actions and within template text.

This chapter describes how the expression
language is integrated within the JSP 2.1 environment.

=== Syntax of expressions in JSP pages: $\{} vs #\{}

There are two constructs to represent EL
expressions: _$\{expr}_ and _#\{expr}_ . While the EL parses and
evaluates _$\{}_ and _#\{}_ the same way, additional restrictions are
placed on the usage of these delimiters in JSP pages.

An EL expression that is evaluated
immediately is represented in JSP with the syntax _$\{}_ , while an EL
expression whose evaluation is deferred is represented with the syntax
_#\{}_ .

=== Expressions and Template Text

The EL can be used directly in template text,
be it inside the body of a custom or standard actions or in template
text outside of any action.Exceptions are if the body of the tag is
_tagdependent_ , or if EL is turned off (usually for compatibility
issues) explicitly through a directive or implicitly; see below.

Only the _$\{}_ syntax is allowed for
expressions in template text. A translation error will result if _#\{}_
is used in template text unless _#\{}_ is turned off via a backwards
compatibility mechanism.

All EL expressions in JSP template text are
evaluated as Strings, and are evaluated by the JSP engine immediately
when the page response is rendered.

The semantics of an EL expression are the
same as with Java expressions: the value is computed and inserted into
the current output. In cases where escaping is desired (for example, to
help prevent cross-site scripting attacks), the JSTL core tag _<c:out>_
can be used. For example:

<c:out value=”$\{anELexpression}” />

The following shows a custom action where two
EL expressions are used to access bean properties:

<c:wombat> +
One value is $\{bean1.a} and another is $\{bean2.a.c} +
</c:wombat>

=== [[a1071]]Expressions and Attribute Values

EL expressions can be used in any attribute
that can accept a run-time expression, be it a standard action or a
custom action. For more details, see the sections on backward
compatibility issues, specifically link:jsp.html#a1156[See
Deactivating EL Evaluation.] and link:jsp.html#a1158[See
Disabling Scripting Elements.].

For example, the following shows a
conditional action that uses the EL to test whether a property of a bean
is less than 3.

<c:if test="$\{bean1.a < 3}"> +
... +
</c:if>

Note that the normal JSP coercion mechanism
already allows for:

 <mytags:if test="true" />

An EL expression that appears in an attribute
value is processed differently depending on the attribute’s type
category defined in the TLD. Details are provided in the sections below.

=== [[a1078]]Static Attribute

* Defined in the TLD through element
_<rtexprvalue>_ set to _false_ .
* Type is always _java.lang.String_ .
* Value must be a String literal (since it is
determined at translation time). It is illegal to specify an expression.
* Type in the TLD is ignored. The String
value is converted to the attribute’s target type (as defined in the tag
handler) using the conversions defined in
link:jsp.html#a1025[See Conversions from string values to target
type.].

=== [[a1083]]Dynamic Attribute

* Defined in the TLD through element
_<rtexprvalue>_ set to _true_ .
* If type is not specified in the TLD,
defaults to _java.lang.Object_ .
* Value can be a String literal, a scriptlet
expression, or an EL expression using the _$\{}_ syntax.
* An EL expression is parsed using
_ExpressionFactory.createValueExpression() (_ with an expected type
equal to the type specified in the TLD) and the evaluation of the
expression takes place immediately by calling method _getValue()_ on the
_ValueExpression_ . After evaluation of the expression, the value is
coerced to the expected type. The resulting value is passed in to the
setter method for the tag attribute.

=== [[a1088]]Deferred Value

* Defined in the TLD through element
_<deferred-value>_ .
* If type is not specified in the TLD,
defaults to _java.lang.Object_ .
* Value can be a String literal or an EL
expression using the _#\{}_ syntax.
* An EL expression is parsed using
_ExpressionFactory.createValueExpression() (_ with an expected type
equal to the type specified in the TLD). The expression is not
evaluated. The result of parsing the expression is passed directly to
the setter method of the tag attribute, whose argument type must be j
_avax.el.ValueExpression_ . This allows for deferred evaluation of EL
expressions. When the expression is evaluated by the tag handler, the
value is coerced to the expected type. If a static value is provided, it
is converted to a _ValueExpression_ where _isLiteralText()_ returns
_true_

=== [[a1093]]Deferred Method

* Defined in the TLD through element
_<deferred-method>_ .
* If the method signature is not defined in
the TLD, it defaults to _void method()_ .
* Value can be a String literal or an EL
expression using the _#\{}_ syntax.
* An EL expression is parsed using
_ExpressionFactory.createMethodExpression() (_ with a method signature
equal to the method signature specified in the TLD). The result of
parsing the expression is passed directly to the setter method of the
tag attribute, whose argument type must be _javax.el.MethodExpression_ .
This allows for deferred processing of EL expressions that identify a
method to be invoked on an Object.
* A String literal can be provided, as long
as the return type of the deferred method signature is not void. A
_MethodExpression_ is created, which when invoked, returns the String
literal coerced to expected return type (the standard EL coercion rules
(see EL spec document /C:/elspec/language.html#39918[] apply). A
translation error occurs if the return type is void or if the string
literal cannot be coerced to the return type of the deferred method
signature.

=== Dynamic Attribute or Deferred Expression

* Defined in the TLD through elements
_<rtexprvalue>_ (see link:jsp.html#a1083[See Dynamic
Attribute.]) specified together with _<deferred-value>_ (see
link:jsp.html#a1088[See Deferred Value.]) or _<deferred-method>_
(see link:jsp.html#a1093[See Deferred Method.]).
* Value can be a String literal, a scriptlet
expression, or an EL expression using the _$\{}_ or _#\{}_ syntax. The
attribute value is considered a deferred value or a deferred method if
the value is an EL expression using the _#\{}_ syntax. It is considered
a dynamic attribute otherwise.
* The attribute value is processed according
to its type category as described above. The only difference is that the
setter method argument must be of type _java.lang.Object_ . The setter
method will normally use _instanceof_ to discriminate whether the
attribute value is a dynamic attribute or a deferred value.

=== Examples of Using $\{} and #\{}

As an example, assume a tag with the
following three attributes:

*  static - _rtexprvalue=false,
type=java.lang.String_
*  dynamic - _rtexprvalue=true,
type=java.lang.String_
*  deferred - _rtexprvalue=true,
type=java.lang.ValueExpression_

 __ 

The following tags would yield the following
results:

=== Examples of Using $\{} and #\{}

Expression

=== Result

 _<my:tag static="xyz" />_

OK

 _<my:tag static="$\{x[y]}" />_

ERROR

 _<my:tag static="#\{x[y]}" />_

ERROR

 _<my:tag dynamic="xyz" />_

OK

 _<my:tag dynamic="$\{x[y]}" />_

OK

 _<my:tag dynamic="#\{x[y]}" />_

ERROR

 _<my:tag deferred="xyz" />_

OK

 _<my:tag deferred="$\{x[y]}" />_

ERROR

 _<my:tag deferred="#\{x[y]}" />_

OK

=== [[a1131]]Implicit Objects

There are several implicit objects that are
available to EL expressions used in JSP pages. These objects are always
available under these names:

*  _pageContext_ - the _PageContext_ object
*  _pageScope_ - a _Map_ that maps
page-scoped attribute names to their values
*  _requestScope_ - a _Map_ that maps
request-scoped attribute names to their values
*  _sessionScope_ - a _Map_ that maps
session-scoped attribute names to their values
*  _applicationScope_ - a _Map_ that maps
application-scoped attribute names to their values
*  _param_ __ - a _Map_ that maps parameter
names to a single String parameter value (obtained by calling __
_ServletRequest.getParameter(String name)_ )
*  _paramValues_ - a _Map_ that maps
parameter names to a _String[]_ of all values for that parameter
(obtained by calling _ServletRequest.getParameterValues(String name)_ )
*  _header_ - a _Map_ that maps header names
to a single String header value (obtained by calling
_HttpServletRequest.getHeader(String name)_ )
*  _headerValues_ - a _Map_ that maps header
names to a _String[]_ of all values for that header (obtained by calling
_HttpervletRequest.getHeaders(String)_ )
*  _cookie_ - a _Map_ that maps cookie names
to a single _Cookie_ object. Cookies are retrieved according to the
semantics of _HttpServletRequest.getCookies()_ . If the same name is
shared by multiple cookies, an implementation must use the first one
encountered in the array of _Cookie_ objects returned by the
_getCookies()_ method. However, users of the cookie implicit object must
be aware that the ordering of cookies is currently unspecified in the
servlet specification.
*  _initParam_ - a _Map_ that maps context
initialization parameter names to their _String_ parameter value
(obtained by calling _ServletContext.getInitParameter(String name)_ )

The following table shows some examples of
using these implicit objects:

=== Examples of Using Implicit Objects

Expression

=== Result

 _$\{pageContext.request.requestURI}_

The request's URI (obtained from
_HttpServletRequest_ )

 _$\{sessionScope.profile}_

The session-scoped attribute named _profile_
(null if not found)

 _$\{param.productId}_

The _String_ value of the _productId_
parameter, or null if not found

 _$\{paramValues.productId}_

The _String[]_ containing all values of the
_productId_ parameter, or null if not found

=== [[a1156]]Deactivating EL Evaluation

Since the syntactic patterns _$\{_ _expr_ _}_
and _#\{_ _expr_ _}_ were not reserved in the JSP specifications before
JSP 2.0, there may be situations where such patterns appear but the
intention is not to activate EL expression evaluation but rather to pass
through the pattern verbatim. To address this, the EL evaluation
machinery can be deactivated as indicated in
/C:/jspspec/JSP_Configuration.html#57050[].

=== [[a1158]]Disabling Scripting Elements

With the addition of the EL, some JSP page
authors, or page authoring groups, may want to follow a methodology
where scripting elements are not allowed. See
/C:/jspspec/JSP_Configuration.html#77067[] for more details.

=== Invalid EL expressions

JSP containers are required to produce a
translation error when a syntactically invalid EL expression is
encountered in an attribute value or within template text. The syntax of
an EL expression is described in detail in the EL specification
document.

=== Errors, Warnings, Default Values

JSP pages are mostly used in presentation,
and in that usage, experience suggests that it is most important to be
able to provide as good a presentation as possible, even when there are
simple errors in the page. To meet this requirement, the EL does not
provide warnings, just default values and errors. Default values are
type-correct values that are assigned to a subexpression when there is
some problem. An error is an exception thrown (to be handled by the
standard JSP machinery).

=== [[a1164]]Resolution of Variables and their Properties

The EL API provides a generalized mechanism,
an _ELResolver_ , implemented by the JSP container and which defines the
rules that govern the resolution of variables and object properties.

The _ELResolver_ shown in
link:jsp.html#a1178[See JSP Resolvers Hierarchy.] is passed to
all EL expressions that appear in a JSP page or tag file. It is an
instance of _javax.el.CompositeELResolver_ that contains the following
component _ELResolver_ s, in order:

.  _jsp.ImplicitObjectELResolver_ +
 +
Resolves the implicit objects mentioned in
link:jsp.html#a1131[See Implicit Objects.]
. All _ELResolver_ s added via
_JspApplicationContext.addELResolver()_ , in the same order in which
they were registered. +
 +
This itself can take the form of a _el.CompositeELResolver_ . This will
include the _ELResolver_ registered by Faces.
. [[a1169]]The ELresolver returned
by ExpressionFactory.getStreamELResolver().
. [[a1170]]javax.el.StaticFieldResolver
.  _javax.el.MapELResolver_ - constructed in
read/write mode.
. javax.el.ResourceBundleELResolver
.  _javax.el.ListELResolver_ - constructed in
read/write mode.
.  _javax.el.ArrayELResolver_ - constructed
in read/write mode.
.  _javax.el.BeanELResolver_ - constructed in
read/write mode. +
 +
Handles all cases where _base != null_
.  _jsp.ScopedAttributeELResolver +
_ +
Handles all cases where _base == null_ . +
Provides a map for other identifiers by looking up its value as an
attribute, according to the behavior of
_PageContext.findAttribute(String)_ on the _pageContext_ object. For
example: +
 +
$\{product} +
 +
This expression will look for the attribute named _product_ , searching
the page, request, session, and application scopes, and will return its
value. If the attribute is not found, null is returned.

=== 

=== [[a1178]]JSP Resolvers Hierarchy

image:sp-2.png[image]

=== Functions

The EL has qualified functions, reusing the
notion of qualification from XML namespaces (and attributes), XSL
functions, and JSP custom actions. Functions are mapped to public static
methods in Java classes. In JSP, the map is specified in the TLD.

Function mapping information is bound into
the _ValueExpression_ or _MethodExpression_ at parse-time and is
serialized along with the state of the expression. No function mapper
needs to be provided at evaluation time.

=== Invocation Syntax

The full syntax is that of qualified n-ary
functions:

 ns:f(a1,a2, ..., an)

As with the rest of EL, this element can
appear in attributes and directly in template text.

The prefix _ns_ must match the prefix of a
tag library that contains a function whose name and signature matches
the function being invoked ( _f_ ), or a translation error must occur.
If the prefix is omitted, the tag library associated with the default
namespace is used (this is only possible in JSP documents).

In the following standard syntax example,
_func1_ is associated with _some-taglib_ :

 <%@ taglib prefix=”some”
uri=”http://acme.com/some-taglib” %> +
$\{some:func1(true)}

In the following JSP document example, both
_func2_ and _func3_ are associated with _default-taglib_ :

 <some:tag
xmlns=”http://acme.com/default-taglib” +
xmlns:some=”http://acme.com/some-taglib” +
xmlns:jsp=”http://java.sun.com/JSP/Page”> +
<some:other value=”$\{func2(true)}”> +
$\{func3(true)} +
</some:other> +
</some:tag>

=== Tag Library Descriptor Information

Each tag library may include zero or more _n_
-ary (static) functions. The Tag Library Descriptor (TLD) associated
with a tag library lists the functions.

Each such function is given a name (as seen
in the EL), and a static method in a specific class that will implement
the function. The class specified in the TLD must be a public class, and
must be specified using a fully-qualified class name (including
packages). The specified method must be a public static method in the
specified class, and must be specified using a fully-qualified return
type followed by the method name, followed by the fully-qualified
argument types in parenthesis, separated by commas (see the XML Schema
in /C:/jspspec/JSP_TLD.html#23570[] for a full description of this
syntax). Failure to satisfy these requirements shall result in a
translation-time error.

A tag library can have only one _function_
element in the same tag library with the same value for their _name_
element. If two functions have the same name, a translation-time error
shall be generated.

Reference the _function_ element in
/C:/jspspec/JSP_TLD.html#70854[] for how to specify a function in the
TLD.

=== Example

The following TLD fragment describes a
function with name _nickname_ that is intended to fetch the nickname of
the user:

<taglib> +
... +
<function> +
<name>nickname</name> +
<function-class>mypkg.MyFunctions</function-class> +
<function-signature> +
java.lang.String nickName(java.lang.String) +
</function-signature> +
</function> +
</taglib>

The following EL fragment shows the
invocation of the function:

<h2>Dear $\{my:nickname(user)}</h2>

=== Semantics

* If the function has no prefix, the default
namespace is used. If the function has a prefix, assume the namespace as
that associated with the prefix.
* Let _ns_ be the namespace associated with
the function, and _f_ be the name of the function.
* Locate the TLD associated with _ns_ . If
none can be found, this shall be a translation-time error.
* Locate the _function_ element with a _name_
subelement with value _f_ in that TLD. If none can be found, this shall
be a translation-time error.
* Locate the public class with name equal to
the value of the _function-class_ element. Locate the public static
method with name and signature equal to the value of the
_function-signature_ element. If any of these don’t exist, a
translation-time error shall occur..
* Evaluate each argument to the corresponding
type indicated in the signature
* Evaluate the public static Java method. The
resulting value is the value returned by the method evaluation, or
_null_ if the Java method is declared to return _void_ . If an exception
is thrown during the method evaluation, the exception must be wrapped in
an _ELException_ and the _ELException_ must be thrown.

== CHAPTER 2 - 

=== [[a1210]]JSP Configuration

This chapter describes the JSP
configuration information, which is specified in the Web Application
Deployment Descriptor in _WEB-INF/web.xml_ . As of Servlet 2.4, the Web
Application Deployment Descriptor is defined using XML Schema, and
imports the elements described in (PENDING)
link:jsp.html#a3717[See XML Schema for JSP 2.0 Deployment
Descriptor.]. See that section for the details on how to specify JSP
configuration information in a Web Application.

=== JSP Configuration Information in web.xml

A Web Application can include general JSP
configuration information in its _web.xml_ file that is to be used by
the JSP container. The information is described through the _jsp-config_
element and its subelements.

The _jsp-config_ element is a subelement of
_web-app_ __ that __ is used to provide global configuration information
for the JSP files in a Web Application. A _jsp-config_ __ has two
subelements: _taglib_ __ and _jsp-property-group_ , defining the taglib
mapping and groups of JSP files respectively.

=== [[a1215]]Taglib Map

The __ _web.xml_ file can include an explicit
taglib map between URIs and TLD resource paths described using _taglib_
elements in the Web Application Deployment descriptor.

The _taglib_ element is a subelement of
_jsp-config_ that can be used to provide information on a tag library
that is used by a JSP page within the Web Application. The _taglib_
element has two subelements: _taglib-uri_ and _taglib-location_ .

A _taglib-uri_ element describes a URI
identifying a tag library used in the web application. _The body of the_
_taglib-uri_ _element may be either an absolute URI specification, or a
relative URI as in link:jsp.html#a274[See Relative URL
Specifications.]. There should be no entries in_ _web.xml_ _with the
same_ _taglib-uri_ _value._

A _taglib-location_ element contains a
resource location (as indicated in _link:jsp.html#a274[See
Relative URL Specifications.]_ ) of the Tag Library Description File for
the tag library.

=== JSP Property Groups

A JSP property group is a collection of
properties that apply to a set of files that represent JSP pages. These
properties are defined in one or more _jsp-property-group_ elements in
the Web Application deployment descriptor.

Most properties defined in a JSP property
group apply to an entire translation unit, that is, the requested JSP
file that is matched by its URL pattern and all the files it includes
via the include directive. The exception is the _page-encoding and
is-xml_ property, which applies separately to each JSP file matched by
its URL pattern.

The applicability of a JSP property group is
defined through one or more URL patterns. URL patterns use the same
syntax as defined in Chapter SRV.11 of the Servlet 2.5 specification,
but are bound at translation time. All the properties in the group apply
to the resources in the Web Application that match any of the URL
patterns. There is an implicit property: that of being a JSP file. JSP
Property Groups do not affect tag files.

If a resource matches a URL pattern in both a
_<servlet-mapping>_ and a _<jsp-property-group>_ , the pattern that is
most specific applies (following the same rules as in the Servlet
specification). If the URL patterns are identical, the
_<jsp-property-group>_ takes precedence over the _<servlet-mapping>_ .
If at least one _<jsp-property-group>_ contains the most specific
matching URL pattern, the resource is considered to be a JSP file, and
the properties in that _<jsp-property-group>_ apply. In addition, if a
resource is considered to be a JSP file, all _include-prelude_ and
_include-coda_ properties apply from all the _<jsp-property-group>_
elements with matching URL patterns (see link:jsp.html#a1299[See
Defining Implicit Includes.]).

=== [[a1225]]JSP Property Groups

A _jsp-property-group_ is a subelement of
_jsp-config_ . The properties that can currently be described in a
_jsp-property-group_ include:

* Indicate that a resource is a JSP file
(implicit).
* Control disabling of EL evaluation.
* Control disabling of Scripting elements.
* Indicate page Encoding information.
* Prelude and Coda automatic includes.
* Indicate that a resource is a JSP document.
* Indicate that the deferred syntax
(initiated by the character sequence _#\{)_ is allowed as a String
literal.
* Control handling of whitespaces in template
text.
* Indicate response ContentType information.
* Indicate response buffer size.
* Control handling of undeclared namespaces
in a JSP page.

=== [[a1238]]Deactivating EL Evaluation

Since the syntactic pattern _$\{expr}_ was
not reserved in the JSP specifications before JSP 2.0, and the syntactic
pattern _#\{expr}_ was not reserved before JSP 2.1, there may be
situations where such patterns appear but the intention is not to
activate EL expression evaluation but rather to pass through the pattern
verbatim. To address this, the EL evaluation machinery can be
deactivated as indicated in this section.

Each JSP page has a default setting as to
whether to ignore EL expressions. When ignored, the expression is passed
through verbatim. The default setting does not apply to tag files, which
always default to evaluating expressions.

The default mode for JSP pages in a Web
Application delivered using a _web.xml_ using the Servlet 2.3 or earlier
format is to ignore EL expressions; this provides for backward
compatibility.

The default mode for JSP pages in a Web
Application delivered using a _web.xml_ using the Servlet 2.4 format is
to evaluate EL expressions with the $\{} syntax. Expressions using the
#\{} are evaluated starting with JSP 2.1. See
link:jsp-1.html#a28[See Backwards Compatibility with JSP 2.0.]
for more details on the evaluation of #\{} expressions.

The default mode can be explicitly changed by
setting the value of the _el-ignored_ element. The _el-ignored_ element
is a subelement of _jsp-property-group_ (see
link:jsp.html#a1225[See JSP Property Groups.]). It has no
subelements. Its valid values are _true_ and _false_ .

For example, the following _web.xml_ fragment
defines a group that deactivates EL evaluation for all JSP pages
delivered using the _.jsp_ extension:

<jsp-property-group> +
<url-pattern>*.jsp</url-pattern> +
<el-ignored>true</el-ignored> +
</jsp-property-group>

Page authors can override the default mode
through the _isELIgnored_ attribute of the page directive. For tag
files, there is no default, but the _isELIgnored_ attribute of the tag
directive can be used to control the EL evaluation settings.

link:jsp.html#a1248[See EL Evaluation
Settings for JSP Pages.] summarizes the EL evaluation settings for JSP
pages, and their meanings:

=== [[a1248]]EL Evaluation Settings for JSP Pages

JSP Configuration +
<el-ignored>

Page Directive +
isELIgnored

EL Encountered

unspecified

unspecified

Ignored if <= 2.3 web.xml

Evaluated otherwise.

false

unspecified

Evaluated

true

unspecified

Ignored

don’t care

false

Evaluated

don’t care

true

Ignored

link:jsp.html#a1269[See EL Evaluation
Settings for Tag Files.] summarizes the EL evaluation settings for tag
files, and their meanings:

=== [[a1269]]EL Evaluation Settings for Tag Files

Tag Directive +
isELIgnored

EL Encountered

unspecified

Evaluated

false

Evaluated

true

Ignored

The EL evaluation setting for a translation
unit also affects whether the _\$_ and _\#_ quote sequences are enabled
for template text and attribute values in a JSP page, document, or tag
file. When EL evaluation is disabled, _\$_ and _\#_ will not be
recognized as quotes, whereas when EL evaluation is enabled, _\$_ and
_\#_ will be recognized as quotes for _$_ and _# respectively_ . See
link:jsp.html#a639[See Quoting and Escape Conventions.] and
link:jsp.html#a1823[See Overview of Syntax of JSP Documents.]
for details.

=== Disabling Scripting Elements

With the addition of the EL, some JSP page
authors, or page authoring groups, may want to follow a methodology
where scripting elements are not allowed. Previous versions of JSP
enabled this through the notion of a _TagLibraryValidator_ that would
verify that the elements are not present. JSP 2.0 makes this slightly
easier through a JSP configuration element.

The _scripting-invalid_ element is a
subelement of _jsp-property-group_ (see link:jsp.html#a1225[See
JSP Property Groups.]). It has no subelements. Its valid values are
_true_ and _false_ . Scripting is enabled by default. Disabling
scripting elements can be done by setting the _scripting-invalid_
element to _true_ in the JSP configuration.

For example, the following _web.xml_ fragment
defines a group that disables scripting elements for all JSP pages
delivered using the _.jsp_ extension:

<jsp-property-group> +
<url-pattern>*.jsp</url-pattern> +
<scripting-invalid>true</scripting-invalid> +
</jsp-property-group>

link:jsp.html#a1285[See Scripting
Settings.] summarizes the scripting settings and their meanings:

=== [[a1285]]Scripting Settings

JSP Configuration +
<scripting-invalid>

Scripting Encountered

unspecified

Valid

false

Valid

true

Translation Error

=== Declaring Page Encodings

The JSP configuration element _page-encoding_
can be used to easily set the _pageEncoding_ property of a group of JSP
pages defined using the _jsp-property-group_ element. This is only
needed for pages in standard syntax, since for documents in XML syntax
the page encoding is determined as described in section 4.3.3 and
appendix F.1 of the XML specification.

The _page-encoding_ element is a subelement
of _jsp-property-group_ (see link:jsp.html#a1225[See JSP
Property Groups.]). It has no subelements. Its valid values are those of
the _pageEncoding_ page directive. It is a translation-time error to
name different encodings in the _pageEncoding_ attribute of the page
directive of a JSP page and in a JSP configuration element matching the
page. It is also a translation-time error to name different encodings in
the prolog / text declaration of the document in XML syntax and in a JSP
configuration element matching the document. It is legal to name the
same encoding through multiple mechanisms.

For example, the following _web.xml_ fragment
defines a group that explicitly assigns _Shift_JIS_ to all JSP pages and
included JSP segments in the _/ja_ subdirectory of the web application:

<jsp-property-group> +
<url-pattern>/ja/*</url-pattern> +
<page-encoding>Shift_JIS</page-encoding> +
</jsp-property-group>

=== [[a1299]]Defining Implicit Includes

The _include-prelude_ element is an optional
subelement of _jsp-property-group_ . It has no subelements. Its value is
a context-relative path that must correspond to an element in the Web
Application. When the element is present, the given path will be
automatically included (as in an _include_ directive) at the beginning
of the JSP page in the _jsp-property-group_ . When there are more than
one _include-prelude_ element in a group, they are to be included in the
order they appear. When more than one _jsp-property-group_ applies to a
JSP page, the corresponding include-prelude elements will be processed
in the same order as they appear in the JSP configuration section of
_web.xml_ .

The _include-coda_ element is an optional
subelement of _jsp-property-group_ . It has no subelements. Its value is
a context-relative path that must correspond to an element in the Web
Application. When the element is present, the given path will be
automatically included (as in an _include_ directive) at the end of the
JSP page in the _jsp-property-group_ . When there are more than one
_include-coda_ element in a group, they are to be included in the order
they appear. When more than one _jsp-property-group_ applies to a JSP
page, the corresponding _include-coda_ elements will be processed in the
same order as they appear in the JSP configuration section of _web.xml_
. Note that these semantics are in contrast to the way _url-pattern_ s
are matched for other configuration elements.

Preludes and codas follow the same rules as
statically included JSP segments. In particular, start tags and end tags
must appear in the same file (see link:jsp.html#a306[See Start
and End Tags.]).

For example, the following _web.xml_ fragment
defines two groups. Together they indicate that everything in directory
_/two/_ have _/WEB-INF/jspf/prelude1.jspf_ and
_/WEB-INF/jspf/prelude2.jspf_ at the beginning and
_/WEB-INF/jspf/coda1.jspf_ and _/WEB-INF/jspf/coda2.jspf_ at the end, in
that order, while other _.jsp_ files only have +
_/WEB-INF/jspf/prelude1.jspf_ at the beginning and
_/WEB-INF/jspf/coda1.jspf_ at the end.

<jsp-property-group> +
<url-pattern>*.jsp</url-pattern> +
<include-prelude>/WEB-INF/jspf/prelude1.jspf</include-prelude> +
<include-coda>/WEB-INF/jspf/coda1.jspf</include-coda> +
</jsp-property-group>

<jsp-property-group> +
<url-pattern>/two/*</url-pattern> +
<include-prelude>/WEB-INF/jspf/prelude2.jspf</include-prelude> +
<include-coda>/WEB-INF/jspf/coda2.jspf</include-coda> +
</jsp-property-group>

=== Denoting XML Documents

The JSP configuration element _is-xml_ can be
used to denote that a group of files are JSP documents, and thus must be
interpreted as XML documents.

The _is-xml_ element is a subelement of
_jsp-property-group_ (see link:jsp.html#a1225[See JSP Property
Groups.]). It has no subelements. Its valid values are _true_ and
_false_ . When _false_ , the files in the associated property group are
assumed to not be JSP documents, unless there is another property group
that indicates otherwise. The files are still considered to be JSP pages
due to the implicit property given by the _<jsp-property-group>_
element.

For example, the following _web.xml_ fragment
defines two groups. The first one indicates that those files with
extension _.jspx_ , which is the default extension for JSP documents,
are instead just plain JSP pages. The last group indicates that files
with extension _.svg_ are actually JSP documents (which most likely are
generating SVG files).

<jsp-property-group> +
<url-pattern>*.jspx</url-pattern> +
<is-xml>false</is-xml> +
</jsp-property-group>

<jsp-property-group> +
<url-pattern>*.svg</url-pattern> +
<is-xml>true</is-xml> +
</jsp-property-group>

=== [[a1312]]Deferred Syntax (character sequence _#\{)_

As of JSP 2.1, the character sequence _#\{_
is reserved for EL expressions. Consequently, a translation error occurs
if the _#\{_ character sequence is used as a String literal (in template
text of a JSP 2.1+ container or as an attribute value for a tag-library
where jsp-version is 2.1+).

The _deferred-syntax-allowed-as-literal_
element is a subelement of _jsp-property-group_ (See
link:jsp.html#a1225[See JSP Property Groups.]). It has no
subelements. Its valid values are _true_ and _false_ , and it is
disabled ( _false_ ) by default. Allowing the character sequence #\{
when used as a String literal can be done by setting the
_deferred-syntax-allowed-as-literal_ element to _true_ in the JSP
configuration.

Page authors can override the default value
through the _deferredSyntaxAllowedAsLiteral_ attribute of the page
directive (see link:jsp.html#a763[See Directives.]). See also
link:jsp-1.html#a28[See Backwards Compatibility with JSP 2.0.]
for more information.

=== [[a1316]]Removing whitespaces from template text

Whitespaces in template text of a JSP page
are preserved by default (See link:jsp.html#a333[See White
Space.]). Unfortunately, this means that unwanted extraneous whitespaces
often make it into the response output.

For example, the following code snippet
(where _↵_ represents the end-of-line character(s))

<%@ taglib prefix=”c”
uri=”http://java.sun.com/jsp/jstl/core” %> _↵_ +
<%@ taglib prefix=”x” uri=”http://java.sun.com/jsp/jstl/xml” %> _↵_ +
Hello World! _↵_

would generate the following output:

 _↵_ +
_↵_ +
Hello World! _↵_



For JSP pages (standard syntax), the JSP
configuration element _trim-directive-whitespaces_ can be used to
indicate that template text containing only whitespaces must be removed
from the response output. It has no effect on JSP documents (XML
syntax).In the example above, the first _↵_ represents template text
that contains only whitespaces and would therefore be removed. _↵_
HelloWorld! _↵_ represents template text that does not contain only
whitespaces and would therefore be preserved as-is.

 _↵_ +
Hello World! _↵_

The _trim-directive-whitespaces_ element is a
subelement of _jsp-property-group_ (See link:jsp.html#a1225[See
JSP Property Groups.]). It has no subelements. Its valid values are
_true_ and _false_ , and it is disabled ( _false_ ) by default. Enabling
the trimming of whitespaces can be done by setting the
_trim-directive-whitespaces_ element to _true_ in the JSP configuration.

Page authors can override the default value
through the _trimDirectiveWhitespaces_ attribute of the page directive
(see link:jsp.html#a763[See Directives.]).

=== [[a1327]]Declaring Default Content Type

The JSP configuration element
default-content-type can be used to specify the default contentType
property of a group of JSP pages defined using the jsp-property-group
element.

The valid values for the default-content-type
element are those of the contentType attribute of the page directive. It
specifies the default response contentType if the page directive does
not include a contentType attribute.

=== [[a1330]]Setting Default Buffer Size

The JSP configuration element buffer can be
used to specify the default buffering model for the initial out
JspWriter for a group of JSP pages defined using the the
jsp-property-group element.

The valid values for the buffer element are
those of the buffer attribute of the page directive. It can be used to
specify if buffering should be used for the output to Response, and if
so, the size of the buffer to use.

=== Raising Errors for Undeclared Namespaces

The default behavior when a tag with unknown
namespace is used in a JSP page is to silently ignore it. For most page
authors, this is often a source of errors. To make the mistakes obvious,
this JSP configuration element can be used to force an error when an
unknown namespace is used in a JSP page, as is already the case for JSP
documents (XML syntax).

The error-on-undeclared-namespace element is
a subelement of jsp-property-group . It has no subelements. Its valid
valuesare true and false, with false being the default.

 If it is set to true, then an error must be
raised during the translation time, when an undeclared tag is used in a
JSP page.



== CHAPTER 3 - 

=== [[a1339]]Internationalization Issues

This chapter describes requirements for
internationalization with JavaServer Pages.

The JSP specification by itself does not
provide a complete platform for internationalization. It is complemented
by functionality provided by the underlying Java Standard Edition
platform, the Servlet APIs, and by tag libraries such as the JSP
Standard Tag Library (JSTL) with its collection of internationalization
and formatting actions. For complete information, see the respective
specifications.

Primarily, this specification addresses the
issues of character encodings.

The Java programming language represents
characters internally using the Unicode character encoding, which
provides support for most languages. As of J2SE 1.4, the Unicode 3.0
character set is supported. For storage and transmission over networks,
however, many other character encodings are used. The J2SE platform
therefore also supports character conversion to and from other character
encodings. Any Java runtime must support the Unicode transformations
UTF-8, UTF-16BE, and UTF-16LE as well as the ISO-8859-1 (Latin-1)
character encoding, but most implementations support many more. The
character encodings supported by Sun’s Java 2 Runtime Environment
version 1.3 and version 1.4 respectively are described at:



http://java.sun.com/j2se/1.3/docs/guide/intl/encoding.doc.html

http://java.sun.com/j2se/1.4/docs/guide/intl/encoding.doc.html



In JSP pages and in JSP configuration
elements, character encodings are named using the names defined in the
IANA charset registry:



http://www.iana.org/assignments/character-sets

=== [[a1351]]Page Character Encoding

The page character encoding is the character
encoding in which the JSP page or tag file itself is encoded. The
character encoding is determined for each file separately, even if one
file includes another using the include directive
(link:jsp.html#a894[See The include Directive.]). A detailed
algorithm for determining the page character encoding of a JSP page or
tag file can be found in link:jsp.html#a5854[See Page Encoding
Detection.].

=== Standard Syntax

For JSP pages in standard syntax, the page
character encoding is determined from the following sources:

* A byte order mark (BOM)
* A JSP configuration element _page-encoding_
value whose URL pattern matches the page.
* The _pageEncoding_ attribute of the _page_
directive of the page. It is a translation-time error to name different
encodings in the _pageEncoding_ attribute of the page directive of a JSP
page and in a JSP configuration element whose URL pattern matches the
page.
* The charset value of the _contentType_
attribute of the page directive. This is used to determine the page
character encoding if neither a JSP configuration element
_page-encoding_ nor the _pageEncoding_ attribute are provided.
* If none of the above is provided,
ISO-8859-1 is used as the default character encoding.

For tag files in standard syntax, the page
character encoding is determined from a BOM or the _pageEncoding_
attribute of the _tag_ directive of the tag file (in this precedence
order), or is _ISO-8859-1_ if neither is specified.



A BOM consists of the Unicode character code
U+FEFF at the beginning of a data stream, where it is used to define the
byte order and encoding form of unmarked plaintext files.

The exact byte representation of the BOM
depends on the particular encoding of the text file, as follows:

=== Byte representations of the BOM

[width="100%",cols="50%,50%",]
|===
|Bytes |Encoding
Form

a|
=== FE FF

|UTF-16, big-endian

a|
=== FF FE

|UTF-16, little-endian

a|
=== 00 00 FE FF

|UTF-32, big-endian

a|
=== FF FE 00 00

|UTF-32, little-endian

a|
=== EF BB BF

|UTF-8
|===

 The above byte sequences have been reserved
to identify a BOM at the beginning of JSP pages in standard syntax, and
will not appear in the page's output.

The _pageEncoding_ and _contentType_
attributes determine the page character encoding of only the file that
physically contains them. Parsers are only required to take these
attributes into consideration for character encoding detection if the
directive appears at the beginning of the page or tag file and if the
character encoding is an extension of ASCII, that is, if byte values 0
to 127 have the same meaning as in ASCII, at least until the attributes
are found. For character encodings where this is not the case (including
_UTF-16_ and _EBCDIC_ -based encodings), the JSP configuration element
_page-encoding_ or a BOM should be used.

When using a BOM, it is legal to describe the
character encoding in a JSP configuration element page-encoding or a
pageEncoding attribute of the page directive of the page, as long as
they are consistent.

=== XML Syntax

For JSP documents and tag files in XML
syntax, the page character encoding is determined as described in
section 4.3.3 and appendix F.1 of the XML specification.

For JSP documents in XML syntax, it is legal
to also describe the character encoding in a JSP configuration element
_page-encoding_ or a _pageEncoding_ attribute of the page directive of
the document, as long as they are consistent. It is a translation-time
error to name different encodings in two or more of the following: the
XML prolog / text declaration of a JSP document, the _pageEncoding_
attribute of the page directive of the JSP document, and in a JSP
configuration element whose URL pattern matches the document.

Note that for tag files in XML syntax, it is
illegal for the tag directive to include a pageEncoding attribute: the
encoding is inferred solely by using the conventions for XML documents.

A JSP container must raise a translation-time
error if an unsupported page character encoding is requested.

=== [[a1384]]Response Character Encoding

The response character encoding is the
character encoding of the response generated from a JSP page, if that
response is in the form of text. It is primarily managed as the
_javax.servlet.ServletResponse_ object’s _characterEncoding_ property.

{empty}The JSP container determines an
initial response character encoding along with the initial content type
for a JSP page and calls _ServletResponse.setContentType()_ with this
information before processing the page. JSP pages can set initial
content type and initial response character encoding using the
_contentType_ attribute of the page directive. The JSP configuration
element default-content-type can also be used to set the default initial
content type and default initial response chrarcter encoding of a group
of JSP pages using the jsp-property-group element. See
link:jsp.html#a1327[See Declaring Default Content Type.]

The initial response content type is set to
the _TYPE_ value of the _contentType_ attribute of the page directive.
If the page doesn’t provide this attribute, the initial content type is
“ _text/html_ ” for JSP pages in standard syntax and “ _text/xml_ ” for
JSP documents in XML syntax.

The initial response character encoding is
set to the _CHARSET_ value of the _contentType_ attribute of the page
directive. If the page doesn’t provide this attribute or the attribute
doesn’t have a _CHARSET_ value, the initial response character encoding
is determined as follows:

* For documents in XML syntax, it is _UTF-8_
.
* For JSP pages in standard syntax, it is the
character encoding specified by the BOM, by the _pageEncoding_ attribute
of the page directive, or by a JSP configuration element _page-encoding_
whose URL pattern matches the page. Only the character encoding
specified for the requested page is used; the encodings of files
included via the include directive are not taken into consideration. If
there’s no such specification, no initial response character encoding is
passed to _ServletResponse.setContentType()_ - the _ServletResponse_
object’s default, _ISO-8859-1_ , is used.

After the initial response character encoding
has been set, the JSP page’s content can dynamically modify it by
calling the _ServletResponse_ object’s _setCharacterEncoding_ and
_setLocale_ methods directly or indirectly. A number of JSTL
internationalization and formatting actions call
_ServletResponse.setLocale()_ , which may affect the response character
encoding. See the Servlet and JSTL specifications for more information.

Note that the response character encoding can
only be changed until the response is committed. Data is sent to the
response stream on buffer flushes for buffered pages, or on encountering
the first content (beware of whitespace) on unbuffered pages. Whitespace
is notoriously tricky for JSP Pages in JSP syntax, but much more
manageable for JSP Documents in XML syntax.

=== Request Character Encoding

The request character encoding is the
character encoding in which parameters in an incoming request are
interpreted. It is primarily managed as the _ServletRequest_ object’s
_characterEncoding_ property.

The JSP specification doesn’t provide
functionality to handle the request character encoding directly. To
control the request character encoding from JSP pages without embedded
Java code, the JSTL _<fmt:requestEncoding>_ can be used.

=== XML View Character Encoding

The XML view character encoding is the
character encoding used for externalizing the XML view of a JSP page or
tag file.

The XML view character encoding is always
_UTF-8_ .

=== Delivering Localized Content

The JSP specification does not mandate any
specific approach for structuring localized content, and different
approaches are possible. Two common approaches are to use a template
taglib and pull localized strings from a resource repository, or to
use-per-locale JSP pages. Each approach has benefits and drawbacks. The
JSTL internationalization and formatting actions provide support for
retrieving localized content from resource bundles and thus support the
first approach. Some users have been using transformations on JSP
documents to do simple replacement of elements by localized strings,
thus maintaining JSP syntax with no performance cost at run-time.
Combinations of these approaches also make sense.



== CHAPTER 4 - 

=== [[a1403]]Standard Actions

This chapter describes the standard
actions of JavaServer Pages 2.2 (JSP 2.2). Standard actions are
represented using XML elements with a prefix of _jsp_ (though that
prefix can be redefined in the XML syntax). A translation error will
result if the JSP prefix is used for an element that is not a standard
action.

=== <jsp:useBean>

A __ _jsp:useBean_ action associates an
instance of a Java programming language object defined within a given
scope and available with a given _id_ with a newly declared scripting
variable of the same _id_ .

When a _<jsp:useBean>_ action is used in an
scriptless page, or in an scriptless context (as in the body of an
action so indicated), there are no Java scripting variables created but
instead an EL variable is created.

The _jsp:useBean_ action is quite flexible;
its exact semantics depends on the attributes given. The basic semantic
tries to find an existing object using _id_ and _scope_ . If the object
is not found it will attempt to create the object using the other
attributes.

It is also possible to use this action to
give a local name to an object defined elsewhere, as in another JSP page
or in a servlet. This can be done by using the _type_ attribute and not
providing _class_ or _beanName_ attributes.

At least one of _type_ and _class_ must be
present, and it is not valid to provide both _class_ and _beanName_ . If
_type_ and _class_ are present, _class_ must be assignable to _type_ __
(in the Java platform sense). For it not to be assignable is a
translation-time error.

The attribute _beanName_ specifies the name
of a Bean, as specified in the JavaBeans specification. It is used as an
argument to the _instantiate_ method in the _java.beans.Beans_ __ class.
It must be of the form _a.b.c_ , which may be either a class, or the
name of a resource of the form _a/b/c.ser_ that will be resolved in the
current _ClassLoader_ . If this is not true, a request-time exception,
as indicated in the semantics of the _instantiate_ method will be
raised. The value of this attribute can be a request-time attribute
expression.

=== The id Attribute

The _id=”name”_ attribute/value tuple in a
_jsp:useBean_ action has special meaning to a JSP container, at page
translation time and at client request processing time. In particular:

* the _name_ must be unique within the
translation unit, and identifies the particular element in which it
appears to the JSP container and page.

Duplicate _id_ ’s found in the same
translation unit shall result in a fatal translation error.

* The JSP container will associate an object
(a JavaBean component) with the named value and accessed via that name
in various contexts through the _pagecontext_ object described later in
this specification.

The _name_ is also used to expose a variable
( _name_ ) in the page’s scripting language environment. The scope of
the scripting language variable is dependent upon the scoping rules and
capabilities of the scripting language used in the page.

Note that this implies the _name_ value
syntax must comply with the variable naming syntax rules of the
scripting language used in the page. link:jsp.html#a2599[See
Scripting.] provides details for the case where the language attribute
is _java_ .

An example of the scope rules just mentioned
is shown next:

<% \{ // introduce a new block %> +
... +
<jsp:useBean id=”customer” class=”com.myco.Customer” /> +
 +
<% +
/* +
* the tag above creates or obtains the Customer Bean +
* reference, associates it with the name “customer” in the +
* PageContext, and declares a Java programming language +
* variable of the same name initialized to the object reference +
* in this block’s scope. +
*/ +
%> +
... +
<%= customer.getName(); %> +
... +
<% } // close the block %> +
 +
<% +
// the variable customer is out of scope now but +
// the object is still valid (and accessible via pageContext) +
%>

=== The scope Attribute

The
_scope=”page|request|session|application”_ attribute/value tuple is
associated with, and modifies the behavior of the _id_ attribute
described above (it has both translation time and client request
processing time semantics). In particular it describes the namespace,
the implicit lifecycle of the object reference associated with the
_name_ , and the APIs used to access this association. For all scopes,
it is illegal to change the instance object so associated, such that its
new runtime type is a subset of the type(s) of the object previously so
associated. See link:jsp.html#a692[See Objects and Scopes.] for
details on the available scopes.

=== Semantics

The actions performed in a _jsp:useBean_
action are:

. An attempt to locate an object based on the
attribute values _id_ _and_ _scope_ . For application and session scope,
the inspection is done synchronized per scope namespace to avoid
non-deterministic behavior.
. A scripting language variable of the
specified type (if given) or _class_ (if _type_ is not given) is defined
with the given _id_ in the current lexical scope of the scripting
language. The _type_ attribute should be used to specify a Java type
that cannot be instantiated as a JavaBean (i.e. a Java type that is an
abstract class, interface, or a class with no public no-args
constructor). If the _class_ attribute is used for a Java type that
cannot be instantiated as a JavaBean, the container may consider the
page invalid, and is recommended to (but not required to) produce a
fatal translation error at translation time, or a
_java.lang.InstantiationException_ __ at request time. Similarly, if
either _type_ or _class_ specify a type that can not be found, the
container may consider the page invalid, and is recommended to (but not
required to) produce a fatal translation error at translation time, or a
_java.lang.ClassNotFoundException_ at request time.
. If the object is found, the variable’s
value is initialized with a reference to the located object, cast to the
specified _type_ . If the cast fails, a _java.lang.ClassCastException_
shall occur. This completes the processing of this _jsp:useBean_ action.
. If the _jsp:useBean_ action had a non-empty
body it is ignored. This completes the processing of this _jsp:useBean_
action.
. If the object is not found in the specified
scope and neither class nor beanName are given, a
_java.lang.InstantiationException_ shall occur. This completes the
processing of this _jsp:useBean_ action.
. If the object is not found in the specified
_scope_ , and the _class_ specified names a non-abstract class that
defines a public no-args constructor, then the class is instantiated.
The new object reference is associated with the scripting variable and
with the specified name in the specified scope using the appropriate
scope dependent association mechanism (see _PageContext_ ). After this,
step 8 is performed.
. If the object is not found, and the _class_
is either abstract, an _interface_ , or no public no-args constructor is
defined therein, then a _java.lang.InstantiationException_ shall occur.
This completes the processing of this _jsp:useBean_ action.
. If the object is not found in the specified
_scope_ ; and _beanName_ is given, then the method _instantiate_ of
_java.beans.Beans_ will be invoked with the _ClassLoader_ of the servlet
object and the _beanName_ as arguments. If the method succeeds, the new
object reference is associated the with the scripting variable and with
the specified name in the specified scope using the appropriate scope
dependent association mechanism (see _PageContext_ ). After this, step 8
is performed.
. If the _jsp:useBean_ action has a non-empty
body, the body is processed. The variable is initialized and available
within the scope of the body. The text of the body is treated as
elsewhere. Any template text will be passed through to the out stream.
Scriptlets and action tags will be evaluated.

A common use of a non-empty body is to
complete initializing the created instance. In that case the body will
likely contain _jsp:setProperty_ actions and scriptlets that are
evaluated. This completes the processing of this _useBean_ action.

=== Examples

In the following example, a Bean with name
_connection_ of type _com.myco.myapp.Connection_ is available after
actions on this element, either because it was already created and
found, or because it is newly created.

<jsp:useBean id=”connection”
class=”com.myco.myapp.Connection” />

In the next example, the _timeout_ property
is set to 33 if the Bean was instantiated.

 _<jsp:useBean id=”connection”
class=”com.myco.myapp.Connection”> +
<jsp:setProperty name=”connection” property=”timeout” value=”33”> +
</jsp:useBean>_

In the final example, the object should have
been present in the session. If so, it is given the local name _wombat_
with _WombatType_ . A _ClassCastException_ __ may be raised if the
object is of the wrong class, and an _InstantiationException_ may be
raised if the object is not defined.

 _<jsp:useBean id=”wombat”
type=”my.WombatType” scope=”session”/>_

=== Syntax

This action may or not have a body. If the
action has no body, it is of the form:

<jsp:useBean id="name"
scope="page|request|session|application" typeSpec />

typeSpec ::= class=”className” | +
class=”className” type=”typeName” | +
type=”typeName” class=”className” | +
beanName=”beanName” type=”typeName” | +
type=”typeName” beanName=”beanName” | +
type=”typeName”

If the action has a body, it is of the form:

<jsp:useBean id="name"
scope="page|request|session|application" typeSpec > +
body +
</jsp:useBean>

In this case, the body will be invoked if the
Bean denoted by the action is created. Typically, the body will contain
either scriptlets or _jsp:setProperty_ tags that will be used to modify
the newly created object, but the contents of the body are not
restricted.

The _<jsp:useBean>_ tag has the following
attributes:

=== jsp:useBean Attributes

 _id_

The name used to identify the object instance
in the specified scope’s namespace, and also the scripting variable name
declared and initialized with that object reference. The name specified
is case sensitive and shall conform to the current scripting language
variable-naming conventions.

 _scope_

The scope within which the reference is
available. The default value is _page_ . See the description of the
_scope_ attribute defined earlier herein. A translation error must occur
if scope is not one of “ _page_ ”, “ _request_ ”, “ _session_ ” or “
_application_ ”.

 _class_

The fully qualified name of the class that
defines the implementation of the object. The class name is case
sensitive.

If the _class_ and _beanName_ attributes are
not specified the object must be present in the given scope.

 _beanName_

The name of a bean, as expected by the
_instantiate_ method of the _java.beans.Beans_ __ class.

This attribute can accept a request-time
attribute expression as a value.

 _type_

If specified, it defines the type of the
scripting variable defined.

This allows the type of the scripting
variable to be distinct from, but related to, the type of the
implementation class specified.

The type is required to be either the class
itself, a superclass of the class, or an interface implemented by the
class specified.

The object referenced is required to be of
this type, otherwise a _java.lang.ClassCastException_ shall occur at
request time when the assignment of the object referenced to the
scripting variable is attempted.

If unspecified, the value is the same as the
value of the _class_ attribute.

=== <jsp:setProperty>

The _jsp:setProperty_ action sets the values
of properties in a bean. The _name_ attribute that denotes the bean must
be defined before this action appears.

There are two variants of the
_jsp:setProperty_ action. Both variants set the values of one or more
properties in the bean based on the type of the properties. The usual
bean introspection is done to discover what properties are present, and,
for each, its name, whether it is simple or indexed, its type, and the
_setter_ and _getter_ methods. Introspection also indicates if a given
property type has a _PropertyEditor_ class.

Properties in a Bean can be set from one or
more parameters in the request object, from a _String_ constant, or from
a computed request-time expression. Simple and indexed properties can be
set using _jsp:setProperty_ .

When assigning from a parameter in the
request object, the conversions described in
link:jsp.html#a1020[See Conversions from String values.] are
applied, using the target property to determine the target type.

When assigning from a value given as a String
constant, the conversions described in link:jsp.html#a1020[See
Conversions from String values.] are applied, using the target property
to determine the target type.

When assigning from a value given as a
request-time attribute, no type conversions are applied if a scripting
expression is used, as indicated in link:jsp.html#a1050[See
Conversions from request-time expressions.]. If an EL expression is
used, the type conversions described in Section 1.16 “Type Conversion”
of the EL specification document are performed.

When assigning values to indexed properties
the value must be an array; the rules described in the previous
paragraph apply to the actions.

A conversion failure leads to an error,
whether at translation time or request-time.

=== Examples

The following two actions set a value from
the request parameter values.

 _<jsp:setProperty name=”request”
property=”*” /> +
<jsp:setProperty name=”user” property=”user” param=”username” />_

The following two elemenst set a property
from a value

 _<jsp:setProperty name=”results”
property=”col” value=”$\{i mod 4}”/> +
<jsp:setProperty name=”results” property=”row” value=”<%= i/4 %>” />_

=== Syntax

<jsp:setProperty name="beanName" prop_expr />

 _prop_expr ::= +
property="*" | +
property=”propertyName” | +
property=”propertyName” param="parameterName" | +
property=”propertyName” value=”propertyValue”_

propertyValue ::= string

The value _propertyValue_ can also be a
request-time attribute value, as described in
link:jsp.html#a1004[See Request Time Attribute Values.].

{empty}propertyValue ::=
expr_scriptletlink:#a6613[3]

The _<jsp:setProperty>_ action has the
following attributes:

=== jsp:setProperty Attributes

 _name_

The name of a bean instance defined by a
_<jsp:useBean>_ action or some other action. The bean instance must
contain the property to be set. The _defining action_ must appear before
the _<jsp:setProperty>_ action in the same file.

 _property_

The name of the property whose value will be
set. _I_ _f_ _propertyName_ _is set to_ _*_ _then the tag will iterate
over the current_ _ServletRequest_ _parameters, matching paramet_ er
names and value type(s) to property names and setter method type(s),
setting each matched property to the value of the matching parameter. If
a parameter has a value of _""_ , the corresponding property is not
modified.

 _param_

The name of the request parameter whose value
is given to a bean property. The name of the request parameter usually
comes from a web form.

If _param_ is omitted, the request parameter
name is assumed to be the same as the bean property name.

If the _param_ is not set in the Request
object, or if it has the value of _““_ , the _jsp:setProperty_ action
has no effect (a noop).

An action may not have both _param_ and
_value_ attributes.

 _value_

The value to assign to the given property.

This attribute can accept a request-time
attribute expression as a value.

An action may not have both _param_ and
_value_ attributes.

=== <jsp:getProperty>

The _<_ _jsp:getProperty_ _>_ action places
the value of a bean instance property, converted to a _String_ , into
the implicit _out_ object, from which the value can be displayed as
output. The bean instance must be defined as indicated in the _name_
attribute before this point in the page (usually via a _jsp:useBean_
action).

The conversion to String is done as in the
_println_ methods, i.e. the _toString_ method of the object is used for
Object instances, and the primitive types are converted directly.

If the object is not found, a request-time
exception is raised.

The value of the name attribute in
_jsp:setProperty_ and _jsp:getProperty_ will refer to an object that is
obtained from the _pageContext_ object through its _findAttribute_
method.

The object named by the name must have been
“introduced” to the JSP processor using either the _jsp:useBean_ action
or a custom action with an associated _VariableInfo_ entry for this
name. If the object was not introduced in this manner, the container
implementation is recommended (but not required) to raise a translation
error, since the page implementation is in violation of the
specification.

* 

If the JSP processor can ascertain that there
is an alternate way guaranteed to access the same object, it can use
that information. For example it may use a scripting variable, but it
must guarantee that no intervening code has invalidated the copy held by
the scripting variable. The truth is always the value held by the
_pageContext_ object.

=== Examples

<jsp:getProperty name=”user” property=”name”
/>

=== Syntax

<jsp:getProperty name=”name”
property=”propertyName” />

The attributes are:

=== jsp:getProperty Attributes

 _name_

The name of the object instance from which
the property is obtained.

 _property_

Names the property to get.

=== <jsp:include>

A _<jsp:include .../>_ action provides for
the inclusion of static and dynamic resources in the same context as the
current page. See _link:jsp.html#a909[See Summary of Include
Mechanisms in JSP 2.2.]_ for a summary of include facilities.

Inclusion is into the current value of _out_
. The resource is specified using a _relativeURLspec_ that is
interpreted in the context of the web application (i.e. it is mapped).

The _page_ attribute of both the
_jsp:include_ and the _jsp:forward_ actions are interpreted relative to
the current JSP page, while the _file_ attribute in an include directive
is interpreted relative to the current JSP file. See below for some
examples of combinations of this.

An included page cannot change the response
status code or set headers. This precludes invoking methods like
_setCookie_ . Attempts to invoke these methods will be ignored. The
constraint is equivalent to the one imposed on the _include_ method of
the _RequestDispatcher_ class.

A _jsp:include_ action may have _jsp:param_
subelements that can provide values for some parameters in the request
to be used for the inclusion.

Request processing resumes in the calling JSP
page, once the inclusion is completed.

The _flush_ attribute controls flushing. If
true, then, if the page output is buffered and the flush attribute is
given a true value, then the buffer is flushed prior to the inclusion,
otherwise the buffer is not flushed. The default value for the flush
attribute is _false_ .

=== Examples

<jsp:include
page=”/templates/copyright.html”/>

The above example is a simple inclusion of an
object. The path is interpreted in the context of the Web Application.
It is likely a static object, but it could be mapped into, for instance,
a servlet via _web.xml_ .

For an example of a more complex set of
inclusions, consider the following four situations built using four JSP
files: _A.jsp_ , _C.jsp_ , _dir/B.jsp_ and _dir/C.jsp_ :

*  _A.jsp_ says _<%@ include
file=”dir/B.jsp”%>_ and _dir/B.jsp_ says _<%@ include file=”C.jsp”%>_ .
In this case the relative specification _C.jsp_ resolves to _dir/C.jsp_
.
*  _A.jsp_ says _<jsp:include
page=”dir/B.jsp”/>_ and _dir/B.jsp_ says _<jsp:include page=”C.jsp” />_
. In this case the relative specification _C.jsp_ resolves to
_dir/C.jsp_ .
*  _A.jsp_ says _<jsp:include
page=”dir/B.jsp”/>_ and _dir/B.jsp_ says _<%@ include file=”C.jsp” %>_ .
In this case the relative specification _C.jsp_ resolves to _dir/C.jsp_
.
*  _A.jsp_ says _<%@ include
file=”dir/B.jsp”%>_ and _dir/B.jsp_ says _<jsp:include page=”C.jsp”/>_ .
In this case the relative specification _C.jsp_ resolves to _C.jsp_ .

=== Syntax

<jsp:include page=”urlSpec”
flush="true|false"/>

and

<jsp:include page=”urlSpec”
flush="true|false"> +
\{ <jsp:param .... /> }* +
</jsp:include>

The first syntax just does a request-time
inclusion. In the second case, the values in the _param_ subelements are
used to augment the request for the purposes of the inclusion.

The valid attributes are:

=== jsp:include Atrributes

 _page_

The URL is a relative _urlSpec_ as in
link:jsp.html#a274[See Relative URL Specifications.]. Relative
paths are interpreted relative to the current JSP page.

Accepts a request-time attribute value (which
must evaluate to a String that is a relative URL specification).

 _flush_

Optional boolean attribute. If the value is
_true_ , the buffer is flushed now. The default value is _false_ .

=== <jsp:forward>

A _<jsp:forward page=”urlSpec” />_ action
allows the runtime dispatch of the current request to a static resource,
a JSP page or a Java servlet class in the same context as the current
page. A _jsp:forward_ effectively terminates the execution of the
current page. The relative _urlSpec_ is as in
link:jsp.html#a274[See Relative URL Specifications.].

The request object will be adjusted according
to the value of the page attribute.

A _jsp:forward_ action may have _jsp:param_
subelements that can provide values for some parameters in the request
to be used for the forwarding.

If the page output is buffered, the buffer is
cleared prior to forwarding.

If the page output is buffered and the buffer
was flushed, an attempt to forward the request will result in an
_IllegalStateException._

If the page output was unbuffered and
anything has been written to it, an attempt to forward the request will
result in an _IllegalStateException_ .

=== Examples

The following action might be used to forward
to a static page based on some dynamic condition.

<% String whereTo = “/templates/”+someValue;
%> +
<jsp:forward page=’<%= whereTo %>’ />

=== Syntax

<jsp:forward page=”relativeURLspec” />

and

<jsp:forward page=”urlSpec”> +
\{ <jsp:param .... /> }* +
</jsp:forward>

This tag allows the page author to cause the
current request processing to be affected by the specified attributes as
follows:

=== jsp:forward Attributes

 _page_

 _The URL is a relative_ _urlSpec_ __ as in
__ link:jsp.html#a274[See Relative URL Specifications.] _._
Relative paths are interpreted relative to the current JSP page.

 _Accepts a request-time attribute value
(which must evaluate to a String that is a relative URL specification)._

=== <jsp:param>

The _jsp:param_ element is used to provide
key/value information. This element is used in the _jsp:include_ ,
_jsp:forward_ , and _jsp:params_ elements. A translation error shall
occur if the element is used elsewhere.

When doing _jsp:include_ or _jsp:forward_ ,
the included page or forwarded page will see the original request
object, with the original parameters augmented with the new parameters,
in the order of appearance, with new values taking precedence over
existing values when applicable. The scope of the new parameters is the
_jsp:include_ or _jsp:forward_ call; i.e. in the case of an
_jsp:include_ the new parameters (and values) will not apply after the
include. This is the same behavior as in the _ServletRequest_ _include_
and _forward_ methods (see Section 8.1.1 in the Servlet 2.4
specification).

For example, if the request has a parameter
_A=foo_ and a parameter _A=bar_ is specified for forward, the forwarded
request shall have _A=bar,foo_ . Note that the new _param_ has
precedence.

The parameter names and values specified
should be left unencoded by the page author. The JSP container must
encode the parameter names and values using the character encoding from
the request object when necessary. For example, if the container chooses
to append the parameters to the URL in the dispatched request, both the
names and values must be encoded as per the content type
_application/x-www-form-urlencoded_ in the HTML specification.

=== Syntax

<jsp:param name="name" value="value" />

This action has two mandatory attributes:
_name_ and _value_ . _name_ indicates the name of the parameter, and
_value_ , which may be a request-time expression, indicates its value.

=== [[a1575]]<jsp:plugin>

The plugin action enables a JSP page author
to generate HTML that contains the appropriate client browser dependent
constructs ( _OBJECT_ or _EMBED_ ) that will result in the download of
the Java Plugin software (if required) and subsequent execution of the
Applet or JavaBeans component specified therein.

The _<jsp:plugin>_ tag is replaced by either
an _<object>_ or _<embed>_ tag, as appropriate for the requesting user
agent, and emitted into the output stream of the response. The
attributes of the _<jsp:plugin>_ tag provide configuration data for the
presentation of the element, as indicated in the table below.

The _<jsp:params>_ action containing one or
more _<jsp:param>_ actions provides parameters to the Applet or
JavaBeans component.

The _<jsp:fallback>_ element indicates the
content to be used by the client browser if the plugin cannot be started
(either because _OBJECT_ or _EMBED_ is not supported by the client
browser or due to some other problem). If the plugin can start but the
Applet or JavaBeans component cannot be found or started, a plugin
specific message will be presented to the user, most likely a popup
window reporting a _ClassNotFoundException_ .

The actual plugin code need not be bundled
with the JSP container and a reference to Sun’s plugin location can be
used instead, although some vendors will choose to include the plugin
for the benefit of their customers.

=== Examples

<jsp:plugin type=”applet”
code=”Molecule.class” codebase=”/html” > +
<jsp:params> +
<jsp:param +
name=”molecule” +
value=”molecules/benzene.mol”/> +
</jsp:params> +
<jsp:fallback> +
<p> unable to start plugin </p> +
</jsp:fallback> +
</jsp:plugin>

=== Syntax

<jsp:plugin type="bean|applet" +
code="objectCode" +
codebase="objectCodebase" +
\{ align="alignment" } +
\{ archive="archiveList" } +
\{ height="height" } +
\{ hspace="hspace" } +
\{ jreversion="jreversion" } +
\{ name="componentName" } +
\{ vspace="vspace" } +
\{ title=”title” } +
\{ width="width" } +
\{ nspluginurl="url" } +
\{ iepluginurl="url" } +
\{ mayscript=’true|false’ } >

 _\{ <jsp:params> +
\{ <jsp:param name="paramName" value=”paramValue" /> }+ +
</jsp:params> }_

 _\{ <jsp:fallback> arbitrary_text
</jsp:fallback> } +
</jsp:plugin>_

=== jsp:plugin Attributes

 _type_

Identifies the type of the component; a bean,
or an Applet.

 _code_

As defined by HTML spec

 _codebase_

As defined by HTML spec

 _align_

As defined by HTML spec

 _archive_

As defined by HTML spec

 _height_

As defined by HTML spec.

Accepts a run-time expression value.

 _hspace_

As defined by HTML spec.

 _jreversion_

Identifies the spec version number of the JRE
the component requires in order to operate; the default is: _1.2_

 _name_

As defined by HTML spec

 _vspace_

As defined by HTML spec

 _title_

As defined by the HTML spec

 _width_

As defined by HTML spec.

Accepts a run-time expression value.

 _nspluginurl_

URL where JRE plugin can be downloaded for
Netscape Navigator, default is implementation defined.

 _iepluginurl_

URL where JRE plugin can be downloaded for
IE, default is implementation defined.

 _mayscript_

As defined by HTML spec.

=== <jsp:params>

The _jsp:params_ action is part of the
_jsp:plugin_ action and can only occur as a direct child of a
_<jsp:plugin>_ action. Using the _jsp:params_ element in any other
context shall result in a translation-time error.

The semantics and syntax of _jsp:params_ are
described in link:jsp.html#a1575[See <jsp:plugin>.].

=== <jsp:fallback>

The _jsp:fallback_ action is part of the
_jsp:plugin_ action and can only occur as a direct child of a
_<jsp:plugin>_ element. Using the _jsp:fallback_ element in any other
context shall result in a translation-time error.

The semantics and syntax of _jsp:fallback_
are described in link:jsp.html#a1575[See <jsp:plugin>.].

=== [[a1626]]<jsp:attribute>

The _<jsp:attribute>_ standard action has two
uses. It allows the page author to define the value of an action
attribute in the body of an XML element instead of in the value of an
XML attribute. It also allows the page author to specify the attributes
of the element being output, when used inside a _<jsp:element>_ action.
The action must only appear as a subelement of a standard or custom
action. An attempt to use it otherwise must result in a translation
error. For example, it cannot be used to specify the value of an
attribute for XML elements that are template text. For custom action
invocations, JSP containers must support the use of _<jsp:attribute>_
for both Classic and Simple Tag Handlers.

The behavior of the _<jsp:attribute>_
standard action varies depending on the type of attribute being
specified, as follows:

* A translation error must occur if
_<jsp:attribute>_ is used to define the value of an attribute of
_<jsp:attribute>_ .
* If the enclosing action is _<jsp:element>_
, the value of the name attribute and the body of the action will be
used as attribute name/value pairs in the dynamically constructed
element. See link:jsp.html#a1702[See <jsp:element>.] for more
details on _<jsp:element>_ . Note that in this context, the attribute
does not apply to the _<jsp:element>_ action itself, but rather to the
output of the element. That is, _<jsp:attribute>_ cannot be used to
specify the _name_ attribute of the _<jsp:element>_ action.
* For custom action attributes of type
_javax.servlet.jsp.tagext.JspFragment_ , the container must create a
_JspFragment_ out of the body of the _<jsp:attribute>_ action and pass
it to the tag handler. This applies for both Classic Tag Handlers and
Simple Tag Handlers. A translation error must result if the body of the
_<jsp:attribute>_ action is not scriptless in this case.
* If the custom action accepts dynamic
attributes (link:jsp.html#a2091[See Attributes With Dynamic
Names.]), and the name of the attribute is not one explicitly indicated
for the tag, then the container will evaluate the body of
_<jsp:attribute>_ and assign the computed value to the attribute using
the dynamic attribute machinery. Since the type of the attribute is
unknown and the body of _<jsp:attribute>_ evaluates to a _String_ , the
container must pass in an instance of _String_ .
* For standard or custom action attributes
that accept a request-time expression value, the Container must evaluate
the body of the _<jsp:attribute>_ action and use the result of this
evaluation as the value of the attribute. The body of the attribute
action can be any JSP content in this case. If the type of the attribute
is not _String_ , the standard type conversion rules are applied, as per
link:jsp.html#a1020[See Conversions from String values.].
* For standard or custom action attributes
that do not accept a request-time expression value, the Container must
use the body of the _<jsp:attribute>_ action as the value of the
attribute. A translation error must result if the body of the
_<jsp:attribute>_ action contains anything but template text.

If the body of the _<jsp:attribute>_ action
is empty, it is the equivalent of specifying _“”_ as the value of the
attribute. Note that after being trimmed, non-empty bodies can result in
a value of _““_ as well.

The _<jsp:attribute>_ action accepts a _name_
attribute, a _trim_ attribute, and a omit attribute. The _name_
attribute associates the action with one of the attributes the tag
handler is declared to accept, or in the case of _<jsp:element>_ it
associates the action with one of the attributes in the element being
output. The optional _trim_ attribute determines whether the whitespace
appearning at the beginning and at the end of the element body should be
discarded or not. By default, the leading and trailing whitespace is
discarded. The Container must trim at translation time only. The
Container must not trim at runtime. For example, if a body contains a
custom action that produces leading or trailing whitespace, that
whitespace is preserved regardless of the value of the _trim_ attribute.
The optional omit attribute, when used with <jsp:element>, determines
whether the attribute in the element being output should be omitted.

The following is an example of using the
_<jsp:attribute>_ standard action to define an attribute that is
evaluated by the container prior to the custom action invocation. This
example assumes the name attribute is declared with type
_java.lang.String_ in the TLD.

 <mytag:highlight> +
<jsp:attribute name=”text”> +
Inline definition. +
</jsp:attribute> +
</mytag:highlight>

The following is an example of using the
_<jsp:attribute>_ standard action within _<jsp:element>_ , to define
which attributes are to be output with that element:

 <jsp:element name=”firstname”> +
<jsp:attribute name=”name”>Susan</jsp:attribute> +
</jsp:element>

This would produce the following output:

 <firstname name=”Susan”/>

See link:jsp.html#a388[See JSP
Syntax Grammar.] for the formal syntax definition of the
_<jsp:attribute>_ standard action.

The attributes are:

=== Attributes for the _<jsp:attribute>_ standard action

 _name_

(required) If not being used with
_<jsp:element>_ , then if the action does not accept dynamic attributes,
the name must match the name of an attribute for the action being
invoked, as declared in the Tag Library Descriptor for a custom action,
or as specified for a standard action, or a translation error will
result. Except for when used with _<jsp:element>_ , a translation error
will result if both an XML element attribute and a _<jsp:attribute>_
element are used to specify the value for the same attribute.

The value of name can be a QName. If so, a
translation error must occur if the prefix does not match that of the
action it applies to, unless the action supports dynamic attributes, or
unless the action is _<jsp:element>_ .

When used with _<jsp:element>_ , this
attribute specifies the name of the attribute to be included in the
generated element.

 _trim_

(optional) Valid values are _true_ and
_false_ . If _true_ , the whitespace, including spaces, carriage
returns, line feeds, and tabs, that appears at the beginning and at the
end of the body of the _<jsp:attribute>_ action will be ignored by the
JSP compiler. If _false_ the whitespace is not ignored. Defaults to
_true_ .

 _omit_

(optional) Valid values are _true_ and
_false_ . If _true_ , and when used with <jsp:element>, the attribute in
the element being ouput is omitted. Ignored when used with a standard or
custom action. Defaults to _false_ .

=== [[a1654]]<jsp:body>

Normally, the body of a standard or custom
action invocation is defined implicitly as the body of the XML element
used to represent the invocation. The body of a standard or custom
action can also be defined explicitly using the _<jsp:body>_ standard
action. This is required if one or more _<jsp:attribute>_ elements
appear in the body of the tag.

If one or more _<jsp:attribute>_ elements
appear in the body of a tag invocation but no _<jsp:body>_ element
appears or an empty _<jsp:body>_ element appears, it is the equivalent
of the tag having an empty body.

It is also legal to use the _<jsp:body>_
standard action to supply bodies to standard actions, for any standard
action that accepts a body (except for _<jsp:body>_ , _<jsp:attribute>_
, _<jsp:scriptlet>_ , _<jsp:expression>_ , and _<jsp:declaration>_ ).

The body standard action accepts no
attributes.

=== <jsp:invoke>

The _<jsp:invoke>_ standard action can only
be used in tag files (see link:jsp.html#a2322[See Tag Files.]),
and must result in a translation error if used in a JSP. It takes the
name of an attribute that is a fragment, and invokes the fragment,
sending the output of the result to the _JspWriter_ , or to a scoped
attribute that can be examined and manipulated. If the fragment
identified by the given name is _null_ , _<jsp:invoke>_ will behave as
though a fragment was passed in that produces no output.

=== Basic Usage

The most basic usage of this standard action
will invoke a fragment with the given name with no parameters. The
fragment will be invoked using the _JspFragment.invoke_ method, passing
in null for the _Writer_ parameter so that the results will be sent to
the _JspWriter_ of the _JspContext_ associated with the _JspFragment_ .
The following is an example of such a basic fragment invocation:

<jsp:invoke fragment=”frag1”/>

=== Storing Fragment Output

It is also possible to invoke the fragment
and send the results to a scoped attribute for further examination and
manipulation. This can be accomplished by specifying the _var_ or
_varReader_ attribute in the action. In this usage, the fragment is
invoked using the _JspFragment.invoke_ method, but a custom
_java.io.Writer_ is passed in instead of _null_ .

If _var_ is specified, the container must
ensure that a _java.lang.String_ object is made available in a scoped
attribute with the name specified by _var_ . The _String_ must contain
the content sent by the fragment to the _Writer_ provided in the
_JspFragment.invoke_ call.

If _varReader_ is specified, the container
must ensure that a _java.io.Reader_ object is constructed and is made
available in a scoped attribute with the name specified by _varReader_ .
The _Reader_ object can then be passed to a custom action for further
processing. The _Reader_ object must produce the content sent by the
fragment to the provided _Writer_ . The _Reader_ must also be
resettable. That is, if its _reset_ method is called, the result of the
invoked fragment must be able to be read again without re-executing the
fragment.

An optional _scope_ attribute indicates the
scope of the resulting scoped variable.

The following is an example of using _var_ or
_varReader_ and the _scope_ attribute:

 <jsp:invoke fragment=”frag2”
var=”resultString” scope=”session”/>

 <jsp:invoke fragment=”frag3”
varReader=”resultReader” scope=”page”/>

=== Providing a Fragment Access to Variables

JSP fragments have access to the same page
scope variables as the page or tag file in which they were defined (in
addition to variables in the request, session, and application scopes).
Tag files have access to a local page scope, separate from the page
scope of the calling page. When a tag file invokes a fragment that
appears in the calling page, the JSP container provides a way to
synchronize variables between the local page scope in the tag file and
the page scope of the calling page. For each variable that is to be
synchronized, the tag file author must declare the variable with a scope
of either _AT_BEGIN_ or _NESTED_ . The container must then generate code
to synchronize the page scope values for the variable in the tag file
with the page scope equivalent in the calling page or tag file. The
details of how variables are synchronized can be found in
link:jsp.html#a2542[See Variable Synchronization.].

The following is an example of a tag file
providing a fragment access to a variable:

<%@ variable name-given=”x” scope=”NESTED”
%> +
... +
<c:set var=”x” value=”1”/> +
<jsp:invoke fragment=”frag4”/>

A translation error shall result if the
_<jsp:invoke>_ action contains a non-empty body.

See link:jsp.html#a388[See JSP
Syntax Grammar.] for the formal syntax definition of the _<jsp:invoke>_
standard action.

The attributes are:

=== Attributes for the _<jsp:invoke>_ standard action

 _fragment_

(required) The name used to identify this
fragment during this tag invocation.

 _var_

(optional) The name of a scoped attribute to
store the result of the fragment invocation in, as a _java.lang.String_
object. A translation error must occur if both _var_ and _varReader_ are
specified. If neither _var_ nor _varReader_ are specified, the result of
the fragment goes directly to the _JspWriter_ , as described above.

 _varReader_

(optional) The name of a scoped attribute to
store the result of the fragment invocation in, as a _java.io.Reader_
object. A translation error must occur if both _var_ and _varReader_ are
specified. If neither _var_ nor _varReader_ is specified, the result of
the fragment invocation goes directly to the _JspWriter_ , as described
above.

 _scope_

(optional) The scope in which to store the
resulting variable. A translation error must result if the value is not
one of _page_ , _request_ , _session_ , or _application_ . A translation
error will result if this attribute appears without specifying either
the _var_ or _varReader_ attribute as well. Note that a value of
_session_ should be used with caution since not all calling pages may be
participating in a session. A container must throw an
_IllegalStateException_ at runtime if _scope_ is _session_ and the
calling page does not participate in a session. Defaults to _page_ .

=== <jsp:doBody>

The _<jsp:doBody>_ __ standard action can
only be used in tag files (see link:jsp.html#a2322[See Tag
Files.]), and must result in a translation error if used in a JSP. It
invokes the body of the tag, sending the output of the result to the
_JspWriter_ , or to a scoped attribute that can be examined and
manipulated.

The _<jsp:doBody>_ standard action behaves
exactly like _<jsp:invoke>_ , except that it operates on the body of the
tag instead of on a specific fragment passed as an attribute. Because it
always operates on the body of the tag, there is no _name_ attribute for
this standard action. The _var_ , _varReader_ , and _scope_ attributes
are all supported with the same semantics as for _<jsp:invoke>_ .
Fragments are provided access to variables the same way for
_<jsp:doBody>_ as they are for _<jsp:invoke>_ . If no body was passed to
the tag, _<jsp:doBody>_ will behave as though a body was passed in that
produces no output.

The body of a tag is passed to the simple tag
handler as a _JspFragment_ object.

A translation error shall result if the
_<jsp:doBody>_ action contains a non-empty body.

See link:jsp.html#a388[See JSP
Syntax Grammar.] for the formal syntax definition of the _<jsp:doBody>_
standard action.

The attributes are:

=== Attributes for the _<jsp:doBody>_ standard action

 _var_

(optional) The name of a scoped attribute to
store the result of the body invocation in, as a _java.lang.String_
object. A translation error must occur if both _var_ and _varReader_ are
specified. If neither _var_ nor _varReader_ are specified, the result of
the body goes directly to the _JspWriter_ , as described above.

 _varReader_

(optional) The name of a scoped attribute to
store the result of the body invocation in, as a _java.io.Reader_
object. A translation error must occur if both _var_ and _varReader_ are
specified. If neither _var_ nor _varReader_ is specified, the result of
the body invocation goes directly to the _JspWriter_ , as described
above.

 _scope_

(optional) The scope in which to store the
resulting variable. A translation error must result if the value is not
one of _page_ , _request_ , _session_ , or _application_ . A translation
error will result if this attribute appears without specifying either
the _var_ or _varReader_ attribute as well. Note that a value of
_session_ should be used with caution since not all calling pages may be
participating in a session. A container must throw an
_IllegalStateException_ at runtime if _scope_ is _session_ and the
calling page does not participate in a session. Defaults to _page_ .

=== [[a1702]]<jsp:element>

The _jsp:element_ action is used to
dynamically define the value of the tag of an XML element. This action
can be used in JSP pages, tag files and JSP documents. This action has
an optional body; the body can use the _jsp:attribute and jsp:body
actions._

A _jsp:element_ action has one mandatory
attribute, name, of type _String_ . The value of the attribute is used
as that of the tag of the element generated.

=== Examples

The following example generates an XML
element whose name depends on the result of an EL expression,
content.headerName. The element has an attribute, lang, and the value of
the attribute is that of the expression content.lang. The body of the
element is the value of the expression content.body.

<jsp:element +
name=”$\{content.headerName}” +
xmlns:jsp=” _http://java.sun.com/JSP/Page”_ > +
<jsp:attribute name=”lang”>$\{content.lang}</jsp:attribute> +
<jsp:body>$\{content.body}</jsp:body> +
</jsp:element>

The next example fragment shows that
_jsp:element_ needs no children. The example generates an empty element
with name that of the value of the expression myName.

<jsp:element name=”$\{myName}”/>

=== Syntax

The _jsp:element_ action may have a body. Two
forms are valid, depending on whether the element is to have attributes
or not. In the first form, no attributes are present:

<jsp:element name="name"> +
optional body +
</jsp:element>

In the second form, zero or more attributes
are requested, using _jsp:attribute_ and _jsp:body_ , as appropriate.

<jsp:element name="name"> +
jsp:attribute* +
jsp:body? +
</jsp:element>

The one valid, mandatory, attribute of
_jsp:element_ is its name. Unlike other standard actions, the value of
the _name_ attribute must be given as an XML-style attribute and cannot
be specified using _<jsp:attribute>_ This is because _<jsp:attribute>_
has a special meaning when used in the body of _<jsp:element>_ . See
link:jsp.html#a1626[See <jsp:attribute>.] for more details..

=== Attributes for the _<jsp:element>_ standard action

 _name_

(required) The value of name is that of the
element genreated. The name can be a QName; JSP 2.0 places no
constraints on this value: it is accepted as is. A request-time
attribute value may be used for this attribute.

=== [[a1719]]<jsp:text>

A _jsp:text_ action can be used to enclose
template data in a JSP page, a JSP document, or a tag file. A _jsp:text_
action has no attributes and can appear anywhere that template data can.
Its syntax is:

<jsp:text> template data </jsp:text>

=== The interpretation of a _jsp:text_ element is to pass its content through to the current value of _out_ . This is very similar to the XSLT _xsl:text_ element.Examples

The following example is a fragment that
could be in both a JSP page or a JSP document.

<jsp:text> +
This is some content +
</jsp:text>

Expressions may appear within _jsp:text_ , as
in the next example, where the expression foo.content is evaluated and
the result is inserted.

<jsp:text> +
This is some content: $\{foo.content} +
</jsp:text>

No subelements may appear within _jsp:text_ ;
for example the following fragment is invalid and must generate a
translation error.

<jsp:text> +
This is some content: <jsp:text>foo</jsp:text> +
</jsp:text>

When within a JSP document, of course, the
body content needs to additionally conform to the constraints of being a
well-formed XML document, so the following example, although valid in a
JSP page is invalid in a JSP document:

<jsp:text> +
This is some content: $\{foo.content > 3} +
</jsp:text>

The same example can be made legal, with no
semantic changes, by using gt instead of > in the expression; i.e.
$\{foo.content gt 3}.

In an JSP document, CDATA sections can also
be used to quote, uninterpreted, content, as in the following example:

<jsp:text> +
<![CDATA[<mumble></foobar>]]> +
</jsp:text>

=== Syntax

The _jsp:text_ action has no attributes. The
action may have a body. The body may not have nested actions nor
scripting elements. The body may have EL expressions. The syntax is of
the form:

<jsp:text> +
optional body +
</jsp:text>

=== [[a1737]]<jsp:output>

The _jsp:output_ action can only be used in
JSP documents and in tag files in XML syntax, and a translation error
must result if used in a standard syntax JSP or tag file. This action is
used to modify some properties of the output of a JSP document or a tag
file. In JSP 2.0 there are four properties that can be specified, all of
which affect the output of the XML prolog.

The _omit-xml-declaration_ property allows
the page author to adjust whether an XML declaration is to be inserted
at the beginning of the output. Since XML declarations only make sense
for when the generated content is XML, the default value of this
property is defined so that it is unnecessary in most cases.

The _omit-xml-declaration_ property is of
type _String_ and the valid values are “yes”, “no”, “true” and “false”.
The name, values and semantics mimic that of the _xsl:output_ element in
the XSLT specification: if a value of “yes” or “true” is given, the
container will not add an XML declaration; if a value of “no” or “false”
is given, the container will add an XML declaration.

The default value for a JSP document that has
a _jsp:root_ element is “yes”. The default value for JSP documents
without a _jsp:root_ element is “no”.

The default value for a tag file in XML
syntax is always “yes”. If the value is “false” or “no” the tag file
will emit an XML declaration as its first content.

The generated XML declaration is of the form:

<?xml version=”1.0” encoding=”encodingValue”
?>

Where encodingValue is the response character
encoding, as determined in link:jsp.html#a1384[See Response
Character Encoding.] . +

The _doctype-root-element_ , _doctype-system_
and _doctype-public_ properties allow the page author to specify that a
DOCTYPE be automatically generated in the XML prolog of the output.
Without these properties, the DOCTYPE would need to be output manually
via a _<jsp:text>_ element before the root element of the JSP document,
which is inconvenient.

A DOCTYPE must be automatically output if and
only if the _doctype-system_ element appears in the translation unit as
part of a _<jsp:output>_ action. The _doctype-root-element_ must appear
and must only appear if the _doctype-system_ property appears, or a
translation error must occur. The _doctype-public_ property is optional,
but must not appear unless the _doctype-system_ property appears, or a
translation error must occur.

The DOCTYPE to be automatically output, if
any, is statically determined at translation time. Multiple occurrences
of the _doctype-root-element_ , _doctype-system_ or _doctype-public_
properties will cause a translation error if the values for the
properties differ from the previous occurrence.

The DOCTYPE that is automatically output, if
any, must appear immediately before the first element of the output
document. The name following <!DOCTYPE must be the value of the
_doctype-root-element_ property. If a _doctype-public_ property appears,
then the format of the generated DOCTYPE is:

<!DOCTYPE nameOfRootElement PUBLIC
“doctypePublic” “doctypeSystem”>

If a _doctype-public_ property does not
appear, then the format of the generated DOCTYPE is:

<!DOCTYPE nameOfRootElement SYSTEM
“doctypeSystem”>

Where _nameOfRootElement_ is the value of the
_doctype-root-element_ property, _doctypePublic_ is the value of the
_doctype-public_ attribute, and _doctypeSystem_ is the value of the
_doctype-system_ property.

The values for _doctypePublic_ and
_doctypeSystem_ must be enclosed in either single or double quotes,
depending on the value provided by the page author. It is the
responsibility of the page author to provide a syntactically-valid URI
as per the XML specification (see
_http://www.w3.org/TR/REC-xml#dt-sysid_ ).

=== Examples

The following JSP document (with an extension
of _.jspx_ or with _<is-xml>_ set to _true_ in the JSP configuration):

<?xml version=”1.0” encoding=”EUC-JP” ?> +
<hello></hello>

generates an XML document as follows:

<?xml version=”1.0” encoding=”UTF-8” ?> +
<hello></hello>

The following JSP document is like the
previous one, except that the XML declaration is omited. A typical use
would be where the XML fragment is to be included within another
document.

<?xml version=”1.0” encoding=”EUC-JP” ?> +
<hello> +
<jsp:output +
xmlns:jsp=” _http://java.sun.com/JSP/Page” +
_ omit-xml-declaration=”true”/> +
</hello>

The following JSP document is equivalent but
uses _jsp:root_ instead of _jsp:output_ .

<?xml version=”1.0” encoding=”EUC-JP” ?> +
<jsp:root xmlns:jsp=” _http://java.sun.com/JSP/Page” version=”2.0”_ > +
<hello></hello> +
</jsp:root>

The following JSP document specifies both a
_doctype-public_ and a _doctype-system_ :

<?xml version=”1.0” encoding=”UTF-8” ?> +
<html xmlns:jsp=”http://java.sun.com/JSP/Page”> +
<jsp:output doctype-root-element=”html” +
doctype-public=”-//W3C//DTD XHTML Basic 1.0//EN” +
doctype-system=”http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd” /> +
<body> +
<h1>Example XHTML Document</h1> +
</body> +
</html>

and generates and XML document as follows:

<?xml version=”1.0” encoding=”UTF-8” ?> +
<!DOCTYPE html PUBLIC “-//W3C//DTD XHTML Basic 1.0//EN” +
“http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd”> +
<html><body><h1>Example XHTML Document</h1></body></html>

The following JSP document omits the
_doctype-public_ and explicitly omits the XML declaration:

<?xml version=”1.0” encoding=”UTF-8” ?> +
<elementA> +
<jsp:output omit-xml-declaration=”true” +
doctype-root-element=”elementA” +
doctype-system=”test.dtd” /> +
Element body goes here. +
</elementA>

and generates an XML document as follows:

<!DOCTYPE elementA SYSTEM “test.dtd”> +
<elementA>Element body goes here.</elementA>

=== Syntax

The _jsp:output_ action cannot have a body.
The <jsp:output> action has the following syntax:

 _<jsp:output (
omit-xml-declaration=”yes|no|true|false” ) \{ doctypeDecl } />_

 _doctypeDecl ::= (
doctype-root-element=”rootElement” +
_ doctype-public=”PubidLiteral” +
doctype-system=”SystemLiteral” ) +
| ( doctype-root-element=”rootElement” +
doctype-system=”SystemLiteral” )

The following are the valid attributes of
jsp:output:

=== Attribute for the _<jsp:output>_ standard action

 _omit-xml-declaration_

(optional) Indicates whether to omit the
generation of an XML declaration. Acceptable values are “true”, “yes”,
“false” and “no”.

 _doctype-root-element_

(optional) Must be specified if and only if
_doctype-system_ is specified or a translation error must occur.
Indicates the name that is to be output in the generated DOCTYPE
declaration.

 _doctype-system_

(optional) Specifies that a DOCTYPE
declaration is to be generated and gives the value for the System
Literal.

 _doctype-public_

(optional) Must not be specified unless
_doctype-system_ is specified. Gives the value for the Public ID for the
generated DOCTYPE.

=== Other Standard Actions

link:jsp.html#a1794[See JSP
Documents.] defines several other standard actions that are either
convenient or needed to describe JSP pages with an XML document, some of
which are available in all JSP pages. They are:

*  _<jsp:root>_ , defined in
link:jsp.html#a1870[See The jsp:root Element.].
*  _<jsp:declaration>_ , defined in
link:jsp.html#a1902[See Scripting Elements.].
*  _<jsp:scriptlet>_ , defined in
link:jsp.html#a1902[See Scripting Elements.].
*  _<jsp:expression>_ , defined in
link:jsp.html#a1902[See Scripting Elements.].



== CHAPTER 5 - 

=== [[a1794]]JSP Documents

This chapter introduces two concepts
related to XML and JSP: JSP documents and XML views. This chapter
provides a brief overview of the two concepts and their relationship and
also provides the details of JSP documents. The details of the XML view
of a JSP document are described in link:jsp.html#a2670[See XML
View.].

=== Overview of JSP Documents and of XML Views

A _JSP document_ is a JSP page written using
XML syntax. JSP documents need to be described as such, either
implicitly or explicitly, to the JSP container, which will then process
them as XML documents, checking for well-formedness and applying
requests like entity declarations, if present. JSP documents are used to
generate dynamic content using the standard JSP semantics.

Here is a simple JSP document:

<table> +
<c:forEach +
xmlns:c="http://java.sun.com/jsp/jstl/core" +
var="counter" begin="1" end="3"> +
<row>$\{counter}</row> +
</c:forEach> +
</table>

This well-formed, namespace-aware XML
document generates, using the JSP standard tag library, an XML document
that has _<table>_ as the root element. That element has 3 _<row>_
subelements containing values _1_ , _2_ and _3_ . See
link:jsp.html#a1946[See Examples of JSP Documents.] for more
details of this and other examples.

The design of JSP documents is focused on the
generation of dynamic XML content, in any of its many uses, but JSP
documents can be used to generate any dynamic content.

Some of the syntactic elements described in
link:jsp.html#a204[See Core Syntax and Semantics.] are not
legal XML; this chapter describes alternative syntaxes for those
elements that are aligned with the XML syntax. The alternative syntaxes
can be used in JSP documents; most of them ( _jsp:output_ and _jsp:root_
are exceptions) can also be used in JSP pages in JSP syntax. As it will
be described later, the alternative syntax is also used in the XML view
of JSP pages.

JSP documents can be used in a number of
ways, including:

* JSP documents can be passed directly to the
JSP container; this is becoming more important as more and more content
is authored as XML, be it in an XML-based languages like XHTML or SVG,
or for the exchange of documents in applications like Web Services. The
generated content may be sent directly to a client, or it may be part of
some XML processing pipeline.
* JSP documents can be manipulated by
XML-aware tools.
* A JSP document can be generated from a
textual representation by applying an XML transformation, like XSLT.
* A JSP document can be generated
automatically, say by serializing some objects

Tag files can also be authored using XML
syntax. The rules are very similar to that of JSP documents; see
link:jsp.html#a2492[See Tag Files in XML Syntax.] for more
details.

The _XML view of a JSP page_ is an XML
document that is derived from the JSP page following a mapping defined
later in this chapter. The XML view of a JSP page is intended to be used
for validating the JSP page against some description of the set of valid
pages. Validation of the JSP page is supported in the JSP 2.2
specification through a _TagLibraryValidator_ class associated with a
tag library. The validator class acts on a PageData object that
represents the XML view of the JSP page (see, for example,
link:jsp.html#a2295[See Validator Classes.])

link:jsp.html#a1812[See Relationship
between JSP Pages and XML views of JSP pages..] below depicts the
relationship between the concepts of JSP pages, JSP documents and XML
views. Two phases are involved: the Translation phase, where JSP pages,
in either syntax, are exposed to Tag Library Validators, via their XML
view, and the Request Processing phase, where requests are processed to
produce responses.



image:sp-4.png[image]

=== [[a1812]]Relationship between JSP Pages and XML views of JSP pages.

JSP documents are used by JSP page authors.
They can be authored directly, using a text editor, through an XML
editing tool, or through a JSP page authoring tool that is aware of the
XML syntax. Any JSP page author that is generating XML content should
consider the use of JSP documents. In contrast, the XML view of a JSP
page is a concept internal to the JSP container and is of interest only
to Tag Library Authors and to implementors of JSP containers.

=== JSP Documents

A JSP document is a JSP page that is a
namespace-aware XML document and that is identified as a JSP document to
the JSP container.

=== Identifying JSP Documents

A JSP document can be identified as such in
three ways:

* If there is a _<jsp-property-group>_ that
explicitly indicates, through the _<is-xml>_ element, whether a given
file is a JSP document, then that indication overrides any other
determination. Otherwise,
* If this web application is using a version
2.4 web.xml, and if the extension is . _jspx_ , then the file is a JSP
document. Otherwise,
* If the file is explicitly or implicitly
identified as a JSP page and the top element is a _jsp:root_ element
then the file is identified as a JSP document. This behavior provides
backwards compatibility with JSP 1.2.

It is a translation-time error for a file
that is identified as a JSP document to not be a well-formed,
namespace-aware, XML document.

See link:jsp.html#a2492[See Tag Files
in XML Syntax.] for details on identifying tag files in XML syntax.

=== [[a1823]]Overview of Syntax of JSP Documents

A JSP document may or not have a _<jsp:root>_
as its top element; _<jsp:root>_ was mandatory in JSP 1.2, but we expect
most JSP documents in JSP 2.0 not to use it.

JSP documents identify standard actions
through the use of a well-defined URI in its namespace; although in this
chapter the prefix _jsp_ is used for the standard actions, any prefix is
valid as long as the correct URI identifying JSP 2.0 standard actions is
used. Custom actions are identified using the URI that identifies their
tag library; _taglib_ directives are not required and cannot appear in a
JSP document.

A JSP document can use XML elements as
template data; these elements may have qualified names (and thus be in a
namespace), or be unqualified.

The _<jsp:text>_ element can be used to
define some template data verbatim.

Since a JSP document must be a valid XML
document, there are some JSP elements that can’t be used in a JSP
document. The elements that can be used are:

* JSP directives and scripting elements in
XML syntax.
* EL expressions in the body of elements and
in attribute values.
* All JSP standard actions described in
Chapter JSP.1.
* The jsp:root, jsp:text, and jsp:output
elements.
* Custom action elements
* Template data described using _jsp:text_
elements.
* Template data described through XML
fragments.

Scriptlet expressions used to specify
request-time attribute values use a slightly different syntax in JSP
documents than in non JSP documents; rather than using _<%= expr %>_ ,
they use _%= expr %_ . The white space around _expr_ is not needed, and
note the missing _<_ and _>_ . The _expr_ , after any applicable quoting
as in any other XML document, is an expression to be evaluated as in
link:jsp.html#a1004[See Request Time Attribute Values.].

The mechanisms that enable scripting and EL
evaluation in a JSP page apply also when the page is a JSP document.
Just as in the standard syntax, the _$_ in an EL expression can be
quoted using _\$_ in both attribute values and template text. Recall,
however, that _\\_ is not an escape sequence in XML attributes so
whereas within an attribute in standard syntax _\\$\{1+1}_ would result
in _\2_ (assuming EL is enabled) or _\$\{1+1}_ (assuming EL is ignored),
in XML syntax _\\$\{1+1}_ always results in _\$\{1+1}_ .

It should be noted that the equivalent JSP
document form of +
_<a href="<%= url %>">_ , where ’a’ is not a custom action, is:

<jsp:text><![CDATA[<a
href="]]></jsp:text><jsp:expression>url</jsp:expression><jsp:text><![CDATA[">]]></jsp:text>

In the JSP document element _<a href="%= url
%">_ , _"%= url %"_ does not represent a request-time attribute value.
That syntax only applies for custom action elements. This is in contrast
to _<a href="$\{url}">_ , where " _$\{url}_ " represents an EL
expression in both JSP pages and JSP documents.

=== [[a1841]]Semantic Model

The semantic model of a JSP document is
unchanged from that of a JSP page in JSP syntax: JSP pages generate a
response stream of characters from template data and dynamic elements.
Template data can be described explicitly through a _jsp:text_ element,
or implicitly through an XML fragment. Dynamic elements are EL
expressions, scripting elements, standard actions or custom actions.
Scripting elements are represented as XML elements with the exception of
request-time attribute expressions, which are represented through
special attribute syntax.

The first step in processing a JSP document
is to process it as an XML document, checking for well-formedness,
processing entity resolution and, if applicable, performing validation
as described in link:jsp.html#a1849[See JSP Document
Validation.]. As part of the processing XML quoting will be performed,
and JSP quoting will not be performed later.

After these steps, the JSP document will be
passed to the JSP container which will then interpret it as a JSP page.

The JSP processing step for a JSP document is
as for any other JSP page except that namespaces are used to identify
standard actions and custom action tag libraries and that run time
expressions in attributes use the slightly different syntax. Note that
all the JSP elements that are described in this chapter are valid in all
JSP pages, be they identified as JSP documents or not. This is a
backward compatible change from the behavior in JSP 1.2 to enable
gradual introduction of XML syntax in existing JSP pages.

To clearly explain the processing of
whitespace, we follow the structure of the XSLT specification. The first
step in processing a JSP document is to identify the nodes of the
document. Then, all textual nodes that have only white space are dropped
from the document; the only exception are nodes in a _jsp:text_ element,
which are kept verbatim. The resulting nodes are interpreted as
described in the following sections. Template data is either passed
directly to the response or it is mediated through (standard or custom)
actions.

Following the XML specification (and the XSLT
specification), whitespace characters are _#x20_ , _#x9_ , _#xD_ , or
_#xA_ .

The container will add, in some conditions,
an XML declaration to the output; the rules for this depend on the use
of jsp:root and jsp:output; see link:jsp.html#a1888[See The
jsp:output Element.].

=== [[a1849]]JSP Document Validation

A JSP Document with a DOCTYPE declaration
must be validated by the container in the translation phase. Validation
errors must be handled the same way as any other translation phase
errors, as described in link:jsp.html#a607[See Translation Time
Processing Errors.].

JSP 2.0 requires only DTD validation for JSP
Documents; containers should not perform validation based on other types
of schemas, such as XML schema.

If an author wishes to have the JSP Document
framed by the root element of a vocabulary outside the
http://java.sun.com/JSP/Page namespace, and they wish to be able to
validate the JSP Document according to a DTD, then they should be aware
that the DTD must make explicit provision for elements from the JSP
namespace, and the namespace prefix to which they are bound.



For example, the following XML document:

<?xml version="1.0"?> +
<!DOCTYPE root PUBLIC "-//My Org//My DTD//EN" +
"http://www.my.org/dtd/my.dtd"> +
<root xmlns:jsp="http://java.sun.com/JSP/Page"/>

can only be validated against its DTD if the
DTD makes special

provision for both the attribute "xmlns:jsp"
on the root element, and

also for elements with a "jsp" namespace
prefix. Even if the DTD

provides for this, you must bind the
namespace to the prefix that the

DTD has chosen.

=== Syntactic Elements in JSP Documents

This section describes the elements in a JSP
document.

=== Namespaces, Standard Actions, and Tag Libraries

JSP documents and tag files in XML syntax use
XML namespaces to identify the standard actions, the directives, and the
custom actions. JSP pages and tags in the JSP syntax cannot use XML
namespaces and instead must use the taglib directive.

Though the prefix " _jsp_ " is used
throughout this specification, it is the namespace
_http://java.sun.com/JSP/Page_ and not the prefix " _jsp_ " that
identifies the JSP standard actions.

An _xmlns_ attribute for a custom tag library
of the form _xml:prefix=’uri’_ identifies the tag library through the
_uri_ value. The _uri_ value may be of one of three forms, either a URN
of the form urn:jsptagdir:tagdir, a URN of the form _urn:jsptld:_ _path_
, or a plain URI.

If the _uri_ value is a URN of the form
_urn:jsptld:_ _path_ , then the TLD is determined following the
mechanism described in link:jsp.html#a2142[See TLD resource
path.].

If the _uri_ value is a URN of the form
_urn:jsptagdir:_ _tagdir_ , then the TLD is determined following the
mechanism described in link:jsp.html#a2346[See Packaging Tag
Files.].

If the _uri_ value is a plain URI, then a
path is determined by consulting the mapping indicated in _web.xml_
extended using the implicit maps in the packaged tag libraries (Sections
link:jsp.html#a2153[See Taglib Map in web.xml.] and
link:jsp.html#a2155[See Implicit Map Entries from TLDs.]), as
indicated in link:jsp.html#a2165[See Determining the TLD
Resource Path.]. In contrast to link:jsp.html#a2172[See
Computing the TLD Resource Path.], however, a translation error must not
be generated if the given _uri_ is not found in the taglib map. Instead,
any actions in the namespace defined by the uri value must be treated as
uninterpreted.

=== [[a1870]]The jsp:root Element

The _jsp:root_ element can only appear as the
root element in a JSP document or in a tag file in XMLsyntax; otherwise
a translation error shall occur. JSP documents and tag files in XML
syntax need not have a _jsp:root_ element as its root element.

The _jsp:root_ element has two main uses. One
is to indicate that the JSP file is in XML syntax, without having to use
configuration group elements nor using the .jspx extension. The other
use of the jsp:root element is to accomodate the generation of content
that is not a single XML document: either a sequence of XML documents or
some non-XML content.

A jsp:root element can be used to provide
zero or more _xmlns_ attributes that correspond to namespaces for the
standard actions, for custom actions or for generated template text.
Unlike in JSP 1.2, not all tag libraries used within the JSP document
need to be introduced on the root; tag libraries can be incorporated as
needed inside the document using additional _xmlns_ attributes.

The jsp:root element has one mandatory
element, the version of the JSP spec that the page is using.

When _jsp:root_ is used, the container will,
by default, not insert an XML declaration; the default can be changed
using the _jsp:output_ element.

=== Examples

The following example generates a sequence of
two XML documents. No XML declaration is generated.

<jsp:root xmlns:jsp=”
_http://java.sun.com/JSP/Page”_ version=”2.0"> +
<table>foo</table> +
<table>bar</table> +
</jsp:root>

The following example generates one XML
document. An XML declaration is generated because of the use of
_jsp:output_ . The example is mostly instructional, as the same content
could be generated dropping the _jsp:root_ element.

<jsp:root xmlns:jsp=”
_http://java.sun.com/JSP/Page”_ version=”2.0"> +
<jsp:output omit-xml-declaration="no"/> +
<table>foo</table> +
</jsp:root>

=== Syntax

No other attributes are defined in this
element.

<jsp:root
xmlns:jsp="http://java.sun.com/JSP/Page" body... +
</jsp:root>

The one valid, mandatory, attribute of
jsp:root is the version of the JSP specification used:

=== Attributes for the _<jsp:root>_ standard action

 _version_

(required) The version of the JSP
specification used in this page. Valid values are "1.2", "2.0", and
"2.1". It is a translation error if the container does not support the
specified version.

=== [[a1888]]The jsp:output Element

The jsp:output element can be used in JSP
documents and in tag files in XML syntax. The jsp:output element is
described in detail in link:jsp.html#a1737[See <jsp:output>.].

=== The jsp:directive.page Element

The _jsp:directive.page_ element defines a
number of page dependent properties and communicates these to the JSP
container. This element must be a child of the root element. Its syntax
is:

<jsp:directive.page page_directive_attr_list
/>

Where _page_directive_attr_list_ is as
described in link:jsp.html#a770[See The page Directive.].

The interpretation of a _jsp:directive.page_
element is as described in link:jsp.html#a770[See The page
Directive.], and its scope is the JSP document and any fragments
included through an include directive.

=== The jsp:directive.include Element

The _jsp:directive.include_ element is used to
substitute text and/or code at JSP page translation-time. This element
can appear anywhere within a JSP document. Its syntax is:

<jsp:directive.include file="relativeURLspec”
/>

The interpretation of a
_jsp:directive.include_ element is as in link:jsp.html#a894[See
The include Directive.].

The XML view of a JSP page does not contain
_jsp:directive.include_ elements, rather the included file is expanded
in-place. This is done to simplify validation.

=== Additional Directive Elements in Tag Files

link:jsp.html#a2322[See Tag Files.]
describes the tag, attribute and variable directives, which can be used
in tag files. The XML syntax for these directives is the same as in the
XML view (see link:jsp.html#a2819[See The tag Directive.],
link:jsp.html#a2825[See The attribute Directive.], and
link:jsp.html#a2830[See The variable Directive.] for details).

=== [[a1902]]Scripting Elements

The usual scripting elements: declarations,
scriptlets and expressions, can be used in JSP documents, but the only
valid forms for these elements in a JSP document are the XML syntaxes;
i.e. those using the elements _jsp:declaration_ , _jsp:scriptlet_ and
_jsp:expression_ .

The _jsp:declaration_ element is used to
declare scripting language constructs that are available to all other
scripting elements. A _jsp:declaration_ element has no attributes and
its body is the declaration itself. The interpretation of a
_jsp:declaration_ element is as in link:jsp.html#a959[See
Declarations.]. Its syntax is:

<jsp:declaration> declaration goes here
</jsp:declaration>

The _jsp:scriptlet_ element is used to
describe actions to be performed in response to some request. Scriptlets
are program fragments. A _jsp:scriptlet_ element has no attributes and
its body is the program fragment that comprises the scriptlet. The
interpretation of a _jsp:scriptlet_ element is as in
link:jsp.html#a971[See Scriptlets.]. Its syntax is:

<jsp:scriptlet> code fragment goes here
</jsp:scriptlet>

The _jsp:expression_ element is used to
describe complete expressions in the scripting language that get
evaluated at response time. A _jsp:expression_ element has no attributes
and its body is the expression. The interpretation of a _jsp:expression_
element is as in link:jsp.html#a984[See Expressions.]. Its
syntax is:

 _<jsp:expression> expression goes here
</jsp:expression>_

=== Other Standard Actions

The standard actions of
link:jsp.html#a1403[See Standard Actions.] use a syntax that is
consistent with XML syntax and they can be used in JSP documents and in
tag files in XML syntax.

=== Template Content

A JSP page has no structure on its template
content, and, correspondingly, imposes no constraints on that content.
On the other hand, JSP documents have structure and some constraints are
needed.

JSP documents can generate unconstrained
content using jsp:text, as defined in link:jsp.html#a1719[See
<jsp:text>.]. Jsp:text can be used to generate totally fixed content but
it can also be used to generate some dynamic content, as described in
link:jsp.html#a1940[See Dynamic Template Content.] below.

Fixed structured content can be generated
using XML fragments. A template XML element, an element that represents
neither a standard action nor a custom action, can appear anywhere where
a _jsp:text_ may appear in a JSP document. The interpretation of such an
XML element is to pass its textual representation to the current value
of _out_ , after the whitespace processing described in
link:jsp.html#a1841[See Semantic Model.].

For example, if the variable i has the value
3, and the JSP document is of the form. :

=== Example 1 - Input

LineNo

Source Text

=== 1

<hello>

=== 2

 <hi>

=== 3

 <jsp:text> hi you all

=== 4

 </jsp:text>$\{i}

=== 5

 </hi>

=== 6

</hello>

The result is:

=== Example 1 - Output

LineNo

Output Text

=== 1

<hello><hi> hi you all

=== 2

 3</hi></hello>

=== [[a1940]]Dynamic Template Content

Custom actions can be used to generate any
content, both structured and unstructured. Future versions of the JSP
specification may allow for custom actions to check constraints on the
generated content (see link:jsp.html#a1984[See Generating XML
Content Natively.]) but the current specification has no standards
support for any such constraints.

The most flexible standard mechanism for
dynamic content is _jsp:element_ . _jsp:element_ , together with
_jsp:attribute_ and _jsp:body_ can be used to generate any element.
Further details of jsp:element, jsp:attribute and jsp:body are given in
link:jsp.html#a1702[See <jsp:element>.], in
link:jsp.html#a1626[See <jsp:attribute>.] and in
link:jsp.html#a1654[See <jsp:body>.]. The following example is
from that section

<jsp:element +
name=”$\{content.headerName}” +
xmlns:jsp=” _http://java.sun.com/JSP/Page”_ > +
<jsp:attribute name=”lang”>$\{content.lang}</jsp:attribute> +
<jsp:body>$\{content.body}</jsp:body> +
</jsp:element>

In some cases, the dynamic content that is
generated can be described as simple substitutions on otherwise static
templates. JSP documents can have XML templates where EL expressions are
used as the values of the body or of attributes. For instance, the next
example uses the expression table.indent as the value of an attribute,
and the expression table.value as that for the body of an element:

<table indent="$\{table.indent}"> +
<row>$\{table.value}</row> +
</table>

=== [[a1946]]Examples of JSP Documents

The following sections provide several
annotated examples of JSP documents.

=== Example: A simple JSP document

This simple JSP document generates a table
with 3 rows with numeric values 1, 2, 3. The JSP document uses template
XML elements intermixed with actions from the JSP Standard Tag Library.

<table size="$\{3}"> +
<c:forEach +
xmlns:c="http://java.sun.com/jsp/jstl/core" +
var="counter" begin="1" end="$\{3}"> +
<row>$\{counter}</row> +
</c:forEach> +
</table>

Some comments:

* The XML template elements are <table> and
<row>. The custom action element is <c:forEach>
* The JSP standard tag library is introduced
through the use of its URI namespace and the specific prefix used, c in
this case, is irrelevant. The prefix is introduced in a non-root
element, and the top element of the document is still <table>.
* The expression $\{counter} is used within
the <row> template element.
* The expression $\{3} (3 would have been
equally good, but an expression is used for expository reasons) is used
within the value of an attribute in both the XML template element
<table> and in the custom action element <c:forEach>.
* The JSP document does not have an xml
declaration - we are assuming the encoding of the file did not require
it, e.g. it used UTF-8, - but the output will include an xml declaration
due to the defaulting rules and to the absence of jsp:output element
directing the container to do otherwise.

The JSP document above does not generate an
XML document that uses namespaces, but the next example does.

=== Example: Generating Namespace-aware documents

<table +
xmlns="http://table.com/Table1" +
size="$\{3}"> +
<c:forEach +
xmlns:c="http://java.sun.com/jsp/jstl/core" +
var="counter" begin="1" end="$\{3}"> +
<row>$\{counter}</row> +
</c:forEach> +
</table>

This example is essentially the same as the
one above, except that a default namespace is introduced in the top
element The namespace applies to the unqualified elements: <table> and
<row>. Also note that if the default namespace were to correspond to a
custom action, then the elements so effected would be interpreted as
invocations on custom actions or tags.

Although the JSP container understands that
this document is a namespace-aware document. the JSP 2.0 container does
not really understand that the generated content is a well-formed XML
document and, as the next example shows, a JSP document can generate
other types of content.

=== Example: Generating non-XML documents

<jsp:root +
xmlns:c="http://java.sun.com/jsp/jstl/core" +
xmlns:jsp="http://java.sun.com/JSP/Page" +
version="2.0"> +
<c:forEach +
var="counter" begin="1" end="$\{3}"> +
<jsp:text>$\{counter}</jsp:text> +
</c:forEach> +
</jsp:root>

This example just generates 123. There is no
xml declaration generated because there is no <jsp:output> element to
modify the default rule for when a JSP document has <jsp:root>. No
additional whitespace is introduced because there is none within the
<jsp:text> element.

The previous example used elements in the JSP
namespace. That example used the jsp prefix, but, unlike with JSP pages
in JSP syntax, the name of the prefix is irrelevant (although highly
convenient) in JSP documents: the JSP URI is the only important
indicative and the corrent URI should be used, and introduced via a
namespace attribute.

For example, the same output would be
generated with the following modification of the previous example:

<wombat:root +
xmlns:c="http://java.sun.com/jsp/jstl/core" +
xmlns:wombat="http://java.sun.com/JSP/Page" +
version="2.0"> +
<c:forEach +
var="counter" begin="1" end="$\{3}"> +
<wombat:text>$\{counter}</wombat:text> +
</c:forEach> +
</wombat:root>

On the other hand, although the following
example uses the jsp prefix the URI used in the namespace attribute is
not the JSP URI and the JSP document will generate as output an XML
document with root <jsp:root> using the URI
"http://johnsonshippingproducts.com".

<jsp:root +
xmlns:c="http://java.sun.com/jsp/jstl/core" +
xmlns:jsp="http://johnsonshippingproducts.com" +
version="2.0"> +
<c:forEach +
var="counter" begin="1" end="$\{3}"> +
<jsp:text>$\{counter}</jsp:text> +
</c:forEach> +
</jsp:root>

Finally, note that, since a JSP document is a
well-formed, namespace-aware document, prefixes, including jsp cannot be
used without being introduced through a namespace attribute.

=== [[a1971]]Example: Using Custom Actions and Tag Files

Custom actions are frequently used within a
JSP document to generate portions of XML content. The JSP specification
treats this content as plain text, with no intepretation nor constraints
imposed on it. Good practice, though, suggests abstractions that
organize the content along well-formed fragments.

The following example generates an XHTML
document using tag library abstractions for presentation and data
access, made available through the prefixes u and data respectively.

<html xmlns="http://www.w3.org/1999/xhtml" +
xmlns:jsp="http://java.sun.com/JSP/Page" +
xmlns:c="http://java.sun.com/jsp/jstl/core" +
xmlns:u="urn:jsptagdir:/WEB-INF/tags/mylib/" +
xmlns:data="http://acme.com/functions"> +
<c:set var="title" value="Best Movies" /> +
<u:headInfo title="$\{title}"/> +
<body> +
<h1>$\{title}</h1> +
<h2>List of Best Movies</h2> +
<ul> +
<c:forEach var="m" varStatus="s" items="data:movieItems()"> +
<li><a href="#EL$\{s.index}">$\{s.index}</a>$\{m.title}</li> +
</c:forEach> +
</ul> +
</body> +
</html>

For convenience we use the <c:set> JSTL
action, which defines variables and associates values with them. This
allows grouping in a single place of definitions used elsewhere.

Notice that if the above example included a
DOCTYPE declaration for XHTML documents, it would not validate according
to the DTD for XHTML documents, because that DTD does not list any of
the namespaces declared on the <html> root element as valid attributes
on the <html> element type.

However, to output a DOCTYPE, the
<jsp:output> standard action specified in JSP.5.16 could be used. +

The action <u:headInfo> could be implemented
either through a custom action or through a tag. For example, as a tag
it could be defined by the following code:

 _<jsp:root
xmlns:jsp="http://java.sun.com/JSP/Page" version="2.0"> +
_ <jsp:directive.tag /> +
<jsp:directive.attribute name=”title” required="true" /> +
_<head> +
<meta http-equiv="content-type" +
content="text/html;charset=$\{pageCharSet}" /> +
<title>$\{title}</title> +
</head> +
</jsp:root>_

 _where pageCharSet is a variable with a
value as iso-8859-1._

Note that this tag is a JSP document (because
of the jsp:root declaration), and, as such, it is validated by the
container. Also note that the content that is generated in this case is
not using QNames, which means that the interpretation of the generated
elements can be ’captured’ based on the invocation context. That is the
case here, as there is a default namespace active (that of XHTML) where
the tag is being invoked.

=== Possible Future Directions for JSP documents

This section is non-normative. Two features
are sketched briefly here to elicit input that could be used on future
versions of the JSP specification.

=== [[a1984]]Generating XML Content Natively

All JSP 2.0 content is textual, even when
using JSP documents to generate XML content. This is quite acceptable,
and even ideal, for some applications, but in some other applications
XML documents are the main data type being manipulated. For example, the
data source may be an XML document repository, perhaps queried using
XQuery, some of the manipulation on this data internal to the JSP page
will use XML concepts (XPath, XSTL operations), and the generated XML
document may be part of some XML pipeline.

In one such application, it is appealing not
to transform back and forth between a stream of characters (text) and a
parsed representation of the XML document. The JSP expert group has
explored different approaches on how such XML-awareness could be added,
and a future version of JSP could support this functionality.

=== Schema and XInclude Support

The current specification only requires DTD
validation support for JSP documents. A more flexible schema language,
like XML Schema, could be useful and could be explored by a future
version of the JSP specification.

Similarly, future versions of the
specification may also consider support for XInclude.

== CHAPTER 6 - 

=== [[a1991]]Tag Extensions

This chapter describes the tag library
facility for introducing new actions into a JSP page. The tag library
facility includes portable run-time support, a validation mechanism, and
authoring tool support. Both the classic JSP 1.2 style tag extension
mechanism and the newer JSP 2.0 simple tag extension mechanism are
described. In link:jsp.html#a2322[See Tag Files.], a mechanism
for authoring tag extensions using only JSP syntax is described. This
brings the power of tag extensions to page authors that may not know the
Java programming language.

This chapter also provides an overview of the
tag library concept. It describes the Tag Library Descriptor, and the
_taglib_ directive. A detailed description of the APIs involved follows
in link:javax.servlet.jsp.tagext.html#UNKNOWN[].

=== Introduction

A Tag Library abstracts functionality used by
a JSP page by defining a specialized (sub)language that enables a more
natural use of that functionality within JSP pages.

The actions introduced by the Tag Library can
be used by the JSP page author in JSP pages explicitly, when authoring
the page manually, or implicitly, when using an authoring tool. Tag
Libraries are particularly useful to authoring tools because they make
intent explicit and the parameters expressed in the action instance
provide information to the tool.

Actions that are delivered as tag libraries
are imported into a JSP page using the _taglib_ directive. They are
available for use in the page using the prefix given by the directive.
An action can create new objects that can be passed to other actions, or
can be manipulated programmatically through a scripting element in the
JSP page.

The semantics of a specific custom action in
a tag library is described via a tag handler class which is usually
instantiated at runtime by the JSP page implementation class. When the
tag library is well known to the JSP container
(link:jsp.html#a2195[See Well-Known URIs.]), the Container can
use alternative implementations as long as the semantics are preserved.

Tag libraries are portable: they can be used
in any legal JSP page regardless of the scripting language used in that
page.

The tag extension mechanism includes
information to:

* Execute a JSP page that uses the tag
library.
* Author or modify a JSP page.
* Validate the JSP page.
* Present the JSP page to the end user.

A Tag Library is described via the Tag
Library Descriptor ( TLD), an XML document that is described below.

=== [[a2006]]Goals

The tag extension mechanism described in this
chapter addresses the following goals. It is designed to be:

*  _Portable_ - An action described in a tag
library must be usable in any JSP container.
*  _Simple_ - Unsophisticated users must be
able to understand and use this mechanism. Vendors of JSP functionality
must find it easy to make it available to users as actions.
*  _Expressive_ - The mechanism must support
a wide range of actions, including nested actions, scripting elements
inside action bodies, and creation, use, and updating of scripting
variables.
*  _Usable from different scripting
languages_ - Although the JSP specification currently only defines the
semantics for scripts in the Java programming language, we want to leave
open the possibility of other scripting languages.
*  _Built upon existing concepts and
machinery_ - We do not want to reinvent what exists elsewhere. Also, we
want to avoid future conflicts whenever we can predict them.

=== [[a2013]]Overview

The processing of a JSP page conceptually
follows these steps:

=== Parsing

JSP pages can be authored using two different
syntaxes: a JSP syntax and an XML syntax. The semantics and validation
of a JSP syntax page is described with reference to the semantics and
validation of an equivalent document in the XML syntax.

The first step is to parse the JSP page. The
page that is parsed is as expanded by the processing of include
directives. Information in the TLD is used in this step, including the
identification of custom tags, so there is some processing of the taglib
directives in the JSP page.

=== Validation

The tag libraries in the XML document are
processed in the order in which they appear in the page.

Each library is checked for a validator
class. If one is present, the whole document is made available to its
_validate_ method as a _PageData_ object. As of JSP 2.0, the Container
must provide a _jsp:id_ attribute. This information can be used to
provide location information on errors.

Each custom tag in the library is checked for
a _TagExtraInfo_ class. If one is present, its _validate_ method is
invoked. The default implementation of _validate_ is to call _isValid_ .
See the APIs for more details.

=== Translation

Finally, the XML document is processed to
create a JSP page implementation class. This process may involve
creating scripting variables. Each custom action will provide
information about variables, either statically in the TLD, or more
flexibly by using the _getVariableInfo_ method of a _TagExtraInfo_
class.

=== Execution

Once a JSP page implementation class has been
associated with a JSP page, the class will be treated as any other
servlet class: Requests will be directed to instances of the class. At
run-time, tag handler instances will be created and methods will be
invoked in them.

=== Classic Tag Handlers

A classic tag handler is a Java class that
implements the _Tag_ , _IterationTag_ , or _BodyTag_ interface, and is
the run-time representation of a custom action.

The JSP page implementation class
instantiates a tag handler object, or reuses an existing tag handler
object, for each action in the JSP page. The handler object is a Java
object that implements the _javax.servlet.jsp.tagext.Tag_ interface. The
handler object is responsible for the interaction between the JSP page
and additional server-side objects.

There are three main interfaces: _Tag_ ,
_IterationTag_ , and _BodyTag_ .

* The __ _Tag_ interface defines the basic
methods needed in all tag handlers. These methods include setter methods
to initialize a tag handler with context data and attribute values of
the action, and the _doStartTag_ and _doEndTag_ __ methods.
* The __ _IterationTag_ _interface_ is an
extension to _Tag_ that provides the additional method, _doAfterBody_ ,
invoked for the reevaluation of the body of the tag.
* The __ _BodyTag_ interface is an extension
of _IterationTag_ with two new methods for when the tag handler wants to
manipulate the tag body: _setBodyContent_ passes a buffer, the
_BodyContent_ __ object, and _doInitBody_ provides an opportunity to
process the buffer before the first evaluation of the body into the
buffer.

The use of interfaces simplifies making an
existing Java object a tag handler. There are also two support classes
that can be used as base classes: _TagSupport_ and _BodyTagSupport_ .

JSP 1.2 introduced a new interface designed
to help maintain data integrity and resource management in the presence
of exceptions. The _TryCatchFinally_ interface is a “mix-in” interface
that can be added to a class implementing any of _Tag_ , _IterationTag_
, or _BodyTag_ .

=== [[a2035]]Simple Examples of Classic Tag Handlers

As examples, we describe prototypical uses of
tag extensions, briefly sketching how they take advantage of these
mechanisms.

=== Plain Actions

The simplest type of action just does
something, perhaps with parameters to modify what the “something” is,
and improve reusability.

This type of action can be implemented with a
tag handler that implements the _Tag_ interface. The tag handler needs
to use only the _doStartTag_ method which is invoked when the start tag
is encountered. It can access the attributes of the tag and information
about the state of the JSP page. The information is passed to the _Tag_
object through setter method calls, prior to the call to _doStartTag_ .

Since simple actions with empty tag bodies
are common, the Tag Library Descriptor can be used to indicate that the
tag is always intended to be empty. This indication leads to better
error checking at translation time, and to better code quality in the
JSP page implementation class.

=== Actions with a Body

Another set of simple actions require
something to happen when the start tag is found, and when the end tag is
found. The _Tag_ interface can also be used for these actions. The
_doEndTag_ is similar to the _doStartTag_ method except that it is
invoked when the end tag of the action is encountered. The result of the
_doEndTag_ invocation indicates whether the remainder of the page is to
be evaluated or not.

=== Conditionals

In some cases, a body needs to be invoked
only when some (possibly complex) condition happens. Again, this type of
action is supported by the basic _Tag_ interface through the use of
return values in the _doStartTag_ method.

=== Iterations

For iteration the _IterationTag_ interface is
needed. The _doAfterBody_ method is invoked to determine whether to
reevaluate the body or not.

=== Actions that Process their Body

Consider an action that evaluates its body
many times, creating a stream of response data. The _IterationTag_
protocol is used for this.

If the result of the reinterpretation is to
be further manipulated for whatever reason, including just discarding
it, we need a way to divert the output of reevaluations. This is done
through the creation of a _BodyContent_ object and use of the
_setBodyContent_ method, which is part of the _BodyTag_ interface.
_BodyTag_ also provides the _doInitBody_ __ method which is invoked
after _setBodyContent_ and before the first body evaluation provides an
opportunity to interact with the body.

=== Cooperating Actions

Cooperating actions may offer the best way to
describe a desired functionality. For example, one action may be used to
describe information leading to the creation of a server-side object,
while another action may use that object elsewhere in the page. These
actions may cooperate explicitly, via scoped variables: one action
creates an object and gives it a name; the other refers to the object
through the name.

Two actions can also cooperate implicitly. A
flexible and convenient mechanism for action cooperation uses the nested
structure of the actions to describe scoping. This is supported in the
specification by providing each tag handler with its parent tag handler
(if any) through the _setParent_ method. The _findAncestorWithClass_
static method in _TagSupport_ can then be used to locate a tag handler,
and, once located, to perform valid operations on the tag handler.

=== [[a2053]]Actions Defining Scripting Variables

A custom action may create server-side
objects and make them available to scripting elements by creating or
updating the scripting variables. The variables thus affected are part
of the semantics of the custom action and are the responsibility of the
tag library author.

This information is used at JSP page
translation time and can be described in one of two ways: directly in
the TLD for simple cases, or through subclasses of _TagExtraInfo_ .
Either mechanism will indicate the names and types of the scripting
variables.

At request time the tag handler will
associate objects with the scripting variables through the _pageContext_
object.

It is the responsibility of the JSP page
translator to automatically supply the code required to do the
“synchronization” between the _pageContext_ values and the scripting
variables.

There are some sections of JSP where
scripting is not allowed. For example, this is the case in a tag body
where the _body-content_ is declared as ‘ _scriptless_ ’, or in a page
where _<scripting-invalid>_ is true. In these sections, it is not
possible to access scripting variables directly via scriptlets or
expressions, and therefore the container need not synchronize them.
Instead, the page author can use the EL to access the _pageContext_
values.

=== [[a2059]]Simple Tag Handlers

The API and invocation protocol for classic
tag handlers is necessarily somewhat complex because scriptlets and
scriptlet expressions in tag bodies can rely on surrounding context
defined using scriptlets in the enclosing page.

With the advent of the Expression Language
(EL) and JSP Standard Tag Library (JSTL), it is now feasible to develop
JSP pages that do not need scriptlets or scriptlet expressions. This
allows us to define a tag invocation protocol that is easier to use for
many use cases.

In that interest, JSP 2.0 introduces a new
type of tag extension called a Simple Tag Extension. Simple Tag
Extensions can be written in one of two ways:

* In Java, by defining a class that
implements the _javax.servlet.jsp.tagext.SimpleTag_ interface. This
class is intended for use by advanced page authors and tag library
developers who need the flexibility of the Java language in order to
write their tag handlers. The
_javax.servlet.jsp.tagext.SimpleTagSupport_ class provides a default
implementation for all methods in _SimpleTag_ .
* In JSP, using tag files. This method can be
used by page authors who do not know Java. It can also be used by
advanced page authors or tag library developers who know Java but are
producing tag libraries that are presentation-centric or can take
advantage of existing tag libraries. See link:jsp.html#a2322[See
Tag Files.] for more details.

The lifecycle of a Simple Tag Handler is
straightforward and is not complicated by caching semantics. Once a
Simple Tag Handler is instantiated by the Container, it is executed and
then discarded. The same instance must not be cached and reused. Initial
performance metrics show that caching a tag handler instance does not
necessarily lead to greater performance, and to accommodate such caching
makes writing portable tag handlers difficult and makes the tag handler
prone to error.

In addition to being simpler to work with,
Simple Tag Extensions do not directly rely on any servlet APIs, which
allows for potential future integration with other technologies. This is
facilitated by the _JspContext_ class, which _PageContext_ now extends.
_JspContext_ provides generic services such as storing the _JspWriter_
and keeping track of scoped attributes, whereas _PageContext_ has
functionality specific to serving JSPs in the context of servlets.
Whereas the _Tag_ interface relies on _PageContext_ , _SimpleTag_ only
relies on _JspContext_ .

The body of a Simple Tag, if present, is
translated into a JSP Fragment and passed to the _setJspBody_ method.
The tag can then execute the fragment as many times as needed. See
link:jsp.html#a2069[See JSP Fragments.] for more details on JSP
Fragments.

Because JSP Fragments do not support
scriptlets, the <body-content> of a SimpleTag cannot be "JSP". A JSP
page is invalid if it references a custom tag whose tag handler
implements the SimpleTag interface and whose <body-content> is equal to
"JSP" as per the supporting TLD.

=== [[a2069]]JSP Fragments

During the translation phase, various pieces
of the page are translated into implementations of the
_javax.servlet.jsp.tagext.JspFragment_ abstract class, before being
passed to a tag handler. This is done automatically for any JSP code in
the body of a named attribute (one that is defined by _<jsp:attribute>_
) that is declared to be a fragment, or of type _JspFragment_ , in the
TLD. This is also automatically done for the body of any tag handled by
a Simple Tag handler. Once passed in, the tag handler can then evaluate
and re-evaluate the fragment as many times as needed, or even pass it
along to other tag handlers, in the case of Tag Files.

A JSP fragment can be parameterized by a tag
handler by setting page-scoped attributes in the _JspContext_ associated
with the fragment. These attributes can then be accessed via the EL.

A translation error must occur if a piece of
JSP code that is to be translated into a JSP Fragment contains
scriptlets or scriptlet expressions.

See link:javax.servlet.jsp.tagext.html#UNKNOWN[]
for more details on the _JspFragment_ abstract class.

=== Simple Examples of Simple Tag Handlers

In this section, we revisit the prototypical
uses of classic tag extensions, as was presented in
link:jsp.html#a2035[See Simple Examples of Classic Tag
Handlers.], and briefly describe how they are implemented using simple
tag handlers.

=== Plain Actions

To implement plain actions, the tag library
developer creates a class that extends _SimpleTagSupport_ and implements
the _doTag_ method. The details on accessing attributes and enforcing an
empty body are the same as with classic tag handlers. By default, the
rest of the page will be evaluated after invoking _doTag_ . To signal
that the page is to be skipped, _doTag_ throws _SkipPageException_ .

=== Actions with a Body

To implement actions with a body, the tag
library developer implements _doTag_ and invokes the body at any point
by calling _invoke_ on the _JspFragment_ object passed in via the
_setJspBody_ method. The tag handler can provide the fragment access to
variables through the _JspContext_ object.

=== Conditionals

All conditional logic is handled in the
_doTag_ method. If the body is not to be invoked, the tag library
developer simply does not call _invoke_ on the _JspFragment_ object
passed in via _setJspBody_ .

=== Iterations

All iteration logic is handled in the _doTag_
method. The tag library developer simply calls _invoke_ on the
_JspFragment_ object passed in via _setJspBody_ as many times as needed.

=== Actions that Process their Body

To divert the result of the body invocation,
the tag library developer passes a _java.io.Writer_ object to the
_invoke_ method on the body _JspFragment_ . Unlike the standard tag
handler’s _BodyContent_ solution, the result of the invocation does not
need to be buffered.

=== Cooperating Actions

Cooperating actions work the same way as with
classic tag handlers. A _setParent_ method is available in the
_SimpleTag_ interface and is called by the container before calling
_doTag_ if one tag invocation is nested within another. A
_findAncestorWithClass_ method is available on _SimpleTagSupport_ . This
should be used, instead of _TagSupport.findAncestorWithClass(),_ in all
cases where the desired return value may implement _SimpleTag_ .

Note that _SimpleTag_ does not extend _Tag_ .
Because of this, the _JspTag_ common base is used in these new APIs
instead of _Tag_ . Furthermore, because _Tag.setParent_ only accepts an
object of type _Tag_ , tag collaboration becomes more difficult when
classic tag handlers are nested inside _SimpleTag_ custom actions.

To make things easier, the
_javax.servlet.jsp.tagext.TagAdapter_ class can wrap any _SimpleTag_ and
expose it as if it were a _Tag_ instace. The original _JspTag_ can be
retrieved through its _getAdaptee_ method. Whenever calling the
_setParent_ method on a classic _Tag_ in a case where the outer tag does
not implement _Tag_ , the JSP Container must construct a new
_TagAdapter_ and call _setParent_ on the classic _Tag_ passing in the
adapter.

See link:javax.servlet.jsp.tagext.html#UNKNOWN[]
for more details on these APIs.

=== [[a2091]]Attributes With Dynamic Names

Prior to JSP 2.0, the name of every attribute
that a tag handler accepted was predetermined at the time the tag
handler was developed. It is sometimes useful, however, to be able to
define a tag handler that accepts attributes with dynamic names that are
not known until the page author uses the tag. For example, it is time
consuming and error-prone to anticipate what attributes a user may wish
to pass to a tag that mimics an HTML element.

New to JSP 2.0 is the ability to declare that
a tag handler accepts additional attributes with dynamic names. This is
done by having the tag handler implement the
_javax.servlet.jsp.tagext.DynamicAttributes_ interface. See
link:javax.servlet.jsp.tagext.html#UNKNOWN[] for more details on this
interface.

=== [[a2094]]Event Listeners

A tag library may include classes that are
event listeners (see the Servlet 2.5 specification). The listeners
classes are listed in the tag library descriptor and the JSP container
automatically instantiates them and registers them. A Container is
required to locate all TLD files (see link:jsp.html#a2138[See
Identifying Tag Library Descriptors.] for details on how they are
identified), read their _listener_ elements, and treat the event
listeners as extensions of those listed in _web.xml_ .

The order in which the listeners are
registered is undefined, but they are registered before application
start.

=== JspId Attribute

Sometimes it may be useful to provide unique
identifications for tag handlers. A tag handler can implement the
interface _javax.servlet.jsp.tagext.JspIdConsumer_ for such
functionality. See section JSP.13.4 for more details.

=== Resource Injection

The Java Metadata specification (JSR-175),
which is part of J2SE 5.0 and greater, provides a means of specifying
configuration data in Java code. Metadata in Java code is also referred
to as annotations. In Java EE, annotations are used to declare
dependencies on external resources and configuration data in Java code
without the need to define that data in a configuration file.

Section SRV.14.5 of the Servlet Specification
describes the behavior of annotations and resource injection in Java EE
technology compliant web containers.

In the JSP specification, tag handlers which
implement interfaces _javax.servlet.jsp.tagext.Tag_ and
_javax.servlet.jsp.tagext.SimpleTag_ may be annotated for injection. In
both cases, injection occurs immediately after an instance of the tag
handler is constructed, and before any of the tag properties are
initialized.

Event Listeners (See
link:jsp.html#a2094[See Event Listeners.]) can also be annotated
for resource injection. Injection occurs immediately after an instance
of the event handler is constructed, and before it is registered.

The annotations supported are:

*  _@EJB_ , @EJBs
* @PersistenceContext, @PersistenceContexts
* @PersistenceUnit, @PersistenceUnits
* @PostConstruct, @PreDestroy
*  _@Resource_ , _@Resources_
*  _@WebServiceRef, @WebServiceRefs_

Please see Section SRV.14.5 of the servlet
specification for more details on these annotations.

A JSP container that is not part of a Java EE
technology-compliant implementation is encouraged, but not required, to
support resource injection.

Resource injection is not supported for JSP
pages or tag files.

=== Tag Libraries

A tag library is a collection of actions that
encapsulate some functionality to be used from within a JSP page. A tag
library is made available to a JSP page through a _taglib_ directive
that identifies the tag library via a URI (Universal Resource
Identifier).

The URI identifying a tag library may be any
valid URI as long as it can be used to uniquely identify the semantics
of the tag library.

The URI identifying the tag library is
associated with a Tag Library Description (TLD) file and with tag
handler classes as indicated in link:jsp.html#a2131[See The Tag
Library Descriptor.] below.

=== Packaged Tag Libraries

JSP page authoring tools and JSP containers
are required to accept a tag library that is packaged as a JAR file.
When deployed in a JSP container, the standard JAR conventions described
in the Servlet 2.5 specification apply, including the conventions for
dependencies on extensions.

Packaged tag libraries must have at least one
tag library descriptor file. The JSP 1.1 specification allowed only a
single TLD, in _META-INF/taglib.tld_ , but as of JSP 1.2 multiple tag
libraries are allowed. See link:jsp.html#a2138[See Identifying
Tag Library Descriptors.] for how TLDs are identified.

Both Classic and Simple Tag Handlers
(implemented either in Java or as tag files) can be packaged together.

=== Location of Java Classes

A tag library contains classes for
instantiation at translation time and classes for instantiation at
request time. The former include classes such as _TagLibraryValidator_
and _TagExtraInfo_ . The latter include tag handler and event listener
classes.

The usual conventions for Java classes apply:
as part of a web application, they must reside either in a JAR file in
the _WEB-INF/lib_ directory, or in a directory in the _WEB-INF/classes_
directory.

A JAR containing packaged tag libraries must
be dropped into the _WEB-INF/lib_ directory to make its classes
available at request time (and also at translation time, see
link:jsp.html#a2189[See Translation-Time Class Loader.]). The
mapping between the URI and the TLD is explained further below.

=== Tag Library directive

The _taglib_ directive in a JSP page declares
that the page uses a tag library, uniquely identifies the tag library
using a URI, and associates a tag prefix with usage of the actions in
the library.

A JSP container maps the URI used in the
_taglib_ directive into a Tag Library Descriptor in two steps: it
resolves the URI into a TLD resource path, and then derives the TLD
object from the TLD resource path.

If the JSP container cannot locate a TLD
resource path for a given URI, a fatal translation error shall result.
Similarly, it is a fatal translation error for a URI attribute value to
resolve to two different TLD resource paths.

It is a fatal translation error for the
_taglib_ directive to appear after actions using the prefix introduced
by it.

=== [[a2131]]The Tag Library Descriptor

The Tag Library Descriptor (TLD) is an XML
document that describes a tag library. The TLD for a tag library is used
by a JSP container to interpret pages that include _taglib_ directives
referring to that tag library. The TLD is also used by JSP page
authoring tools that will generate JSP pages that use a library, and by
authors who do the same manually.

The TLD includes documentation on the library
as a whole and on its individual tags, version information on the JSP
container and on the tag library, and information on each of the actions
defined in the tag library.

The TLD may name a _TagLibraryValidator_
class that can validate that a JSP page conforms to a set of constraints
expected by the tag library.

Each action in the library is described by
giving its name, the class of its tag handler, information on any
scripting variables created by the action, and information on attributes
of the action. Scripting variable information can be given directly in
the TLD or through a _TagExtraInfo_ class. For each valid attribute
there is an indication about whether it is mandatory, whether it can
accept request-time expressions, and additional information.

A TLD file is useful for providing
information on a tag library. It can be read by tools without
instantiating objects or loader classes. Our approach conforms to the
conventions used in other Java EE technologies.

As of JSP 2.0, the format for the Tag Library
Descriptor is represented in XML Schema. This allows for a more
extensible TLD that can be used as a true single-source document.

=== [[a2138]]Identifying Tag Library Descriptors

Tag library descriptor files have names that
use the extension _.tld_ , and the extension indicates a tag library
descriptor file. When deployed inside a JAR file, the tag library
descriptor files must be in the _META-INF_ directory, or a subdirectory
of it. When deployed directly into a web application, the tag library
descriptor files must always be in the _WEB-INF_ directory, or some
subdirectory of it. TLD files should not be placed in _/WEB-INF/classes_
or _/WEB-INF/lib, and must not be placed inside /WEB-INF/tags or a
subdirectory of it, unless named implicit.tld and intended to configure
an implicit tag library with its JSP version and tlib-version_ .

The XML Schema for a TLD document is
_http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_1.xsd_ . See
link:jsp.html#a3944[See XML Schema for TLD, JSP 2.1.].

Note that tag files, which collectively form
tag libraries, may or may not have an explicitly defined TLD. In the
case that they do not, the container generates an implicit TLD that can
be referenced using the _tagdir_ attribute of the _taglib_ directive.
More details about identifying this implicit Tag Library Descriptor can
be found in link:jsp.html#a2322[See Tag Files.].

=== [[a2142]]TLD resource path

A URI in a _taglib_ directive is mapped into
a context relative path (as discussed in link:jsp.html#a274[See
Relative URL Specifications.]). The context relative path is a URL
without a protocol and host components that starts with _/_ and is
called the TLD resource path.

The TLD resource path is interpreted relative
to the root of the web application and should resolve to a TLD file
directly, or to a JAR file that has a TLD file at location
_META-INF/taglib.tld_ . If the TLD resource path is not one of these two
cases, a fatal translation error will occur.

The URI describing a tag library is mapped to
a TLD resource path though a taglib map, and a fallback interpretation
that is to be used if the map does not contain the URI. The taglib map
is built from an explicit taglib map in _web.xml_ (described in
link:jsp.html#a2153[See Taglib Map in web.xml.]) that is
extended with implicit entries deduced from packaged tag libraries in
the web application (described in link:jsp.html#a2155[See
Implicit Map Entries from TLDs.] _)_ , and implicit entries known to the
JSP container. The fallback interpretation is targetted to a casual use
of the mechanism, as in the development cycle of the Web Application; in
that case the URI is interpreted as a direct path to the TLD (see
link:jsp.html#a2172[See Computing the TLD Resource Path.]).

The following order of precedence applies
(from highest to lowest) when building the taglib map (see the following
sections for details):

. If the container is Java EE platform
compliant, the Map Entries for the tag libraries that are part of the
Java EE platform. This currently includes the JavaServer Pages Standard
Tag Library libraries and the JavaServer Faces libraries.
. Taglib Map in web.xml
. Implicit Map Entries from TLDs
. TLDs in JAR files in WEB-INF/lib
. TLDs under WEB-INF
. Implicit Map Entries from the Container

=== [[a2153]]Taglib Map in web.xml

The __ _web.xml_ file can include an explicit
taglib map between URIs and TLD resource paths described using the
_taglib_ elements of the Web Application Deployment descriptor in
_WEB-INF/web.xml_ . See link:jsp.html#a1215[See Taglib Map.] for
more details.

=== [[a2155]]Implicit Map Entries from TLDs

The taglib map described in _web.xml_ is
extended with new entries extracted from TLD files in the Web
Application. The new entries are computed as follows:

* The container searches for all files with a
_.tld_ extension under _/WEB-INF_ or a subdirectory, and inside JAR
files that are in _/WEB-INF/lib_ . When examining a JAR file, only
resources under _/META-INF_ or a subdirectory are considered. The order
in which these files are searched for is implementation-specific and
should not be relied on by web applications.
* Each TLD file is examined. If it has a
_<uri>_ element, then a new _<taglib>_ element is created, with a
_<taglib-uri>_ subelement whose value is that of the _<uri>_ element,
and with a _<taglib-location>_ subelement that refers to the TLD file.
* If the created _<taglib>_ element has a
different _<taglib-uri>_ to any in the taglib map, it is added.

This mechanism provides an automatic URI to
TLD mapping as well as supporting multiple TLDs within a packaged JAR.
Note that this functionality does not require explicitly naming the
location of the TLD file, which would require a mechanism like the
_jar:protocol_ .

Note also that the mechanism does not add
duplicated entries.

=== [[a2162]]Implicit Map Entries from the Container

The Container may also add additional entries
to the taglib map. As in the previous case, the entries are only added
for URIs that are not present in the map. Conceptually the entries
correspond to TLD describing these tag libraries.

These implicit map entries correspond to
libraries that are known to the Container, who is responsible for
providing their implementation, either through tag handlers, or via the
mechanism described in link:jsp.html#a2195[See Well-Known
URIs.].

=== [[a2165]]Determining the TLD Resource Path

The TLD resource path can be determined from
the _uri_ attribute of a _taglib_ directive as described below. In the
explanation below an absolute URI is one that starts with a protocol and
host, while a relative URI specification is as in section 2.5.2, i.e.
one without the protocol and host part.

All steps are described as if they were
taken, but an implementation can use a different implementation strategy
as long as the result is preserved.

=== Computing TLD Locations

The taglib map generated in Sections
link:jsp.html#a2153[See Taglib Map in web.xml.],
link:jsp.html#a2155[See Implicit Map Entries from TLDs.] and
link:jsp.html#a2162[See Implicit Map Entries from the
Container.] may contain one or more _<taglib></taglib>_ entries. Each
entry is identified by a _taglib_uri_ , which is the value of the
_<taglib-uri>_ subelement. This _taglib_uri_ may be an absolute URI, or
a relative URI spec starting with _/_ or one not starting with _/_ .
Each entry also defines a _taglib_location_ as follows:

* If the _<taglib-location>_ subelement is
some relative URI specification that starts with a _/_ the
_taglib_location_ is this URI.
* If the _<taglib-location>_ subelement is
some relative URI specification that does not start with _/_ , the
_taglib_location_ is the resolution of the URI relative to
_/WEB-INF/web.xml_ (the result of this resolution is a relative URI
specification that starts with _/_ ).

=== [[a2172]]Computing the TLD Resource Path

The following describes how to resolve a
_taglib_ directive to compute the TLD resource path. It is based on the
value of the __ _uri_ attribute of the _taglib_ directive.

* If _uri_ is _abs_uri_ , an absolute URI

Look in the taglib map for an entry whose
_taglib_uri_ is _abs_uri_ . If found, the corresponding
_taglib_location_ is the TLD resource path. If not found, a translation
error is raised.

* If _uri_ is _root_rel_uri_ , a relative URI
that starts with _/_

Look in the taglib map for an entry whose
_taglib_uri_ is _root_rel_uri_ . If found, the corresponding
_taglib_location_ is the TLD resource path. If no such entry is found,
_root_rel_uri_ is the TLD resource path.

* If _uri_ is _noroot_rel_uri_ , a relative
URI that does not start with _/_

Look in the _taglib map_ for an entry whose
_taglib_uri_ is _noroot_rel_uri_ . If found, the corresponding
_taglib_location_ is the TLD resource path. If no such entry is found,
resolve _noroot_rel_uri_ relative to the current JSP page where the
directive appears; that value (by definition, this is a relative URI
specification that starts with _/_ ) is the TLD resource path. For
example, if _/a/b/c.jsp_ references +
_../../WEB-INF/my.tld_ , then if there is no _taglib_location_ that
matches +
_../../WEB-INF/my.tld_ , the TLD resource path would be
_/WEB-INF/my.tld_ .

=== Usage Considerations

The explicit _web.xml_ map provides a
explicit description of the tag libraries that are being used in a web
application.

The implicit map from TLDs means that a JAR
file implementing a tag library can be dropped in and used immediatedly
through its stable URIs.

The use of relative URI specifications in the
taglib map enables very short names in the _taglib_ __ directive. For
example, if the map is:

<taglib> +
<taglib-uri>/myPRlibrary</taglib-uri> +
<taglib-location>/WEB-INF/tlds/PRlibrary_1_4.tld</taglib-location> +
</taglib>

then it can be used as:

<%@ taglib uri=”/myPRlibrary” prefix=”x” %>

Finally, the fallback rule allows a _taglib_
directive to refer directly to the TLD. This arrangement is very
convenient for quick development at the expense of less flexibility and
accountability. For example, in the case above, it enables:

<%@ taglib
uri=”/WEB-INF/tlds/PRlibrary_1_4.tld” prefix=”x” %>

=== [[a2189]]Translation-Time Class Loader

The set of classes available at translation
time is the same as that available at runtime: the classes in the
underlying Java platform, those in the JSP container, and those in the
class files in _WEB-INF/classes_ , in the JAR files in _WEB-INF/lib_ ,
and, indirectly those indicated through the use of the _class-path_
attribute in the _META-INF/MANIFEST_ file of these JAR files.

=== Assembling a Web Application

As part of the process of assembling a web
application, the Application Assembler will create a _WEB-INF/_ __
directory, with appropriate _lib/_ and _classes/_ subdirectories, place
JSP pages, servlet classes, auxiliary classes, and tag libraries in the
proper places, and create a _WEB-INF/web.xml_ that ties everything
together.

Tag libraries that have been delivered in the
standard JAR format can be dropped directly into _WEB-INF/lib_ . This
automatically adds all the TLDs inside the JAR, making their URIs
advertised in their _<uri>_ elements visible to the URI to TLD map. The
assembler may create _taglib_ entries in _web.xml_ for each of the
libraries that are to be used.

Part of the assembly (and later the
deployment) may create and/or change information that customizes a tag
library; see link:jsp.html#a2318[See Customizing a Tag
Library.].

=== [[a2195]]Well-Known URIs

A JSP container may “know of” some specific
URIs and may provide alternate implementations for the tag libraries
described by these URIs, but the user must see the behavior as that
described by the required, portable tag library description described by
the URI.

A JSP container must always use the mapping
specified for a URI in the _web.xml_ deployment descriptor if present.
If the deployer wants to use the platform-specific implementation of the
well-known URI, the mapping for that URI should be removed at deployment
time.

=== Tag and Tag Library Extension Elements

The JSP 2.0 Tag Library Descriptor supports
the notion of Tag Extension Elements and Tag Library Extension Elements.
These are elements added to the TLD by the tag library developer that
provide additional information about the tag, using a schema defined
outside of the JSP specification.

The information contained in these extensions
is intended to be used by tools only, and is not accessible at
compile-time, deployment-time, or run-time. JSP containers must not
alter their behavior based on the content, the presence, or the absence
of a particular Tag or Tag Library Extension Element. In addition, JSP
containers must consider invalid any tag library that specifies
_mustUnderstand=”true”_ for any Tag or Tag Library Extension element.
Any attempt to use an invalid tag library must produce a translation
error. This is to preserve application compatibility across containers.

The JSP container may use schema to validate
the structure of the Tag Library Descriptor. If it does so, any new
content injected into Tag or Tag Library Extension elements must not be
validated by the JSP Container.

Tag Library Extension Elements provide
extension information at the tag library level, and are specified by
adding a _<taglib-extension>_ element as a child of _<taglib>_ . Tag
Extension Elements provide extension information at the tag level, and
are specified by adding a _<tag-extension>_ element as a child of
_<tag>_ . To use these elements, an XML namespace must first be defined
and the namespace must be imported into the TLD.

There are efforts under way in the JCP (Java
Community Process) to define standard extensions for enhanced tool
support for JSP page authoring. Such standard extensions should be used
where appropriate.

=== Example

In the following non-normative example, a
fictitious company called ACME has decided to enhance the page author’s
experience by defining a set of Tag and Tag Library Extension elements
that cause sounds to be played when inserting tags in a document.

In this hypothetical example, ACME has
published an XML Schema at _http://www.acme.com/acme.xsd_ that defines
the extensions, and has provided plug-ins for various JSP-capable IDEs
to recognize these extension elements.

The following example tag library uses ACME’s
extensions to provide helpful voice annotations that describe how to use
each tag in the tag library. Relevant parts highlighted in bold:



<taglib
xmlns=”http://java.sun.com/xml/ns/javaee” +
xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance” +
xmlns:acme=”http://acme.com/” +
xsi:schemaLocation=”http://java.sun.com/xml/ns/javaee +
http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_1.xsd +
http://acme.com/ http://acme.com/acme.xsd” +
version=”2.1”>

 <description> +
Simple Math Tag Library. +
Contains ACME sound extensions with helpful voice annotations +
that describe how to use the tags in this library. +
</description>

 <tlib-version>1.0</tlib-version>

 <short-name>math</short-name>

 <tag>

 <description>Adds two
numbers</description> +
<display-name>add</display-name> +
<name>add</name> +
<tag-class>com.foobar.tags.AddTag</tag-class> +
<body-content>empty</body-content> +
<attribute> +
<name>x</name> +
<type>java.lang.Double</type> +
</attribute> +
<attribute> +
<name>y</name> +
<type>java.lang.Double</type> +
</attribute>

 <tag-extension
namespace=”http://acme.com/”> +
<!-- Extensions for tag sounds --> +
<extension-element xsi:type=”acme:acme-soundsType”> +
<acme:version>1.5</acme:version>

 <!-- Sound played for help on the add tag
--> +
<acme:tag-sound>sounds/add.au</acme:tag-sound>

 <!-- Sound played for help on the x
attribute --> +
<acme:attribute-sound name=”x”> +
sounds/add-x.au +
</acme:attribute-sound>

 <!-- Sound that’s played for help on the
yattribute --> +
<acme:attribute-sound name=”y”> +
sounds/add-y.au +
</acme:attribute-sound>

 </extension-element> +
</tag-extension>

 </tag>

 <taglib-extension
namespace=”http://acme.com/”> +
<!-- Extensions for taglibrary sounds--> +
<extension-element xsi:type=”acme:acme-soundsType”> +
<acme:version>1.5</acme:version> +
<!-- Sound played when author imports this taglib --> +
<acme:import-sound>sounds/intro.au</acme:import-sound> +
</extension-element> +
</taglib-extension>

</taglib>



The corresponding _acme.xsd_ file would look
something like:



<?xml version=”1.0” encoding=”UTF-8”?>



<xsd:schema

 targetNamespace=”http://acme.com/”

 xmlns:j2ee=”http://java.sun.com/xml/ns/j2ee”

 xmlns:acme=”http://acme.com/”

 xmlns:xsd=”http://www.w3.org/2001/XMLSchema”


xmlns:xml=”http://www.w3.org/XML/1998/namespace”

 elementFormDefault=”qualified”

 attributeFormDefault=”unqualified”

 version=”1.0”>



 <xsd:annotation>

 <xsd:documentation>

 This an XML Schema for sample Acme taglib
extensibility

 elements, used to test TLD extensibility.

 </xsd:documentation>

 </xsd:annotation>



 <!--
**************************************************** -->



 <xsd:import
namespace=”http://java.sun.com/xml/ns/j2ee”
schemaLocation=”../web-jsptaglibrary_2_0.xsd” />



 <!--
**************************************************** -->



 <xsd:complexType name=”acme-soundsType”>

 <xsd:annotation>

 <xsd:documentation>

 Extension for sounds associated with a tag

 </xsd:documentation>

 </xsd:annotation>

 <xsd:complexContent>

 <xsd:extension base=”j2ee:extensibleType”>

 <xsd:sequence>

 <xsd:element name=”version”
type=”xsd:string”/>

 <xsd:element name=”tag-sound”
type=”xsd:string”

 minOccurs=”0” maxOccurs=”unbounded”/>

 <xsd:element name=”attribute-sound”

 minOccurs=”0” maxOccurs=”unbounded”>

 <xsd:complexType>

 <xsd:simpleContent>

 <xsd:extension base=”xsd:string”>

 <xsd:attribute name=”name” use=”required”

 type=”xsd:string” />

 </xsd:extension>

 </xsd:simpleContent>

 </xsd:complexType>

 </xsd:element>

 <xsd:element name=”import-sound”
type=”xsd:string”

 minOccurs=”0” maxOccurs=”unbounded”/>

 </xsd:sequence>

 </xsd:extension>

 </xsd:complexContent>

 </xsd:complexType>



 <!--
**************************************************** -->



</xsd:schema>

=== Validation

There are a number of reasons why the
structure of a JSP page should conform to some validation rules:

* Request-time semantics; e.g. a subelement
may require the information from some enclosing element at request-time
.
* Authoring-tool support; e.g. a tool may
require an ordering in the actions.
* Methodological constraints; e.g. a
development group may want to constrain the way some features are used.

Validation can be done either at
translation-time or at request-time. In general translation-time
validation provides a better user experience, and the JSP 2.2
specification provides a very flexible translation-time validation
mechanism.

=== Translation-Time Mechanisms

Some translation-time validation is
represented in the Tag Library Descriptor. In some cases a
_TagExtraInfo_ class needs to be provided to supplement this
information.

=== Attribute Information

The Tag Library Descriptor contains the basic
syntactic information. In particular, the attributes are described
including their name, whether they are optional or mandatory, and
whether they accept request-time expressions. Additionally the
_body-content_ element can be used to indicate that an action must be
empty.

All constraints described in the TLD must be
enforced. A tag library author can assume that the tag handler instance
corresponds to an action that satisfies all constraints indicated in the
TLD.

=== [[a2295]]Validator Classes

A _TagLibraryValidator_ class may be listed
in the TLD for a tag library to request that a JSP page be validated.
The XML view of a JSP page is exposed through a _PageData_ class, and
the validator class can do any checks the tag library author may have
found appropriate.

The JSP container must uniquely identify all
XML elements in the XML view of a JSP page through a _jsp:id_ attribute.
This attribute can be used to provide better information on the location
of an error.

The validator class mechanism is new as of
the JSP 1.2 specification. A _TagLibraryValidator_ can be passed some
initialization parameters in the TLD. This eases the reuse of validator
classes. We expect that validator classes will be written based on
different XML schema mechanisms (DTDs, XSchema, Relaxx, others).
Standard validator classes may be incorporated into a later version of
the JSP specification if a clear schema standard appears at some point.

=== TagExtraInfo Class Validation

Additional translation-time validation can be
done using the _validate_ method in the _TagExtraInfo_ class. The
_validate_ method is invoked at translation-time and is passed a
_TagData_ instance as its argument. As of JSP 2.0, the default behavior
of _validate_ is to call the _isValid_ method.

The _isValid_ mechanism was the original
validation mechanism introduced in JSP 1.1 with the rest of the Tag
Extension machinery. Tag libraries that are designed to run in JSP 1.2
containers or higher should use the validator class mechanism. Tag
libraries that are designed to run in JSP 2.0 containers or higher that
wish to use the _TagExtraInfo_ validation mechanism are encouraged to
implement the _validate_ method in favor of the _isValid_ method due to
the ability to provide better validation messages. Either method will
work, though implementing both is not recommended.

=== Request-Time Errors

In some cases, additional request-time
validation will be done dynamically within the methods in the tag
handler. If an error is discovered, an instance of _JspException_ can be
thrown. If uncaught, this object will invoke the errorpage mechanism of
the JSP specification.

=== Conventions and Other Issues

This section is not normative, although it
reflects good design practices.

=== How to Define New Implicit Objects

We advocate the following style for the
introduction of implicit objects:

* Define a tag library.
* Add an action called _defineObjects_ to
define the desired objects.

The JSP page can make these objects available
as follows:

<%@ taglib prefix="me" uri="......" %> +
<me:defineObjects /> +
.... start using the objects....

This approach has the advantage of requiring
no new machinery and of making very explicit the dependency.

In some cases there may be an implementation
dependency in making these objects available. For example, they may be
providing access to some functionality that exists only in a particular
implementation. This can be done by having the tag extension class test
at run-time for the existence of some implementation dependent feature
and raise a run-time error (this, of course, makes the page not Java EE
compliant).

This mechanism, together with the access to
metadata information allows for vendors to innovate within the standard.

* 

=== Access to Vendor-Specific information

If a vendor wants to associate some
information that is not described in the current version of the TLD with
some tag library, it can do so by inserting the information in a
document it controls, inserting the document in the _WEB-INF_ portion of
the Web Application where the Tag Library resides, and using the
standard Servlet 2.4 mechanisms to access that information.

=== [[a2318]]Customizing a Tag Library

A tag library can be customized at assembly
and deployment time. For example, a tag library that provides access to
databases may be customized with login and password information.

There is no convenient place in _web.xml_ in
the Servlet 2.4 spec for customization information A standardized
mechanism is probably going to be part of a forthcoming JSP
specification, but in the meantime the suggestion is that a tag library
author place this information in a well-known location at some resource
in the _WEB-INF/_ __ portion of the Web Application and access it via
the _getResource_ call on the _ServletContext_ .

== CHAPTER 7 - 

=== [[a2322]]Tag Files

This chapter describes the details of tag
files, a JSP 2.0 facility that allows page authors to author tag
extensions using only JSP syntax. In the past, the ability to
encapsulate presentation logic into reusable, full-featured tag
libraries was only available to developers that had a reasonable amount
of Java experience. Tag files bring the power of reuse to the basic page
author, who are not required to know Java. When used together with JSP
Fragments and Simple Tag Handlers, these concepts have the ability to
simplify JSP development substantially, even for developers who do know
Java.

===  Overview

As of JSP version 2.0, the JSP Compiler is
required to recognize tag files. A tag file is a source file that
provides a way for a page author to abstract a segment of JSP code and
make it reusable via a custom action.

Tag files allow a JSP page author to create
tag libraries using JSP syntax. This means that page authors no longer
need to know Java or ask someone who knows Java to write a tag
extension. Even for page authors or tag library developers who know
Java, writing tag files is more convenient when developing tags that
primarily output template text.

The required file extension for a tag file
are _.tag_ or _.tagx._ As is the case with JSP files, the actual tag may
be composed of a top file that includes other files that contain either
a complete tag or a segment of a tag file. Just as the recommended
extension for a segment of a JSP file is _.jspf_ , the recommended
extension for a segment of a tag file is _.tagf_ .

=== Syntax of Tag Files

The syntax of a tag file is similar to that
of a JSP page, with the following exceptions:

* Directives - Some directives are not
available or have limited availability, and some tag file specific
directives are available. See link:jsp.html#a2375[See Tag File
Directives.] for a discussion on tag file directives.
* The _<jsp:invoke>_ and _<jsp:doBody>_
standard actions can only be used in Tag Files.

The EBNF grammar in
link:jsp.html#a388[See JSP Syntax Grammar.] describes the
syntax of tag files. The root production for a tag files is _JSPTagDef_
.

See link:jsp.html#a2492[See Tag Files
in XML Syntax.] for details on tag files in XML syntax.

=== Semantics of Tag Files

For each tag file in the web application, a
tag handler is made available to JSP pages and other tag files. The
specifics of how this is done are left up to the Container
implementation. For example, some Containers may choose to compile tag
files into Java tag handlers, whereas others may decide to interpret the
tag handlers.

However the Container chooses to prepare the
tag handler, the following conditions must hold true for all tag
handlers defined as tag files:

* The tag file implementation must keep a
copy of the _JspContext_ __ instance passed to it by the invoking page
via the _setJspContext_ method. This is called the _Invoking JSP
Context_ .
* The tag file implementation must create and
maintain a second instance of _JspContext_ called a _JSP Context
Wrapper_ . If the Invoking JSP Context is an instance of _PageContext_ ,
the JSP Context Wrapper must also be an instance of _PageContext_ . This
wrapper must be returned when _getJspContext()_ is called.
* For each invocation to the tag, the JSP
Context Wrapper must present a clean page scope containing no initial
elements. All scopes other than the page scope must be identical to
those in the Invoking JSP Context and must be modified accordingly when
updates are made to those scopes in the JSP Context Wrapper. Any
modifications to the page scope, however, must not affect the Invoking
JSP Context.
* For each attribute declared and specified,
a page-scoped variable must be created in the page scope of the JSP
Context Wrapper, unless the attribute is a deferred value or a deferred
method, in which case the VariableMapper obtained from the ELContext in
the current pageContext is used to map the deferred expression to the
attribute name. The name of the variable must be the same as the
declared attribute name. The value of the variable must be the value of
the attribute passed in during invocation. For each attribute declared
as optional and not specified, no variable is created. If the tag
accepts dynamic attributes, then the names and values of those dynamic
attributes must be exposed to the tag file as specified in
link:jsp.html#a2408[See Details of tag directive attributes.]. +
 +
If the attribute is a deferred-value, it is directly mapped. If the
attribute is a deferred-method, it is wrapped in a _ValueExpression_ ,
and the resulting _ValueExpression_ is mapped. +
 +
There are two implications here. They are best illustrated by examples.
Suppose we have a tag file +
 +
tagf.tag: +
_<%@ attribute name="attr1" deferredValue="true"/> +
<%@ attribute name="attr2" deferredMethod="true"/> +
<c:out value="$\{attr1.bar}"/> +
<h:commandButton value="#\{attr1.foo}" action="#\{attr2}"/> +
_ +
used in test.jsp +
_<%@ taglib prefix="my" tagdir="/WEB-INF/tags"%> +
<my:tagf attr1="#\{someExpr}" attr2="#\{someMethod}"/> +
_ +
First, in _tagf.tag_ , _$\{attr1.bar}_ will cause the immediate
evaluation of the deferred expression. Secondly, since the
_VariableMapper_ is used to resolve variables at EL parse time, a
deferred expression such as _#\{attr1.foo}_ is not dependent on _attr1_
anymore, so that it can be evaluated long after the end of life of the
tag file's pageContext. This is very useful for JavaServer Faces
applications. +
 +
Since the EL syntax does not allow for invokation of the method in a
_MethodExpression_ , the only allowable use of _attr2_ is to pass it to
another tag that has a deferred-method attribute, in the form of "
_#\{attr2}_ ".
* For all intents and purposes other than for
synchronizing the _AT_BEGIN_ , _NESTED_ , and _AT_END_ scripting
variables, the effective _JspContext_ for the tag file is the JSP
Context Wrapper. For example, the _jspContext_ scripting variable must
point to the JSP Context Wrapper instead of the invoking JSP Context.
* The tag handler must behave as though a tag
library descriptor entry was defined for it, in accordance with the
_tag_ , _attribute_ , and _variable_ directives that appear in the tag
file translation unit.

It is legal for a tag file to forward to a
page via the _<jsp:forward>_ standard action. Just as for JSP pages, the
forward is handled through the request dispatcher. Upon return from the
_RequestDispatcher.forward_ method, the generated tag handler must stop
processing of the tag file and throw
_javax.servlet.jsp.SkipPageException_ . Similarly, if a tag file invokes
a Classic Tag Handler which returns _SKIP_PAGE_ from the _doEndTag_
method, or if it invokes a Simple Tag Handler which throws
_SkipPageException_ in the _doTag_ method, the generated tag handler
must terminate and _SkipPageException_ must be thrown. In either of
these two cases, the _doCatch_ and _doFinally_ methods must be called on
enclosing tags that implement the _TryCatchFinally_ interface before
returning. The _doEndTag_ methods of enclosing classic tags must not be
called.

Care should be taken when invoking a classic
tag handler from a tag file. In general, SimpleTag Extensions can be
used in environments other than servlet environments. However, because
the _Tag_ interface relies on _PageContext_ , which in turn assumes a
servlet environment, using classic tag handlers indirectly binds the use
of the tag file to servlet environments. Nonetheless, the JSP container
must allow such an invocation to occur. When a tag file attempts to
invoke a classic tag handler (i.e. one that implements the _Tag_
interface), it must cast the _JspContext_ passed to the _SimpleTag_ into
a _PageContext_ . In the event that the class cast fails, the invocation
of the classic tag fails, and a _JspException_ must be thrown.

If a tag file in XML syntax contains a
jsp:root element, the value of that element’s version attribute must
match the tag file’s JSP version. See link:jsp.html#a2352[See
Packaging in a JAR.], and link:jsp.html#a2356[See Packaging
Directly in a Web Application.], for how the JSP version of a tag file
is determined.

=== [[a2346]]Packaging Tag Files

One of the goals of tag files as a technology
is to make it as easy to write a tag handler as it is to write a JSP.
Traditionally, writing tag handlers has been a tedious task, with a lot
of time spent compiling and packaging the tag handlers and writing a TLD
to provide information to tools and page authors about the custom
actions. The rules for packaging tag files are designed to make it very
simple and fast to write simple tags, while still providing as much
power and flexibility as classic tag handlers have.

=== [[a2348]]Location of Tag Files

Tag extensions written in JSP using tag files
can be placed in one of two locations. The first possibility is in the
_/META-INF/tags/_ directory (or a subdirectory of _/META-INF/tags/_ ) in
a _JAR_ file installed in the _/WEB-INF/lib/_ directory of the web
application. Tags placed here are typically part of a reusable library
of tags that can be easily dropped into any web application.

The second possibility is in the
_/WEB-INF/tags/_ directory (or a subdirectory of _/WEB-INF/tags/_ ) of
the web application. Tags placed here are within easy reach and require
little packaging. Only files with a _.tag_ or . _tagx_ extension are
recognized by the container to be tag files.

Tag files that appear in any other location
are not considered tag extensions and must be ignored by the JSP
container. For example, a tag file that appears in the root of a web
application would be treated as content to be served.

=== [[a2352]]Packaging in a JAR

To be accessible, tag files bundled in a
_JAR_ require a Tag Library Descriptor. Tag files that appear in a JAR
but are not defined in a TLD must be ignored by the JSP container.

JSP 2.0 adds an additional TLD element to
describe tags within a tag library, namely _<tag-file>_ . The
_<tag-file>_ element requires _<name>_ and _<path>_ subelements, which
define the tag name and the full path of the tag file from the root of
the JAR, respectively. In a JAR file, the _<path>_ element must always
begin with _/META-INF/tags_ . The values for the other subelements of
_<tag-file>_ override the defaults specified in the tag directive. Tag
files packaged in a JAR inherit the JSP version of the TLD that
references them.

Note that it is possible to combine both
classic tag handlers and tag handlers implemented using tag files in the
same tag library by combining the use of _<tag>_ and _<tag-file>_
elements under the _<taglib>_ element. This means that in most instances
the client is unaware of how the tag extension was implemented. Given
that _<tag>_ and _<tag-file>_ share a namespace, a tag library is
considered invalid and must be rejected by the container if a
_<tag-file>_ element has a _<name>_ subelement with the same content as
a _<name>_ subelement in a _<tag>_ element. Any attempt to use an
invalid tag library must trigger a translation error.

=== [[a2356]]Packaging Directly in a Web Application

Tag files placed in the _/WEB-INF/tags/_
directory of the web application, or a subdirectory, are made easily
accessible to JSPs without the need to explicitly write a Tag Library
Descriptor. This makes it convenient for page authors to quickly
abstract reusable JSP code by simply creating a new file and placing the
code inside of it.

The JSP container must interpret the
_/WEB-INF/tags/_ directory and each subdirectory under it, as another
implicitly defined tag library containing tag handlers defined by the
tag files that appear in that directory. There are no special
relationships between subdirectories - they are allowed simply for
organizational purposes. For example, the following web application
contains three tag libraries:

 /WEB-INF/tags/ +
/WEB-INF/tags/a.tag +
/WEB-INF/tags/b.tag +
/WEB-INF/tags/foo/ +
/WEB-INF/tags/foo/c.tagx +
/WEB-INF/tags/bar/baz/ +
/WEB-INF/tags/bar/baz/d.tag

The JSP container must generate an implicit
tag library for each directory under and including _/WEB-INF/tags/_ .
This tag library can be imported only via the _tagdir_ attribute of the
_taglib_ directive (see link:jsp.html#a864[See The taglib
Directive.]), and has the following hard-wired values:

*  _<tlib-version>_ for the tag library
defaults to 1.0
*  _<short-name>_ is derived from the
directory name. If the directory is _/WEB-INF/tags/_ , the short name is
simply _tags_ . Otherwise, the full directory path (relative to the web
application) is taken, minus the _/WEB-INF/tags/_ prefix. Then, all _/_
characters are replaced with _-_ , which yields the short name. Note
that short names are not guaranteed to be unique (as in _/WEB-INF/tags/_
versus _/WEB-INF/tags/tags/_ or _/WEB-INF/tags/a-b/_ versus
_/WEB-INF/tags/a/b/_ )
* A _<tag-file>_ element is considered to
exist for each tag file in this directory, with the following
sub-elements:
* The _<name>_ for each is the filename of
the tag file, without the _.tag_ or _.tagx_ extension.
* The _<path>_ for each is the path of the
tag file, relative to the root of the web application.

For the above example, the implicit Tag
Library Descriptor for the _/WEB-INF/tags/bar/baz/_ directory would be:

 <taglib> +
<tlib-version>1.0</tlib-version> +
<short-name>bar-baz</short-name> +
<tag-file> +
<name>d</name> +
<path>/WEB-INF/tags/bar/baz/d.tag</path> +
</tag-file> +
</taglib>

The JSP version of an implicit tag library
defaults to 2.0.

The JSP version and tlib-version of an
implicit tag library may be configured by placing a TLD with the
reserved name implicit.tld in the same directory as the implicit tag
library’s constituent tag files. A JSP 2.1 container must consider only
the JSP version and tlib-version specified by an implicit.tld file, and
ignore its short-name element. Any additional elements in an
implicit.tld file must cause a translation error. The JSP version
specified in an implicit.tld file must be equal to or greater than 2.0,
or else a translation error must be reported.

Upon deployment, the JSP container must
search for and process all tag files appearing in these directories and
subdirectories. In processing a tag file, the container makes the custom
actions defined in these tags available to JSP files.

If a directory contains two files with the
same tag name (e.g. _a.tag_ and _a.tagx_ ), it is considered to be the
same as having a TLD file with two _<tag>_ elements whose _<name>_
sub-elements are identical. The tag library is therefore considered
invalid.

Despite the existence of an implicit tag
library, a Tag Library Descriptor in the web application can still
create additional tags from the same tag files. This is accomplished by
adding a _<tag-file>_ element with a _<path>_ that points to the tag
file. In this case, the value of _<path>_ must start with
_/WEB-INF/tags_ . It a tag file is referenced by both a TLD as well as
an implicit TLD, the JSP versions of the TLD and implicit TLD do not
need to match.

=== Packaging as Precompiled Tag Handlers

Tag files can also be compiled into Java
classes and bundled as a tag library. This is useful for the situation
where a tag library developer wishes to distribute a binary version of
the tag library without the original source. Tag library developers that
choose this form of packaging must use a tool that produces portable JSP
code that uses only standard APIs. Containers are not required to
provide such a tool.

=== [[a2375]]Tag File Directives

This section describes the directives
available within tag files, which define Simple Tag Handlers.
link:jsp.html#a2377[See Directives available to tag files.]
outlines which directives are available in tag files:

=== [[a2377]]Directives available to tag files

Directive

Available?

Interpretation/Restrictions

 _page_

no

A tag file is not a _page_ . The _tag_
directive must be used instead. If this directive is used in a tag file,
a translation error must result.

 _taglib_

yes

Identical to JSP pages.

 _include_

yes

Identical to JSP pages. Note that if the
included file contains syntax unsuitable for tag files, a translation
error must occur.

 _tag_

yes

Only applicable to tag files. An attempt to
use this directive in JSP pages will result in a translation error.

 _attribute_

yes

Only applicable to tag files. An attempt to
use this directive in JSP pages will result in a translation error.

 _variable_

yes

Only applicable to tag files. An attempt to
use this directive in JSP pages will result in a translation error.

=== [[a2399]]The tag Directive

The _tag_ directive is similar to the _page_
directive, but applies to tag files instead of JSPs. Like the _page_
directive, a translation unit can contain more than one instance of the
_tag_ directive, all the attributes will apply to the complete
translation unit (i.e. _tag_ directives are position independent). There
shall be only one occurrence of any attribute/value defined by this
directive in a given translation unit, unless the values for the
duplicate attributes are identical for all occurrences. The _import_ and
_pageEncoding_ attributes are exempt from this rule and can appear
multiple times. Multiple uses of the _import_ attribute are cumulative
(with ordered set union semantics). Other such multiple attribute/value
(re)definitions result in a fatal translation error if the values do not
match.

The attribute/value namespace is reserved for
use by this, and subsequent, JSP specification(s).

Unrecognized attributes or values result in
fatal translation errors.

=== Examples

<%@ tag display-name=”Addition” +
body-content=”scriptless” +
dynamic-attributes=”dyn” +
small-icon=”/WEB-INF/sample-small.jpg” +
large-icon=”/WEB-INF/sample-large.jpg” +
description=”Sample usage of tag directive” %>

=== Syntax

<%@ tag tag_directive_attr_list %> +
 +
tag_directive_attr_list ::= +
\{ display-name=”display-name” } +
\{ body-content=”scriptless|tagdependent|empty” } +
\{ dynamic-attributes=”name” } +
\{ small-icon=”small-icon” } +
\{ large-icon=”large-icon” } +
\{ description=”description” } +
\{ example=”example” } +
\{ language=”scriptingLanguage” } +
\{ import=”importList” } +
\{ pageEncoding=”peinfo” } +
\{ isELIgnored=”true|false” } +
\{ deferredSyntaxAllowedAsLiteral=”true|false” } +
\{ trimDirectiveWhitespaces=”true|false” }

The details of the attributes are as follows:

=== [[a2408]]Details of _tag_ directive attributes

 _display-name_

(optional) A short name that is intended to
be displayed by tools. Defaults to the name of the tag file, without the
_.tag_ extension.

 _body-content_

(optional) Provides information on the
content of the body of this tag. Can be either _empty_ , _tagdependent_
, or _scriptless_ . A translation error will result if _JSP_ or any
other value is used. Defaults to _scriptless_ .

 _dynamic-attributes_

(optional) The presence of this attribute
indicates this tag supports additional attributes with dynamic names. If
present, the generated tag handler must implement the
_javax.servlet.jsp.tagext.DynamicAttributes_ interface, and the
container must treat the tag as if its corresponding TLD entry contained
_<dynamic-attributes>true</dynamic-attributes>_ . The implementation
must not reject any attribute names. The value identifies a page scoped
attribute in which to place a _Map_ containing the names and values of
the dynamic attributes passed during this invocation. The _Map_ must
contain each dynamic attribute name as the key and the dynamic attribute
value as the corresponding value. Only dynamic attributes with no _uri_
are to be present in the _Map_ ; all other dynamic attributes are
ignored. A translation error will result if there is a tag directive
with a _dynamic-attributes_ attribute equal to the value of a
_name-given_ attribute of a _variable_ directive or equal to the value
of a _name_ attribute of an _attribute_ directive in this translation
unit.

 _small-icon_

(optional) Either a context-relative path, or
a path relative to the tag source file, of an image file containing a
small icon that can be used by tools. Defaults to no small icon.

 _large-icon_

(optional) Either a context-relative path, or
a path relative to the tag source file, of an image file containing a
large icon that can be used by tools. Defaults to no large icon.

 _description_

(optional) Defines an arbitrary string that
describes this tag. Defaults to no description.

 _example_

(optional) Defines an arbitrary string that
presents an informal description of an example of a use of this action.
Defaults to no example.

 _language_

(optional) Carries the same syntax and
semantics of the language attribute of the page directive.

 _import_

(optional) Carries the same syntax and
semantics of the import attribute of the page directive.

 _pageEncoding_

(optional) Carries the same syntax and
semantics of the _pageEncoding_ attribute in the _page_ directive.
However, there is no corresponding global configuration element in
_web.xml_ . The _pageEncoding_ attribute cannot be used in tag files in
XML syntax.

 _isELIgnored_

(optional) Carries the same syntax and
semantics of the _isELIgnored_ attribute of the _page_ directive.
However, there is no corresponding global configuration element in
_web.xml_ .

deferredSyntaxAllowedAsLiteral

(optional) Carries the same syntax and
semantics of the deferredSyntaxAllowedAsLiteral attribute of the _page_
directive. However, there is no corresponding global configuration
element in _web.xml_ . Causes a translation error if specified in a tag
file with a JSP version less than 2.1.

trimDirectiveWhitespaces __

(optional) Carries the same syntax and
semantics of the trimDirectiveWhitespaces attribute of the _page_
directive. However, there is no corresponding global configuration
element in _web.xml_ .

=== [[a2435]]The attribute Directive

The _attribute_ directive is analogous to the
_<attribute>_ element in the Tag Library Descriptor, and allows for the
declaration of custom action attributes.

=== Examples

<%@ attribute name=”x” required=”true”
fragment=”false” +
rtexprvalue=”false” type=”java.lang.Integer” +
description=”The first operand” %>

<%@ attribute name=”y”
type=”java.lang.Integer” %>

<%@ attribute name=”prompt” fragment=”true”
%>

=== Syntax

<%@ attribute attribute_directive_attr_list
%> +
 +
attribute_directive_attr_list ::= +
name=”attribute-name” +
\{ required=”true|false” } +
\{ fragment=”true|false” } +
\{ rtexprvalue=”true|false” } +
\{ type=”type” } +
\{ description=”description” } +
\{ deferredValue=”true|false” } +
\{ deferredValueType=”type” } +
\{ deferredMethod=”true|false” } +
\{ deferredMethodSignature=”signature” }

The details of the attributes are as follows:

=== Details of _attribute_ directive attributes

 _name_

(required) The unique name of the attribute
being declared. A translation error must result if more than one
_attribute_ directive appears in the same translation unit with the same
_name_ . A translation error will result if there is an _attribute_
directive with a _name_ attribute equal to the value of the _name-given_
attribute of a _variable_ directive or the _dynamic-attributes_
attribute of a _tag_ directive in this translation unit.

 _required_

(optional) Whether this attribute is required
( _true_ ) or optional ( _false_ ). Defaults to _false_ if not
specified.

 _fragment_

(optional) Whether this attribute is a
fragment to be evaluated by the tag handler ( _true_ ) or a normal
attribute to be evaluated by the container prior to being passed to the
tag handler. If this attribute is _true_ , the type attribute is fixed
at _j_ _avax.servlet.jsp.tagext.JspFragment_ and a translation error
will result if the _type_ attribute is specified. Also, if this
attribute is _true_ , the _rtexprvalue_ attribute is fixed at _true_ and
a translation error will result if the _rtexprvalue_ attribute is
specified. Defaults to _false_ .

 _rtexprvalue_

(optional) Whether the attribute’s value may
be dynamically calculated at runtime by a scriptlet expression. Unlike
the corresponding TLD element, this attribute defaults to _true_ .

 _type_

(optional) The runtime type of the
attribute’s value. Defaults to _java.lang.String_ if not specified. It
is a translation error to specify a primitive type.

 _description_

(optional) Description of the attribute.
Defaults to no description.

 _deferredValue_

(optional) Whether the attribute's value
represents a deferred value expression. Only one of _deferredValue_ or
_deferredMethod_ may be true. If _deferredValueType_ is specified,
default is true, otherwise default is false. Causes a translation error
if specified in a tag file with a JSP version less than 2.1.

 _deferredValueType_

(optional) The expected type resulting from
the evaluation of the attribute's value expression. If both
_deferredValueType_ and _deferredValue_ are specified, _deferredValue_
must be true. If _deferredValue_ is true, default is _java.lang.Object_
. Causes a translation error if specified in a tag file with a JSP
version less than 2.1.

 _deferredMethod_

(optional) Whether the attribute's value
represents a deferred method expression. Only one of _deferredValue_ or
_deferredMethod_ may be true. If _deferredMethodSignature_ is specified,
default is true, otherwise default is false. Causes a translation error
if specified in a tag file with a JSP version less than 2.1.



 _deferredMethodSignature_

(optional) The signature, as defined in the
Java Language Specification, of the method to be invoked in the
attribute's method expression. If both _deferredMethod_ and
_deferredMethodSignature_ are specified, _deferredMethod_ must be true.
If _deferredMethod_ is true and _deferredMethodSignature_ is not
specified, it defaults to _void methodname()_ . Causes a translation
error if specified in a tag file with a JSP version less than 2.1.



=== The variable Directive

The _variable_ directive is analogous to the
_<variable>_ element in the Tag Library descriptor, and defines the
details of a variable exposed by the tag handler to the calling page.

See link:jsp.html#a2053[See Actions
Defining Scripting Variables.] for more details.

=== Examples

<%@ variable name-given=”sum” +
variable-class=”java.lang.Integer” +
scope=”NESTED” +
declare=”true” +
description=”The sum of the two operands” %>

<%@ variable name-given=”op1” +
variable-class=”java.lang.Integer” +
description=”The first operand” %>

<%@ variable name-from-attribute=”var”
alias=”result” %>

=== Syntax

<%@ variable variable_directive_attr_list
%> +
 +
variable_directive_attr_list ::= +
( name-given=”output-name” +
| ( name-from-attribute=”attr-name” +
alias=”local-name” +
) +
) +
\{ variable-class=”output-type” } +
\{ declare=”true|false” } +
\{ scope=”AT_BEGIN|AT_END|NESTED” } +
\{ description=”description” }

The details of the attributes are as follows:

=== Details of _variable_ directive attributes

 _name-given_

Defines a scripting variable to be defined in
the page invoking this tag. Either the _name-given_ attribute or the
_name-from-attribute_ attribute must be specified. Specifying neither or
both will result in a translation error. A translation error will result
if two _variable_ directives have the same _name-given_ . A translation
error will result if there is a _variable_ directive with a _name-given_
attribute equal to the value of the _name_ attribute of an _attribute_
directive or the _dynamic-attributes_ attribute of a _tag_ directive in
this translation unit.

 _name-from-attribute_

Defines a scripting variable to be defined in
the page invoking this tag. The specified name is the _name_ of an
attribute whose (translation-time) value at of the start of the tag
invocation will give the name of the variable. A translation error will
result if there is no _attribute_ directive with a _name_ attribute
equal to the value of this attribute that is of type _java.lang.String_
, is _required_ and not an _rtexprvalue_ . Either the _name-given_
attribute or the _name-from-attribute_ attribute must be specified.
Specifying neither or both will result in a translation error. A
translation error will result if two variable directives have the same
_name-from-attribute_ .

 _alias_

Defines a locally scoped attribute to hold
the value of this variable. The container will synchronize this value
with the variable whose name is given in _name-from-attribute_ .
Required when _name-from-attribute_ is specified. A translation error
must occur if used without _name-from-attribute_ . A translation error
must occur if the value of _alias_ is the same as the value of a _name_
attribute of an _attribute_ directive or the _alias or name-given_
attribute of a _variable_ directive in the same translation unit.

 _variable-class_

(optional) The name of the class of the
variable. The default is _java.lang.String_ .

 _declare_

(optional) Whether the variable is declared
or not in the calling page/tag file, after this tag invocation. _true_
is the default.

 _scope_

(optional) The scope of the scripting
variable defined. Can be either _AT_BEGIN_ , _AT_END_ , or _NESTED_ .
Defaults to _NESTED_ .

 _description_

(optional) An optional description of this
variable. Defaults to no description.

=== [[a2492]]Tag Files in XML Syntax

Tag files can be authored using the XML
syntax, as described in link:jsp.html#a1794[See JSP Documents.].
This section describes the few distinctions from the case of JSP
documents.

Tag files in XML syntax must have the
extension _.tagx_ . All files with extension _.tagx_ according to the
rules in link:jsp.html#a2348[See Location of Tag Files.] are tag
files in XML syntax. Conversely, files with extension _.tag_ are not in
XML syntax.

The _jsp:root_ element can, but needs not,
appear in tag files in XML syntax. A _jsp:root_ element cannot appear in
a tag file in JSP syntax.

As indicated in
link:jsp.html#a1737[See <jsp:output>.], the default for tag
files, in either syntax, is not to generate the xml declaration. The
element _jsp:output_ can be used to change that default for tag files in
XML syntax.

Finally, the _tag_ directive in a tag file in
XML syntax cannot include a _pageEncoding_ attribute; the encoding is
inferred using the conventions for XML documents. Using the
_pageEncoding_ attribute shall result in a translation-time error.

=== XML View of a Tag File

Similar to JSP pages, tag files have an
equivalent XML document, the XML view of a tag file, that is exposed to
the translation phase for validation. During the translation phase for a
tag file, a tag XML view is created and passed to all TLVs declared in
all tag libraries declared in the tag file.

The XML view of a tag file is identical to
the XML view of a JSP, except that there are additional XML elements
defined to handle tag file specific features. The XML view of a tag file
is obtained in the same way that the XML view of a JSP page is obtained
(see link:jsp.html#a2670[See XML View.]).

=== Implicit Objects

Tag library developers writing tag files have
access to certain implicit objects that are always available for use
within scriptlets and expressions through scripting variables that are
declared implicitly at the beginning of the tag handler implementation.
All scripting languages are required to provide access to these objects.

Each implicit object has a class or interface
type defined in a core Java technology or Java Servlet API package, as
shown in _link:jsp.html#a2504[See Implicit Objects Available in
Tag Files.]_ .

=== [[a2504]]Implicit Objects Available in Tag Files

Variable Name

Type

Semantics & Scope

 _request_

protocol dependent subtype of:
_javax.servlet.ServletRequest_

e.g:

 _javax.servlet.http.HttpServletRequest_

The request triggering the service
invocation.

 _request_ scope.

 _response_

protocol dependent subtype of:
_javax.servlet.ServletResponse,_ e.g:

 _javax.servlet.http.HttpServletResponse_

The response to the request.

 _page_ scope.

jspContext

javax.servlet.jsp.JspContext

The _JspContext_ for this tag file.

page scope.

 _session_

 _javax.servlet.http.HttpSession_

The session object created for the requesting
client (if any).

This variable is only valid for HTTP
protocols.

 _session_ scope

 _application_

 _javax.servlet.ServletContext_

The servlet context obtained from the servlet
configuration object

(as in the call _getServletConfig(). +
getContext()_ )

 _application_ scope

 _out_

 _javax.servlet.jsp.JspWriter_

An object that writes into the output stream.

 _page_ scope

 _config_ __

 _javax.servlet.ServletConfig_

The _ServletConfig_ for this JSP page

 _page_ scope

Object names with prefixes _jsp_ , __jsp_ ,
_jspx_ and __jspx_ , in any combination of upper and lower case, are
reserved by the JSP specification.

=== [[a2542]]Variable Synchronization

Just as is the case for all tag handlers, a
tag file is able to communicate with its calling page via variables. As
mentioned earlier, in tag files, variables are declared using the
_variable_ directive. Though the scopes of variables are similar to
those in classic tag handlers, the semantics are slightly different. The
intent is to be able to emulate IN and OUT parameters using attributes
and variables, which appear as page-scoped attributes local to the tag
file, and are synchronized with the calling page’s _JspContext_ at
various points.

The _name-from-attribute_ and _alias_
attributes of the _variable_ directive can be used to allow the caller
to customize the name of the variable in the calling page while
referring to a constant name in the tag file. When using these
attributes, the name of the variable in the calling page is derived from
the value of _name-from-attribute_ at the time the tag was called. The
name of the corresponding variable in the tag file is the value of
_alias_ .

* IN parameters - Use attributes. For each
attribute, a page-scoped attribute is made available in the _JspContext_
of the tag file. The page-scoped attribute is initialized to the value
of the attribute when the tag is called. No further synchronization is
performed.
* OUT parameters - Use variables with scope
_AT_BEGIN_ or _AT_END_ . For each _AT_BEGIN_ or _AT_END_ variable, a
page-scoped attribute is made available in the _JspContext_ of the tag
file. The scoped attribute is not initialized. Synchronization is
performed at the end of the tag for _AT_BEGIN_ and _AT_END_ and also
before the invocation of a fragment for _AT_BEGIN_ . See
link:jsp.html#a2550[See Variable synchronization behavior.] for
details.
* Nested parameters - Use variables with
scope _AT_BEGIN_ or _NESTED_ . For each _AT_BEGIN_ or _NESTED_ variable,
a page-scoped attribute is made available in the _JspContext_ of the tag
file. The scoped attribute is not initialized. Synchronization is
performed before each fragment invocation for _AT_BEGIN_ and _NESTED_ ,
and also after the end of the tag for _AT_BEGIN_ . See
link:jsp.html#a2550[See Variable synchronization behavior.] for
details.

=== Synchronization Points

The JSP container is required to generate
code to handle the synchronization of each declared variable. The
details of how and when each variable is synchronized varies by the
variable’s scope, as per link:jsp.html#a2550[See Variable
synchronization behavior.].

=== [[a2550]]Variable synchronization behavior



AT_BEGIN

NESTED

AT_END

Beginning of tag file

do nothing

save

do nothing

Before any fragment

image:sp-6.png[image] 

image:sp-7.png[image] 

do nothing

After any fragment

do nothing

do nothing

do nothing

End of tag file

image:sp-8.png[image] 

restore

image:sp-9.png[image] 

The following list describes what each
synchronization action means. If _name-given_ is used, the name of the
variable in the calling page (referred to as P) and the name of the
variable in the tag file (referred to as T) are the same and are equal
to the value of _name-given_ . If _name-from-attribute_ is used, the
name of P is equal to the value of the attribute (at the time the page
was called) specified by the value of _name-from-attribute_ and the name
of T is equal to the value of the _alias_ attribute.

* 

* save - For this variable, save the value of
P, for later restoration. If P did not exist, remember that fact.
* restore - For this variable, restore the
value of P in the calling page, from the value saved earlier. If P did
not exist before, ensure it does not exist now.

All variable synchronization and restoration
that occurs at the end of a tag file must occur regardless of whether an
exception is thrown inside the tag file. All variable synchronization
that occurs after the invocation of a fragment must occur regardless of
whether an exception occured while invoking the fragment.

=== Synchronization Examples

The following examples help illustrate how
variable synchronization works between a tag file and its calling page.

=== Example of AT_BEGIN

In this example, the _AT_BEGIN_ scope is used
to pass a variable to the tag’s body, and make it available to the
calling page at the end of the tag invocation.

<%-- page.jsp --%> +
<%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core” %> +
<%@ taglib prefix=”my” tagdir=”/WEB-INF/tags” %> +
<c:set var=”x” value=”1”/> +
$\{x} <%-- (x == 1) --%> +
<my:example> +
$\{x} <%-- (x == 2) --%> +
<c:set var=”x” value=”3”/> +
</my:example> +
$\{x} <%-- (x == 4) --%>

<%-- /WEB-INF/tags/example.tag --%> +
<%@ variable name-given=”x” scope=”AT_BEGIN” %> +
<%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core” %> +
$\{x} <%-- (x == null) --%> +
<c:set var=”x” value=”2”/> +
<jsp:doBody/> +
$\{x} <%-- (x == 2) --%> +
<c:set var=”x” value=”4”/>

=== Example of AT_BEGIN and name-from-attribute

Like the previous example, in this example
the _AT_BEGIN_ scope is used to pass a variable to the tag’s body, and
make it available to the calling page at the end of the tag invocation.
The name of the attribute is customized via _name-from-attribute_ .

<%-- page.jsp --%> +
<%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core” %> +
<%@ taglib prefix=”my” tagdir=”/WEB-INF/tags” %> +
<c:set var=”x” value=”1”/> +
$\{x} <%-- (x == 1) --%> +
<my:example var=”x”> +
$\{x} <%-- (x == 2) --%> +
$\{result} <%-- (result == null) --%> +
<c:set var=”x” value=”3”/> +
<c:set var=”result” value=”invisible”/> +
</my:example> +
$\{x} <%-- (x == 4) --%> +
$\{result} <%-- (result == ‘invisible’) --%>

<%-- /WEB-INF/tags/example.tag --%> +
<%@ attribute name=”var” required=”true” rtexprvalue=”false”%> +
<%@ variable alias=”result” name-from-attribute=”var” scope=”AT_BEGIN”
%> +
<%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core” %> +
$\{x} <%-- (x == null) --%> +
$\{result} <%-- (result == null) --%> +
<c:set var=”x” value=”ignored”/> +
<c:set var=”result” value=”2”/> +
<jsp:doBody/> +
$\{x} <%-- (x == ‘ignored’) --%> +
$\{result} <%-- (result == 2) --%> +
<c:set var=”x” value=”still_ignored”/> +
<c:set var=”result” value=”4”/>

=== Example of NESTED

In this example, the _NESTED_ scope is used
to make a private variable available to the calling page. The original
value is restored when the tag is done.

<%-- page.jsp --%> +
<%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core” %> +
<%@ taglib prefix=”my” tagdir=”/WEB-INF/tags” %> +
<c:set var=”x” value=”1”/> +
$\{x} <%-- (x == 1) --%> +
<my:example> +
$\{x} <%-- (x == 2) --%> +
<c:set var=”x” value=”3”/> +
</my:example> +
$\{x} <%-- (x == 1) --%>

<%-- /WEB-INF/tags/example.tag --%> +
<%@ variable name-given=”x” scope=”NESTED” %> +
<%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core” %> +
$\{x} <%-- (x == null) --%> +
<c:set var=”x” value=”2”/> +
<jsp:doBody/> +
$\{x} <%-- (x == 2) --%> +
<c:set var=”x” value=”4”/>

=== Example of AT_END

In this example, the AT_END scope is used to
return a value to the page. The body of the tag is not affected.

<%-- page.jsp --%> +
<%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core” %> +
<%@ taglib prefix=”my” tagdir=”/WEB-INF/tags” %> +
<c:set var=”x” value=”1”/> +
$\{x} <%-- (x == 1) --%> +
<my:example> +
$\{x} <%-- (x == 1) --%> +
<c:set var=”x” value=”3”/> +
</my:example> +
$\{x} <%-- (x == 4) --%>

<%-- /WEB-INF/tags/example.tag --%> +
<%@ variable name-given=”x” scope=”AT_END” %> +
<%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core” %> +
$\{x} <%-- (x == null) --%> +
<c:set var=”x” value=”2”/> +
<jsp:doBody/> +
$\{x} <%-- (x == 2) --%> +
<c:set var=”x” value=”4”/>

=== Example of Removing Parameters

This example illustrates how the tag file can
remove objects from the page scope of the calling page during
synchronization.

<%-- page.jsp --%> +
<%@ taglib prefix=”my” tagdir=”/WEB-INF/tags” %> +
<%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core” %> +
<c:set var=”x” value=”2”/> +
$\{x} +
<my:tag1> +
‘$\{x}’ +
</my:tag1> +
$\{x} +
 +
<%-- /WEB-INF/tags/example.tag --%> +
<%@ variable name-given=”x” scope=”NESTED” %> +
<%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core” %> +
<c:set var=”x” value=”1”/> +
<jsp:doBody/> +
<c:remove var=”x”/> +
<jsp:doBody/>

The expected output of this example is: 2 ‘1’
‘’ 2

== CHAPTER 8 - 

=== [[a2599]]Scripting

This chapter describes the details of the
Scripting Elements when the language directive value is _java_ .

The scripting language is based on the Java
programming language (as specified by “The Java Language
Specification”), but note that there is no valid JSP page, or a subset
of a page, that is a valid Java program.

The following sections describe the details
of the relationship between the scripting declarations, scriptlets, and
scripting expressions, and the Java programming language. The
description is in terms of the structure of the JSP page implementation
class. A JSP Container need not generate the JSP page implementation
class, but it must behave as if one exists.

=== Overall Structure

Some details of what makes a JSP page legal
are very specific to the scripting language used in the page. This is
especially complex since scriptlets _are language_ fragments, not
complete language statements.

=== [[a2605]]Valid JSP Page

A JSP page is valid for a Java Platform if and
only if the JSP page implementation class defined by
link:jsp.html#a2611[See The transformations described in this
chapter need not be performed literally. An implementation may implement
things differently to provide better performance, lower memory
footprint, or other implementation attributes..]
link:jsp.html#a2612[See Structure of the JavaProgramming
Language Class.] (after applying all include directives), together with
any other classes defined by the JSP container, is a valid program for
the given Java Platform, and if it passes the validation methods for all
the tag libraries associated with the JSP page.

=== [[a2607]]Reserved Names

Sun Microsystems reserves all names of the
form _\{_}jsp_*_ and _\{_}jspx_*_ , in any combination of upper and
lower case, for the JSP specification. Names of this form that are not
defined in this specification are reserved by Sun for future expansion.

=== Implementation Flexibility

The transformations described in this chapter
need not be performed literally. An implementation may implement things
differently to provide better performance, lower memory footprint, or
other implementation attributes.[[a2611]]

=== [[a2612]]Structure of the JavaProgramming Language Class

Optional imports clause as indicated via
_jsp_ directive

 _import name1_

 _SuperClass_ is either selected by the JSP
container or by the JSP author via the _jsp_ directive.

Name of class ( __jspXXX_ ) is implementation
dependent.

 _class _jspXXX extends SuperClass_

Start of the body of a JSP page
implementation class

 _\{_

(1) Declaration Section

 _// declarations..._

signature for generated method

 _public void
_jspService(<ServletRequestSubtype> request, +
<ServletResponseSubtype> response) +
throws ServletException, IOException \{_

 __ 

(2) Implicit Objects Section



 _// code that defines and initializes
request, response, page, pageContext etc._

(3) Main Section

 _// code that defines request/response
mapping_

close of __jspService_ method

 _}_

close of __jspXXX_

 _}_

=== Declarations Section

The declarations section corresponds to the
declaration elements.

The contents of this section is determined by
concatenating all the declarations in the page in the order in which
they appear.

=== Initialization Section

This section defines and initializes the
implicit objects available to the JSP page. See
link:jsp.html#a702[See Implicit Objects.].

=== Main Section

This section provides the main mapping between
a request and a response object.

The content of code segment 2 is determined
from scriptlets, expressions, and the text body of the JSP page. The
elements are processed sequentially in the order in which they appear in
the page. The translation for each one is determined as indicated below,
and its translation is inserted into this section. The translation
depends on the element type:

=== Template Data

Template data is transformed into code that
will place the template data into the stream named by the implicit
variable _out_ when the code is executed. White space is preserved.

Ignoring quotation issues and performance
issues, this corresponds to a statement of the form:

[width="100%",cols="50%,50%",]
|===
|Original
|Equivalent Text

| _template_ |
_out.print(template)_
|===

=== Scriptlets

A scriptlet is transformed into its code
fragment.:

[width="100%",cols="50%,50%",]
|===
|Original
|Equivalent Text

| _<% fragment %>_
| _fragment_
|===

=== Expressions

An expression is transformed into a Java
statement to insert the value of the expression, converted to
_java.lang.String_ if needed, into the stream named by the implicit
variable _out_ . No additional newlines or space is included.

Ignoring quotation and performance issues,
this corresponds to a statement of the form:

[width="100%",cols="50%,50%",]
|===
|Original
|Equivalent Text

| _<%= expression %>_
| _out.print(expression)_
|===

=== Actions

An action defining one or more objects is
transformed into one or more variable declarations for those objects,
together with code that initializes the variables. Their visibility is
affected by other constructs, for example scriptlets.

The semantics of the action type determines
the names of the variables (usually the name of an _id_ attribute, if
present) and their type. The only standard action in the JSP
specification that defines objects is the _jsp:useBean_ action. The name
of the variable introduced is the name of the _id_ attribute and its
type is the type of the _class_ attribute.

[width="100%",cols="50%,50%",]
|===
|Original
|Equivalent Text

| _<x:tag> +
foo +
</x:tag>_ | _declare AT_BEGIN variables +
\{ +
declare NESTED variables +
transformation of foo +
} +
declare AT_END variables_
|===

Note that the value of the _scope_ attribute
does not affect the visibility of the variables within the generated
program. It affects where and thus for how long there will be additional
references to the object denoted by the variable.

== CHAPTER 9 - 

=== [[a2670]]XML View

This chapter provides details on the XML
view of a JSP page and tag files. The XML views are used to enable
validation of JSP pages and tag files..

=== XML View of a JSP Document, JSP Page or Tag File

This section describes the XML view of a JSP
page or tag file: the mapping between a JSP page, JSP document or tag
file, and an XML document describing it.

=== JSP Documents and Tag Files in XML Syntax

The XML view of a JSP document or of a tag
file written in XML syntax is very close to the original JSP page. Only
five transformations are performed:

* Expand all include directives into the JSP
content they include. See link:jsp.html#a907[See Including Data
in JSP Pages.] for the semantics of mixing XML and standard syntax
content.
* Add a _jsp:root_ element as the root
element if the JSP document or tag file in XML syntax does not have it.
* Set the value of the _pageEncoding_
attribute of the page directive to " _UTF-8_ ". The _page_ directive and
the _pageEncoding_ attribute are added if they don’t exist already.
* Set the value of the _contentType_
attribute of the _page_ directive to the value that the container will
pass to _ServletResponse.setContentType()_ , determined as described in
/C:/jspspec/JSP_I18N.html#52032[]. The _page_ directive and the
_contentType_ attribute are added if they don’t exist already.
* Add the _jsp:id_ attribute (see
link:jsp.html#a2816[See The jsp:id Attribute.]).

=== JSP Pages or Tag Files in JSP Syntax

The XML view of a JSP page or tag file
written in standard syntax is defined by the following transformation:

* Expand all include directives into the JSP
content they include. See /C:/jspspec/JSP_Syntax.html#30346[] for the
semantics of mixing XML and standard syntax content.
* Add a _jsp:root_ element as the root, with
appropriate _xmlns:jsp_ attribute, and convert the _taglib_ directive
into _xmlns:_ attributes of the _jsp:root_ element.
* Convert declarations, scriptlets, and
expressions into valid XML elements as described in
/C:/jspspec/JSP_Documents.html#96582[] and the following sections.
* Convert request-time attribute expressions
as in link:jsp.html#a2756[See Request-Time Attribute
Expressions.].
* Convert JSP quotations to XML quotations.
* Create _jsp:text_ elements for all template
text.
* Add the _jsp:id_ attribute (see
link:jsp.html#a2816[See The jsp:id Attribute.]).

Note that the XML view of a JSP page or tag
file has no _DOCTYPE_ information; see link:jsp.html#a2835[See
Validating an XML View of a JSP page.].

A quick overview of the transformation is
shown in link:jsp.html#a2692[See XML View Transformations.]:

=== [[a2692]]XML View Transformations

JSP element

XML view

 _<%-- comment --%>_

removed

 _<%@ page ... %>_

 _<jsp:directive.page ... />_ . Add _jsp:id_

 _<%@ taglib ... %>_

 _jsp:root_ element is annotated with
namespace information. Add _jsp:id_ .

 _<%@ include ... %>_

 _expanded in place_

 _<%! ... %>_

 _<jsp:declaration> ... </jsp:declaration>_ .
Add _jsp:id_ .

 _<% ... %>_

 _<jsp:scriptlet> ... </jsp:scriptlet>_ _._
Add __ _jsp:id_ _._

 _<%= ... %>_

 _<jsp:expression> ... </jsp:expression>_ _._
Add __ _jsp:id_ _._

Standard action

Replace with XML syntax (adjust request-time
expressions; add _jsp:id_ )

Custom action

As is (adjust request-time expressions; add
_jsp:id_ )

template

Replace with _jsp:text_ . Add _jsp:id_ .

 _<%@ tag ... %>_

{empty} _<jsp:directive.tag ... />_ . Add
_jsp:id._ [tag files only]

 _<%@ attribute ... %>_

{empty} _<jsp:directive.attribute ... />_ .
Add _jsp:id._ [tag files only]

 _<%@ variable ... %>_

{empty} _<jsp:directive.variable ... />_ .
Add _jsp:id._ [tag files only]

In more detail:

=== JSP Comments

JSP comments (of the form _<%-- comment --%>_
) are not passed through to the XML view of a JSP page.

=== The page Directive

A _page_ directive of the form:

<%@ page \{ attr=”value” }* %>

is translated into an element of the form:

<jsp:directive.page \{ attr=”value” }* />

The value of the _pageEncoding_ attribute is
set to " _UTF-8_ ". The value of the _contentType_ attribute is set to
the value that the container will pass to
ServletResponse.setContentType(), determined as described in
/C:/jspspec/JSP_I18N.html#52032[]. The _page_ directive and both
attributes are added if they don’t exist already.

=== The taglib Directive

A taglib directive of the form

<%@ taglib uri=” _uriValue_ ” prefix=”
_prefix_ ” %>

is translated into an _xmlns:prefix_
attribute on the root of the JSP document, with a value that depends on
_uriValue_ . If _uriValue_ is a relative path, then the value used is
_urn:jsptld:_ _uriValue_ ; otherwise, the _uriValue_ is used directly.

A taglib directive of the form

<%@ taglib tagdir=” _tagDirValue_ ” prefix=”
_prefix_ ” %>

is translated into an _xmlns:prefix_
attribute on the root of the JSP document, with a value of the form
_urn:jsptagdir:_ _tagDirValue_ .

=== The include Directive

An include directive of the form

<%@ include file=” _value_ ” %>

is expanded into the JSP content indicated by
_value_ . This is done to allow for validation of the page.

=== Declarations

Declarations are translated into a
_jsp:declaration_ element. For example, the second example from
/C:/jspspec/JSP_Syntax.html#36319[]:

<%! public String f(int i) \{ if (i<3)
return(“...”); ... } %>

is translated into the following.

<jsp:declaration> <![CDATA[ public String
f(int i) \{ if (i<3) return(“...”); } ]]> </jsp:declaration>

Alternatively, we could use an _&lt;_ and
instead say:

<jsp:declaration> public String f(int i) \{
if (i&lt;3) return(“...”); } </jsp:declaration>

=== Scriptlets

Scriptlets are translated into a
_jsp:scriptlet_ element. In the XML document corresponding to JSP pages,
directives are represented using the syntax:

<jsp:scriptlet> code fragment goes here
</jsp:scriptlet>

=== Expressions

In the XML document corresponding to JSP
pages, directives are represented using the _jsp:expression_ element:

<jsp:expression> expression goes here
</jsp:expression>

=== Standard and Custom Actions

The syntax for both standard and action
elements is based on XML. The transformations needed are due to quoting
conventions and the syntax of request-time attribute expressions.

=== [[a2756]]Request-Time Attribute Expressions

Request-time attribute expressions are of the
form _<%= expression %>_ . Although this syntax is consistent with the
syntax used elsewhere in a JSP page, it is not a legal XML syntax. The
XML mapping for these expressions is into values of the form _%=
expression %_ , where the JSP specification quoting convention has been
converted to the XML quoting convention.

Request-time attribute values can also be
specified using EL expressions of the form _$\{expression}_ .
Expressions of this form are represented verbatim in the XML view.

The XML view of an escaped EL expression
using the $\{expr} syntax can be obtained as follows:

* The XML view of an unescaped expression
_$\{foo}_ is _$\{foo}_ .
* The XML view of an escaped expression
_\$\{foo}_ is _\$\{foo}_ .
* For each escaped _\_ preceeding an
unescaped expression _$\{foo}_ , a _$\{’\\’}_ must be generated in the
XML view, and neighboring generated _$\{’\\’}_ expressions must be
combined.

link:jsp.html#a2764[See XML View of
an Escaped EL Expression in a Request-time Attribute Value.] illustrates
these rules. Assume the EL expression _$\{foo}_ evaluates to _[bar]_ and
that EL is enabled for this translation unit.

=== [[a2764]]XML View of an Escaped EL Expression in a Request-time Attribute Value

Attribute Value

XML View

Result

 _$\{foo}_

 _$\{foo}_

 _[bar]_

 _\$\{foo}_

 _\$\{foo}_

 _$\{foo}_

 _\\$\{foo}_

 _$\{’\\’}$\{foo}_

 _\[bar]_

 _\\\$\{foo}_

 _\\$\{foo}_

 _\$\{foo}_

 _\\\\$\{foo}_

 _$\{’\\\\’}$\{foo}_

 _\\[bar]_

 _\\\\\$\{foo}_

 _\\\$\{foo}_

 _\\$\{foo}_

 _\\\\\\$\{foo}_

 _$\{’\\\\\\’}$\{foo}_

 _\\\[bar]_

...

...

...

The XML view of an escaped EL expression
using the _#\{expr}_ syntax follows the same rules as the _$\{expr}_
syntax, where _$\{_ is simply substituted with _#\{_ .

=== [[a2793]]Template Text and XML Elements

All text that is uninterpreted by the JSP
translator is converted into the body for a _jsp:text_ element. As a
consequence no XML elements of the form described in
/C:/jspspec/JSP_Documents.html#16239[] will appear in the XML view of a
JSP page written in JSP syntax.

Because _\\_ is not an escape sequence within
template text in the standard syntax, no special transformation needs to
be done to obtain the XML view of an escaped EL expression that appears
in template text.

link:jsp.html#a2797[See XML View of
an Escaped EL Expression in Template Text.] illustrates how the XML view
of an escaped EL expression is obtained. Assume the EL expression
_$\{foo}_ evaluates to _[bar]_ and that EL is enabled for this
translation unit.The same rules apply for the #\{expr} syntax, where
_$\{_ is simply substituted with _#\{_ .

=== [[a2797]]XML View of an Escaped EL Expression in Template Text

Attribute Value

XML View

Result

 _$\{foo}_

 _$\{foo}_

 _[bar]_

 _\$\{foo}_

 _\$\{foo}_

 _$\{foo}_

 _\\$\{foo}_

 _\\$\{foo}_

 _\$\{foo}_

 _\\\$\{foo}_

 _\\\$\{foo}_

 _\\$\{foo}_

...

...

...

=== [[a2816]]The jsp:id Attribute

A JSP container must support a _jsp:id_
attribute. This attribute can only be present in the XML view of a JSP
page and can be used to improve the quality of translation time error
messages.

The XML view of any JSP page will have an
additional _jsp:id_ attribute added to all XML elements. This attribute
is given a value that is unique over all elements in the XML view. The
prefix for the _id_ attribute need not be " _jsp_ " but it must map to
the namespace _http://java.sun.com/JSP/Page_ . In the case where the
page author has redefined the _jsp_ prefix, an alternative prefix must
be used by the container. See
/C:/jspspec/javax.servlet.jsp.tagext.html#20465[] for more details.

=== [[a2819]]The tag Directive

The _tag_ directive is applicable to tag
files only. A _tag_ directive of the form:

<%@ tag \{ attr=”value” }* %>

is translated into an element of the form:

<jsp:directive.tag \{ attr=”value” }* />

The value of the _pageEncoding_ attribute is
set to " _UTF-8_ ". A _tag_ directive and the _pageEncoding_ attribute
are added if they don’t exist already.

=== [[a2825]]The attribute Directive

The _attribute_ directive is applicable to
tag files only. An _attribute_ directive of the form:

<%@ attribute \{ attr=”value” }* %>

is translated into an element of the form:

<jsp:directive.attribute \{ attr=”value” }*
/>

=== [[a2830]]The variable Directive

The _variable_ directive is applicable to tag
files only. A _variable_ directive of the form:

<%@ variable \{ attr=”value” }* %>

is translated into an element of the form:

<jsp:directive.variable \{ attr=”value” }* />

=== [[a2835]]Validating an XML View of a JSP page

The XML view of a JSP page is a
namespace-aware document and it cannot be validated against a DTD except
in the most simple cases. To reduce confusion and possible unintended
performance consequences, the XML view of a JSP page will not include a
_DOCTYPE_ .

There are several mechanisms that are aware
of namespaces that can be used to do validation of XML views of JSP
pages. The most popular mechanism is the W3C XML Schema language, but
others are also suited, including some very simple ones that may check,
for example, that only some elements are being used, or, inversely, that
they are not used. The _TagLibraryValidator_ for a tag library permits
encapsulating this knowledge with a tag library.

The _TagLibraryValidator_ acts on the XML
view of the JSP page. If the page was authored in JSP syntax, that view
does not provide any detail on template data (all being grouped inside
jsp:text elements), but fine detail can be described when using JSP
documentslink:#a6614[4].

=== Examples

This section presents various examples of XML
Views. The first shows a JSP page in XML syntax that includes XML
fragments. The second shows a JSP page in JSP syntax and its mapping to
XML syntax. The three following examples illustrate the semantics of
cross-syntax translation-time includes and the effect on the XML View.

=== A JSP document

This is an example of a very simple JSP
document that has some template XML elements. This particular example
describes a table that is a collection of 3 rows, with numeric values 1,
2, 3. The JSP Standard Tag Library is being used:

<?xml version="1.0"?> +
<table> +
<c:forEach +
xmlns:c="http://java.sun.com/jsp/jstl/core" +
var="counter" begin="1" end="3"> +
<row>$\{counter}</row> +
</c:forEach> +
</table>

=== A JSP page and its corresponding XML View

Here is an example of mapping between JSP and
XML syntax.

For this JSP page:

<html> +
<title>positiveTagLib</title> +
<body> +
 +
<%@ taglib uri="http://java.apache.org/tomcat/examples-taglib"
prefix="eg" %> +
<%@ taglib uri="/tomcat/taglib" prefix="test" %> +
<%@ taglib uri="WEB-INF/tlds/my.tld" prefix="temp" %> +
 +
<eg:test toBrowser="true" att1="Working"> +
Positive Test taglib directive </eg:test> +
</body> +
</html>

The XML View of the previous page is:

<jsp:root
xmlns:jsp="http://java.sun.com/JSP/Page" +
xmlns:eg="http://java.apache.org/tomcat/examples-taglib" +
xmlns:test="urn:jsptld:/tomcat/taglib" +
xmlns:temp="urn:jsptld:/WEB-INF/tlds/my.tld"> +
 +
<jsp:text><![CDATA[<html> +
<title>positiveTagLib</title> +
<body> +
 +
 +
 +
 +
 +
]]></jsp:text> +
<eg:test toBrowser="true" att1="Working"> +
<jsp:text>Positive test taglib directive</jsp:text> +
</eg:test> +
<jsp:text><![CDATA[ +
</body> +
</html> +
]]></jsp:text> +
</jsp:root>

=== Clearing Out Default Namespace on Include

This example illustrates the need to clear
out the default namespace when doing a translation-time include of a JSP
document:

<!-- a.jspx --> +
<elementA> +
<tagB xmlns="http://namespace1"> +
<jsp:directive.include file="b.jspx" +
xmlns:jsp="http://java.sun.com/JSP/Page" /> +
</tagB> +
</elementA>

<!-- b.jspx --> +
<elementC />

The resulting XML View for these two JSP
documents is:

<jsp:root
xmlns:jsp="http://java.sun.com/JSP/Page"> +
<elementA> +
<tagB xmlns="http://namespace1"> +
<elementC /> +
</tagB> +
</elementA> +
</jsp:root>

=== Taglib Direcive Adds to Global Namespace

This example illustrates the effect of the
taglib directive on the XML View. Notice how the taglib directive always
affects the _<jsp:root>_ element, independent of where it is
encountered.

<!-- c.jspx --> +
<elementD xmlns:jsp="http://java.sun.com/JSP/Page"> +
<jsp:directive.include file="d.jsp" /> +
<jsp:directive.include file="e.jsp" /> +
</elementD>

<%-- d.jsp --%> +
<%@ taglib prefix="x" uri="http://namespace2" %> +
<x:tagE />

<%-- e.jsp --%> +
<x:tagE />

The resulting XML View of these documents and
pages is:

<jsp:root xmlns:x="http://namespace2" +
xmlns:jsp="http://java.sun.com/JSP/Page" > +
<elementD> +
<x:tagE /> +
<x:tagE /> +
</elementD> +
</jsp:root>

=== Collective Application of Inclusion Semantics

This example illustrates how the various
translation-time include semantics are collectively applied:

<%-- f.jsp --%> +
<%@ taglib prefix="m" uri="http://namespace3" %> +
<%@ include file="g.jspx" %>

<!-- g.jspx --> +
<tagF xmlns="http://namespace4" > +
<y:tagG xmlns:y="http://namespace5"> +
<tagH /> +
<jsp:directive.include file="i.jspx" +
xmlns:jsp="http://java.sun.com/JSP/Page" /> +
</y:tagG> +
<jsp:directive.include file="h.jsp" +
xmlns:jsp="http://java.sun.com/JSP/Page" /> +
<tagI /> +
</tagF>

<%-- h.jsp --%> +
<%@ taglib prefix="n" uri="http://namespace6" %> +
<m:tagJ /> +
<n:tagK />

<!-- i.jspx --> +
<jsp:root xmlns:jsp="http://java.sun.com/JSP/Page"> +
<y:tagL xmlns:y="http://namespace7"> +
<elementM /> +
<jsp:directive.include file="h.jsp" /> +
</y:tagL> +
</jsp:root>

The resulting XML View of these documents and
pages is:

<jsp:root xmlns:m="http://namespace3" +
xmlns:n="http://namespace6" +
xmlns:jsp="http://java.sun.com/JSP/Page" > +
<tagF xmlns="http://namespace4"> +
<y:tagG xmlns:y="http://namespace5"> +
<tagH /> +
<y:tagL xmlns="" xmlns:y="http://namespace7"> +
<elementM /> +
<m:tagJ /> +
<n:tagK /> +
</y:tagL> +
</y:tagG> +
<m:tagJ /> +
<n:tagK /> +
<tagI /> +
</tagF> +
</jsp:root>

=== [[a2871]]Part II

 __ 

The next chapters provide detail
specification information on some portions of the JSP specification that
are intended for JSP Container Vendors, JSP Page authors, and JSP Tag
Library authors.

The chapters are normative.

The chapters are

* JSP Container
* Core API
* Tag Extension API
* Expression Language API

== CHAPTER 10 - 

=== [[a2881]]JSP Container

This chapter describes the contracts
between a JSP container and a JSP page, including the precompilation
protocol and debugging support requirements.

The information in this chapter is
independent of the Scripting Language used in the JSP page.
link:jsp.html#a2599[See Scripting.] describes information
specific to when the _language_ attribute of the _page_ directive has
_java_ as its value.).

JSP page implementation classes should use
the _JspFactory_ and _PageContext_ classes to take advantage of
platform-specific implementations.

=== [[a2885]]JSP Page Model

A JSP page is represented at execution time by
a JSP page implementation object and is executed by a JSP container. The
JSP page implementation object is a servlet. The JSP container delivers
requests from a client to a JSP page implementation object and responses
from the JSP page implementation object to the client.

The JSP page describes how to create a
response object from a request object for a given protocol, possibly
creating and/or using some other objects in the process . A JSP page may
also indicate how some events are to be handled. In JSP 2.2 only _init_
and _destroy_ events are allowed events.

The JSP container must render a JSP page for
the HTTP methods GET, POST, and HEAD, with identical responses. The
behavior of the JSP container is undefined for other methods

=== Protocol Seen by the Web Server

The JSP container locates the appropriate
instance of the JSP page implementation class and delivers requests to
it using the servlet protocol. A JSP container may need to create such a
class dynamically from the JSP page source before delivering request and
response objects to it.

The _Servlet_ class defines the contract
between the JSP container and the JSP page implementation class. When
the HTTP protocol is used, the contract is described by the
_HttpServlet_ class. Most JSP pages use the HTTP protocol, but other
protocols are allowed by this specification.

The JSP container automatically makes a
number of server-side objects available to the JSP page implementation
object . See link:jsp.html#a702[See Implicit Objects.].

=== Protocol Seen by the JSP Page Author

The JSP specification defines the contract
between the JSP container and the JSP page author. This contract defines
the assumptions an author can make for the actions described in the JSP
page.

The main portion of this contract is the
__jspService_ method that is generated automatically by the JSP
container from the JSP page. The details of this contract are provided
in link:jsp.html#a2599[See Scripting.].

The contract also describes how a JSP author
can indicate what actions will be taken when the _init_ and _destroy_
methods of the page implementation occur. In JSP 2.2 this is done by
defining methods with the names _jspInit_ and _jspDestroy_ in a
declaration scripting element in the JSP page. The _jspInit_ method, if
present, will be called to prepare the page before the first request is
delivered. Similarly a JSP container can reclaim resources used by a JSP
page when a request is not being serviced by the JSP page by invoking
its _jspDestroy_ method, if present.

A JSP page author may not (re)define servlet
methods through a declaration scripting element.

The JSP specification reserves names for
methods and variables starting with _jsp_ , __jsp_ , _jspx_ , and
__jspx_ , in any combination of upper and lower case.

=== The HttpJspPage Interface

The enforcement of the contract between the
JSP container and the JSP page author is aided by the requirement that
the _Servlet_ class corresponding to the JSP page must implement the
_javax.servlet.jsp.HttpJspPage_ interface (or the
_javax.servlet.jsp.JspPage_ interface if the protocol is not HTTP).

=== 

image:sp-11.png[image]

=== [[a2902]]Contracts between a JSP Page and a JSP Container.

The involved contracts are shown in
_link:jsp.html#a2902[See Contracts between a JSP Page and a JSP
Container..]_ . We now revisit this whole process in more detail.

=== JSP Page Implementation Class

The JSP container creates a JSP page
implementation class for each JSP page.

The name of the JSP page implementation class
is implementation dependent.

The JSP Page implementation object belongs to
an implementation-dependent named package. The package used may vary
between one JSP and another, so minimal assumptions should be made.

As of JSP 2.0, it is illegal to refer to any
classes from the unnamed (a.k.a. default) package. This may result in a
translation error on some containers, specifically those that run in a
JDK 1.4 or greater environment. It is unfortunate, but unavoidable, that
this will break compatibility with some older JSP applications. However,
as of JDK 1.4, importing classes from the unnamed package is not valid
(see http://java.sun.com/j2se/1.4/compatibility.html#source for
details). Therefore, for forwards compatibility, applications must not
rely on the unnamed package. This restriction also applies for all other
cases where classes are referenced, such as when specifying the class
name for a tag in a TLD.

The JSP container may create the
implementation class for a JSP page, or a superclass may be provided by
the JSP page author through the use of the _extends_ attribute in the
_page_ directive.

The extends mechanism is available for
sophisticated users. It should be used with extreme care as it restricts
decisions that a JSP container can make. It may restrict efforts to
improve performance, for example.

The JSP page implementation class will
implement _javax.servlet.Servlet_ and requests are delivered to the
class as per the rules in the Servlet 2.5 specification.

A JSP page implementation class may depend on
support classes. If the JSP page implementation class is packaged into a
WAR, any dependent classes will have to be included so it will be
portable across all JSP containers.

A JSP page author writes a JSP page expecting
that the client and the server will communicate using a certain
protocol. The JSP container must guarantee that requests to and
responses from the page use that protocol. Most JSP pages use HTTP, and
their implementation classes must implement the _HttpJspPage_ interface,
which extends _JspPage_ . If the protocol is not HTTP, then the class
will implement an interface that extends _JspPage_ .

=== API Contracts

The contract between the JSP container and a
Java class implementing a JSP page corresponds to the _Servlet_
interface. Refer to the Servlet 2.5 specification for details.

The responsibility for adhering to this
contract rests on the JSP container implementation if the JSP page does
not use the _extends_ attribute of the _jsp_ directive. If the _extends_
attribute of the _jsp_ directive is used, the JSP page author must
guarantee that the superclass given in the extends attribute supports
this contract.[[a2917]]

=== [[a2918]]How the JSP Container Processes JSP Pages

Methods the JSP Container Invokes

Comments

 _void jspInit()_

Method is optionally defined in JSP page.

Method is invoked when the JSP page is
initialized.

When method is called all the methods in
_servlet_ , including _getServletConfig_ are available

 _void jspDestroy()_

Method is optionally defined in JSP page.

Method is invoked before destroying the page.

 _void _jspService(<ServletRequestSubtype>,
<ServletResponseSubtype>) throws +
IOException, ServletException_

Method may not be defined in JSP page.

The JSP container automatically generates
this method, based on the contents of the JSP page.

Method invoked at each client request.

=== Request and Response Parameters

As shown in link:jsp.html#a2918[See
How the JSP Container Processes JSP
Pages.]link:jsp.html#a2917[See The responsibility for adhering
to this contract rests on the JSP container implementation if the JSP
page does not use the extends attribute of the jsp directive. If the
extends attribute of the jsp directive is used, the JSP page author must
guarantee that the superclass given in the extends attribute supports
this contract..], the methods in the contract between the JSP container
and the JSP page require request and response parameters.

The formal type of the request parameter
(which this specification calls _<_ _ServletRequestSubtype_ _>_ ) is an
interface that extends _javax.servlet.ServletRequest_ . The interface
must define a protocol-dependent request contract between the JSP
container and the class that implements the JSP page.

Likewise, the formal type of the response
parameter (which this specification calls _<_ _ServletResponseSubtype_
_>_ ) is an interface that extends _javax.servlet.ServletResponse_ . The
interface must define a protocol-dependent response contract between the
JSP container and the class that implements the JSP page.

The request and response interfaces together
describe a protocol-dependent contract between the JSP container and the
class that implements the JSP page. The HTTP contract is defined by the
_javax.servlet.http.HttpServletRequest_ and
_javax.servlet.http.HttpServletResponse_ interfaces.

The _JspPage_ interface refers to these
methods, but cannot describe syntactically the methods involving the
_Servlet(Request,Response)_ subtypes. However, interfaces for specific
protocols that extend _JspPage_ can, just as _HttpJspPage_ describes
them for the HTTP protocol.

JSP containers that conform to this
specification (in both JSP page implementation classes and JSP container
runtime) must support the _request_ and _response_ interfaces for the
HTTP protocol as described in this section.

=== Omitting the extends Attribute

If the _extends_ attribute of the _page_
directive (see Section link:jsp.html#a770[See The page
Directive.]) in a JSP page is not used, the JSP container can generate
any class that satisfies the contract described in
link:jsp.html#a2918[See How the JSP Container Processes JSP
Pages.],link:jsp.html#a2917[See The responsibility for adhering
to this contract rests on the JSP container implementation if the JSP
page does not use the extends attribute of the jsp directive. If the
extends attribute of the jsp directive is used, the JSP page author must
guarantee that the superclass given in the extends attribute supports
this contract..] when it transforms the JSP page.

In the following code examples,
link:jsp.html#a2942[See A Generic HTTP Superclass.] illustrates
a generic HTTP superclass named _ExampleHttpSuper_ .
_link:jsp.html#a2949[See The Java Class Generated From a JSP
Page.]_ shows a subclass named __jsp1344_ that extends
_ExampleHttpSuper_ and is the class generated from the JSP page. By
using separate __jsp1344_ and _ExampleHttpSuper_ classes, the JSP page
translator does not need to discover whether the JSP page includes a
declaration with _jspInit_ or _jspDestroy_ . This significantly
simplifies the implementation.

=== [[a2942]]A Generic HTTP Superclass

imports javax.servlet.*; +
imports javax.servlet.http.*; +
imports javax.servlet.jsp.*; +
 +
/** +
* An example of a superclass for an HTTP JSP class +
*/ +
 +
abstract class ExampleHttpSuper implements HttpJspPage \{ +
private ServletConfig config; +
 +
final public void init(ServletConfig config) throws ServletException
\{ +
this.config = config; +
jspInit(); +
} +
 +
public void jspInit() \{ +
} +
 +
public void jspDestroy() \{ +
}

}

final public ServletConfig getServletConfig()
\{ +
return config; +
}

// This one is not final so it can be
overridden by a more precise method +
public String getServletInfo() \{ +
return “A Superclass for an HTTP JSP”; // maybe better? +
}

final public void destroy() \{ +
jspDestroy(); +
} +
 +
/** +
* The entry point into service. +
*/ +
 +
final public void service(ServletRequest req, ServletResponse res) +
throws ServletException, IOException \{ +
 +
// casting exceptions will be raised if an internal error. +
HttpServletRequest request = (HttpServletRequest) req; +
HttpServletResponse response = (HttpServletResponse) res; +
 +
_jspService(request, response); +
} +
 +
/** +
* abstract method to be provided by the JSP processor in the subclass +
* Must be defined in subclass. +
*/ +
 +
abstract public void _jspService(HttpServletRequest request, +
HttpServletResponse response) throws ServletException, IOException;

}

=== [[a2949]]The Java Class Generated From a JSP Page

imports javax.servlet.*; +
imports javax.servlet.http.*; +
imports javax.servlet.jsp.*; +
 +
/** +
* An example of a class generated for a JSP. +
* +
* The name of the class is unpredictable. +
* We are assuming that this is an HTTP JSP page (like almost all are) +
*/ +
 +
class _jsp1344 extends ExampleHttpSuper \{ +
 +
// Next code inserted directly via declarations. +
// Any of the following pieces may or not be present +
// if they are not defined here the superclass methods +
// will be used. +
 +
public void jspInit() \{....} +
public void jspDestroy() \{....} +
 +
// The next method is generated automatically by the +
// JSP processor. +
// body of JSP page +
 +
public void _jspService(HttpServletRequest request, +
HttpServletResponse response) +
throws ServletException, IOException \{ +
 +
// initialization of the implicit variables +
// ... +
 +
// next is code from scriptlets, expressions, and static text. +
 +
} +
 +
}

=== Using the extends Attribute

If the JSP page author uses _extends_ , the
generated class is identical to the one shown in
link:jsp.html#a2949[See The Java Class Generated From a JSP
Page.], except that the class name is the one specified in the _extends_
attribute.

The contract on the JSP page implementation
class does not change. The JSP container should check (usually through
reflection) that the provided superclass:

* Implements _HttpJspPage_ if the protocol is
HTTP, or _JspPage_ otherwise.
* All of the methods in the _Servlet_
interface are declared final.

Additionally, it is the responsibility of the
JSP page author that the provided superclass satisfies:

* The _service_ method of the servlet API
invokes the __jspService_ method.
* The _init(ServletConfig)_ method stores the
configuration, makes it available via _getServletConfig_ , then invokes
_jspInit_ .
* The _destroy_ method invokes _jspDestroy_ .

A JSP container may give a fatal translation
error if it detects that the provided superclass does not satisfy these
requirements, but most JSP containers will not check them.

=== Buffering

The JSP container buffers data (if the jsp
directive specifies it using the buffer attribute) as it is sent from
the server to the client. Headers are not sent to the client until the
first flush method is invoked. Therefore, it is possible to call methods
that modify the response header, such as _setContentType_ ,
_sendRedirect_ , or error methods, up until the flush method is executed
and the headers are sent. After that point, these methods become
invalid, as per the Servlet specification.

The _javax.servlet.jsp.JspWriter_ __ class
buffers and sends output. The _JspWriter_ class is used in the
__jspService_ __ method as in the following example:

 _import javax.servlet.jsp.JspWriter; +
 +
static JspFactory _jspFactory = JspFactory.getDefaultFactory(); +
 +
_jspService(<SRequest> request, <SResponse> response) \{ +
 +
// initialization of implicit variables... +
PageContext pageContext = _jspFactory.createPageContext( +
this, +
request, +
response, +
false, +
PageContext.DEFAULT_BUFFER, +
false +
); +
JSPWriter out = pageContext.getOut(); +
// .... +
// .... the body goes here using "out" +
// .... +
out.flush(); +
}_

The complete listing of
_javax.servlet.jsp.JspWriter_ can be found in
link:javax.servlet.jsp.html#UNKNOWN[].

With buffering turned on, a redirect method
can still be used in a scriptlet in a _.jsp_ file, by invoking
_response.redirect(someURL)_ directly.

=== [[a2967]]Precompilation

A JSP page that is using the HTTP protocol
will receive HTTP requests. JSP 2.2 compliant containers must support a
simple precompilation protocol, as well as some basic reserved parameter
names. Note that the precompilation protocol is related but not the same
as the notion of compiling a JSP page into a _Servlet_ class
(link:jsp.html#a3028[See Packaging JSP Pages.]).

=== Request Parameter Names

All request parameter names that start with
the prefix _jsp_ are reserved by the JSP specification and should not be
used by any user or implementation except as indicated by the
specification.

All JSPs pages should ignore (not depend on)
any parameter that starts with _jsp__ .

=== Precompilation Protocol

A request to a JSP page that has a request
parameter with name _jsp_precompile_ is a precompilation request. The
_jsp_precompile_ parameter may have no value, or may have values _true_
or _false_ . In all cases, the request should not be delivered to the
JSP page.

The intention of the precompilation request
is that of a suggestion to the JSP container to precompile the JSP page
into its JSP page implementation class. The suggestion is conveyed by
giving the parameter the value _true_ or no value, but note that the
request can be ignored.

For example:

.  _?jsp_precompile_
.  _?jsp_precompile=true_
.  _?jsp_precompile=false_
.  _?foobar=foobaz&jsp_precompile=true_
.  _?foobar=foobaz&jsp_precompile=false_

1, 2, and 4 are legal; the request will not
be delivered to the page. 3 and 5 are legal; the request will not be
delivered to the page.

.  _?jsp_precompile=foo_

This is illegal and will generate an HTTP
error; 500 (Server error).

=== [[a2984]]Debugging Requirements

With the completion of JSR-45 ("Debugging
Support for Other Languages"), the JSP Compiler now has a standard
format to convey source map debugging information to tools such as
debuggers. See _http://jcp.org/jsr/detail/45.jsp_ for details.

JSP 2.1 containers are required to provide
support for JSR-45 for JSP pages and tag files written in either
standard or XML syntax.

The JSP compiler must produce _.class_ files
with a _SourceDebugExtension_ attribute, mapping each line or lines of
JSP code to the corresponding generated line or lines of Java code. For
both pages and tag files, the stratum that maps to the original source
should be named _JSP_ in the Source Debug Extension (this stratum name
is reserved for use by the JSP specification). This stratum should be
specified as the default, unless the page or tag file was generated from
some other source.

The exact mechanism for causing the JSP
compiler to produce source map debugging information is
implementation-dependent.

=== Line Number Mapping Guidelines

The following is a set of non-normative
guidelines for generating high quality line number mappings. The
guidelines are presented to help produce a consistent debugging
experience for page authors, across containers. Where possible the JSP
container should generate line number mappings as follows:

. [[a2991]]Abreakpoint on a JSP
line causes execution to stop before any Java code which amounts to a
translation of the JSP line is executed (for one possible exception, see
link:jsp.html#a3001[See For scriptlets, scriptlet expressions,
EL expressions, standard actions and custom actions in template text, a
line containing one or more of these entities should be mapped to Java
source lines which include the corresponding Java code..]). Note that
given the LineInfo Composition Algorithm (see JSR-45 specification), it
is acceptable for the mappings to include one or more Java lines which
are never translated into executable byte code, as long as at least one
of them does.
. It is permitted for two or more lines of
JSP to include the same Java lines in their mappings.
. If a line of JSP has no manifestation in
the Java source other than white-space preserving source, it should not
be mapped.
. The following standard syntax JSP entities
should not be mapped to generated code. These entities either have no
manifestation in the generated Java code (e.g. comments), or are not
manifest in such a way that it allows the debugged process to stop (e.g.
the page directive import):
. JSP comments

=== Directives

* The following XML syntax JSP entities
should not be mapped to generated code. These entities frequently have
no manifestation in the generated Java code.
*  _<jsp:root>_

===  _<jsp:output>_

. Declarations and scriptlets (standard or
XML JSP). Lines in these constructs should preserve a one-to-one mapping
with the corresponding generated code lines. Empty lines and comment
lines are not mapped.
. [[a3001]]For scriptlets,
scriptlet expressions, EL expressions, standard actions and custom
actions in template text, a line containing one or more of these
entities should be mapped to Java source lines which include the
corresponding Java code.

If the line starts with template text, the
Java code which handles it may be excluded from the mappings if this
would cause the debugger to stop before the apparent execution of JSP
lines preceding the line in question. For example:

 100 <p>This is a line with template
text.</p> +
101 <h1><fmt:message key="company" bundle="$\{bundle}"/></h1>

 200 out.write( "<p>This is a line with
template text.</p>\r\n" ); +
201 out.write( "<h1>" ); +
202 org.apache.taglibs.standard.tag.el.fmt.MessageTag taghandler = +
203 new org.apache.taglibs.standard.tag.el.fmt.MessageTag(); +
204 taghandler.setPageContext( pageContext ); +
205 ...

In this example, given that _<h1>_ has its
own call to _write()_ , it makes sense to map 101 to 201, 202 etc.

 200 out.write( "<p>This is a line with
template text.</p>\r\n<h1>" ); +
201 org.apache.taglibs.standard.tag.el.fmt.MessageTag taghandler = +
202 new org.apache.taglibs.standard.tag.el.fmt.MessageTag(); +
203 taghandler.setPageContext( pageContext ); +
204 ...

In this second example, given that _<h1>_ is
output using the same call to _write()_ that was used for line 100,
mapping 101 to 202, 203 etc. may result in more intuitive behavior of
the debugger. +
 +
For scriptlets that contain more than one line, there should be a
one-to-one mapping from JSP to Java lines, and the mapping should start
at the first Java code that is not whitespace or comments. Therefore, a
line that contains only the open scriptlet delimeter is not mapped.



. [[a3009]]Scriptlet expressions
and EL expressions in attribute values. The source line mappings should
include any Java source lines that deal with the evaluation of the
rtexpr value as well as source that deals with the JSP action.
. Standard or custom actions.
. Empty tags and start tags special case: The
_jsp:params_ action typically has no manifestation and should not be
mapped.
. Empty tags and start tags: The Java line
mappings should include as much of the corresponding Java code as
possible, including any separate lines that deal with rtexpr evaluation
as described in (link:jsp.html#a3009[See Scriptlet expressions
and EL expressions in attribute values. The source line mappings should
include any Java source lines that deal with the evaluation of the
rtexpr value as well as source that deals with the JSP action..]). If it
is not possible to include all the Java code in the mappings, the mapped
lines should include the first sequential line which deals with either
the tag or the attribute evaluation in order to meet
(link:jsp.html#a2991[See Abreakpoint on a JSP line causes
execution to stop before any Java code which amounts to a translation of
the JSP line is executed (for one possible exception, see 5). Note that
given the LineInfo Composition Algorithm (see JSR-45 specification), it
is acceptable for the mappings to include one or more Java lines which
are never translated into executable byte code, as long as at least one
of them does..]).
. Closing tags frequently do not have a
manifestation in the Java source, but sometimes do. In case a JSP line
contains only a closing tag, the line may be mapped to whitespace
preserving Java source if it has no semantic translation. This will
avoid a confusing user experience where it is sometimes possible to set
a breakpoint on a line consisting of a closing tag and sometimes not.



=== 

=== [[a3016]]Part III

 __ 

The next Appendices provide details.

Appendices B, C and D are normative.
Appendices A, E, and F are non-normative.

The Appendices are

* Appendix A - Packaging JSP pages
* Appendix B - Schema for the portion of
web.xml owned by the JSP specification
* Appendix C - Schema for the Tag Library
Descriptor file.
* Appendix D - Page Character Encoding
Detection Algorithm
* Appendix E - Changes
* Appendix F - Glossary of terms

=== Appendix

[[a3028]]Packaging JSP Pages

This appendix shows two simple examples
of packaging a JSP page into a WAR for delivery into a Web container. In
the first example, the JSP page is delivered in source form. This is
likely to be the most common example. In the second example the JSP page
is compiled into a servlet that uses only Servlet 2.5 and JSP 2.2 API
calls; the servlet is then packaged into a WAR with a deployment
descriptor such that it looks as the original JSP page to any client.

This appendix is non normative. Actually,
strictly speaking, the appendix relates more to the Servlet 2.5
capabilities than to the JSP 2.2 capabilities. The appendix is included
here as this is a feature that JSP page authors and JSP page authoring
tools are interested in.

=== A Very Simple JSP Page

We start with a very simple JSP page
_HelloWorld.jsp_ .

<%@ page info="Example JSP pre-compiled" %> +
<p> +
Hello World +
</p>

=== The JSP Page Packaged as Source in a WAR File

The JSP page can be packaged into a WAR file
by just placing it at location _/HelloWorld.jsp_ the default JSP page
extension mapping will pick it up. The _web.xml_ is trivial:

<!DOCTYPE webapp +
SYSTEM "http://java.sun.com/j2ee/dtds/web-app_2_3.dtd"> +
<webapp> +
<session-config> +
<session-timeout> 1 </session-timeout> +
</session-config> +
</webapp>

=== The Servlet for the Compiled JSP Page

As an alternative, we will show how one can
compile the JSP page into a servlet class to run in a JSP container.

The JSP page is compiled into a servlet with
some implementation dependent name _com.acme._jsp_HelloWorld_XXX_Impl_ .
The servlet code only depends on the JSP 2.2 and Servlet 2.5 APIs, as
follows:

package com.acme; +
 +
import javax.servlet.*; +
import javax.servlet.http.*; +
import javax.servlet.jsp.*;

public class _jsp_HelloWorld_XXX_Impl +
extends PlatformDependent_Jsp_Super_Impl +
\{ +
public void _jspInit() \{ +
// ... +
}

 public void jspDestroy() \{ +
// ... +
} +
 +
static JspFactory _factory = JspFactory.getDefaultFactory(); +
 +
public void _jspService( HttpServletRequest request, +
HttpServletResponse response) +
throws IOException, ServletException

 \{ +
Object page = this; +
HttpSession session = request.getSession(); +
ServletConfig config = getServletConfig(); +
ServletContext application = config.getServletContext(); +
 +
 +
PageContext pageContext +
= _factory.getPageContext( this, +
request, +
response, +
(String)NULL, +
true, +
JspWriter.DEFAULT_BUFFER, +
true +
);

 JspWriter out = pageContext.getOut(); +
// page context creates initial JspWriter "out" +
 +
try \{ +
out.println("<p>"); +
out.println("Hello World"); +
out.println("</p>"); +
} catch (Exception e) \{ +
pageContext.handlePageException(e); +
} finally \{ +
_factory.releasePageContext(pageContext); +
} +
} +
}

=== The Web Application Descriptor

The servlet is made to look as a JSP page
with the following _web.xml_ :

<!DOCTYPE webapp +
SYSTEM "http://java.sun.com/j2ee/dtds/web-app_2_3.dtd"> +
<webapp> +
<servlet> +
<servlet-name> HelloWorld </servlet-name> +
<servlet-class>com.acme._jsp_HelloWorld_XXX_Impl</servlet-class> +
</servlet> +
 +
<servlet-mapping> +
<servlet-name> HelloWorld </servlet-name> +
<url-pattern> /HelloWorld.jsp </url-pattern> +
</servlet-mapping> +
 +
<session-config> +
<session-timeout> 1 </session-timeout> +
</session-config> +
</webapp>

=== The WAR for the Compiled JSP Page

Finally everything is packaged together into
a WAR:

/WEB-INF/web.xml

/WEB-INF/classes/com/acme/_jsp_HelloWorld_XXX_Impl.class

Note that if the servlet class generated for
the JSP page had depended on some support classes, they would have to be
included in the WAR.

=== APPENDIX

[[a3054]]JSP Elements of web.xml

This appendix describes the JSP elements
of the Servlet Web Application Deployment Descriptor, which is described
using XML Schema.

=== XML Schema for JSP 2.2 Deployment Descriptor

The Servlet 3.0 deployment descriptior schema
includes the definitions that appeas in this section. __

This is the same XML Schema as
_http://java.sun.com/xml/ns/javaee/jsp_2_2.xsd._



<?xml version="1.0" encoding="UTF-8"?>



<xsd:schema
xmlns="http://www.w3.org/2001/XMLSchema"


targetNamespace="http://java.sun.com/xml/ns/javaee"


xmlns:javaee="http://java.sun.com/xml/ns/javaee"

 xmlns:xsd="http://www.w3.org/2001/XMLSchema"

 elementFormDefault="qualified"

 attributeFormDefault="unqualified"

 version="2.2">

 <xsd:annotation>

 <xsd:documentation>

 @(#)jsp_2_2.xsds 02/26/09

 </xsd:documentation>

 </xsd:annotation>



 <xsd:annotation>

 <xsd:documentation>



 DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR
THIS HEADER.



 Copyright 2003-2009 Sun Microsystems, Inc.
All rights reserved.



 The contents of this file are subject to the
terms of either the

 GNU General Public License Version 2 only
("GPL") or the Common

 Development and Distribution License("CDDL")
(collectively, the

 "License"). You may not use this file except
in compliance with

 the License. You can obtain a copy of the
License at


https://glassfish.dev.java.net/public/CDDL+GPL.html or

 glassfish/bootstrap/legal/LICENSE.txt. See
the License for the

 specific language governing permissions and
limitations under the

 License.



 When distributing the software, include this
License Header

 Notice in each file and include the License
file at

 glassfish/bootstrap/legal/LICENSE.txt. Sun
designates this

 particular file as subject to the
"Classpath" exception as

 provided by Sun in the GPL Version 2 section
of the License file

 that accompanied this code. If applicable,
add the following

{empty} below the License Header, with the
fields enclosed by brackets []

 replaced by your own identifying
information:

 "Portions Copyrighted [year] [name of
copyright owner]"



 Contributor(s):



 If you wish your version of this file to be
governed by only the

 CDDL or only the GPL Version 2, indicate
your decision by adding

 "[Contributor] elects to include this
software in this

 distribution under the [CDDL or GPL Version
2] license." If you

 don't indicate a single choice of license, a
recipient has the

 option to distribute your version of this
file under either the

 CDDL, the GPL Version 2 or to extend the
choice of license to its

 licensees as provided above. However, if you
add GPL Version 2

 code and therefore, elected the GPL Version
2 license, then the

 option applies only if the new code is made
subject to such

 option by the copyright holder.



 </xsd:documentation>

 </xsd:annotation>



 <xsd:annotation>

 <xsd:documentation>



 This is the XML Schema for the JSP 2.2
deployment descriptor

 types. The JSP 2.2 schema contains all the
special

 structures and datatypes that are necessary
to use JSP files

 from a web application.



 The contents of this schema is used by the
web-app_3_0.xsd

 file to define JSP specific content.



 </xsd:documentation>

 </xsd:annotation>



 <xsd:annotation>

 <xsd:documentation>



 The following conventions apply to all Java
EE

 deployment descriptor elements unless
indicated otherwise.



 - In elements that specify a pathname to a
file within the

 same JAR file, relative filenames (i.e.,
those not

 starting with "/") are considered relative
to the root of

 the JAR file's namespace. Absolute filenames
(i.e., those

 starting with "/") also specify names in the
root of the

 JAR file's namespace. In general, relative
names are

 preferred. The exception is .war files where
absolute

 names are preferred for consistency with the
Servlet API.



 </xsd:documentation>

 </xsd:annotation>



 <xsd:include schemaLocation="javaee_6.xsd"/>





<!--
**************************************************** -->



 <xsd:complexType name="jsp-configType">

 <xsd:annotation>

 <xsd:documentation>



 The jsp-configType is used to provide global
configuration

 information for the JSP files in a web
application. It has

 two subelements, taglib and
jsp-property-group.



 </xsd:documentation>

 </xsd:annotation>



 <xsd:sequence>

 <xsd:element name="taglib"

 type="javaee:taglibType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 <xsd:element name="jsp-property-group"

 type="javaee:jsp-property-groupType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="jsp-fileType">

 <xsd:annotation>

 <xsd:documentation>



 The jsp-file element contains the full path
to a JSP file

 within the web application beginning with a
`/'.



 </xsd:documentation>

 </xsd:annotation>



 <xsd:simpleContent>

 <xsd:restriction base="javaee:pathType"/>

 </xsd:simpleContent>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType
name="jsp-property-groupType">

 <xsd:annotation>

 <xsd:documentation>



 The jsp-property-groupType is used to group
a number of

 files so they can be given global property
information.

 All files so described are deemed to be JSP
files. The

 following additional properties can be
described:



 - Control whether EL is ignored.

 - Control whether scripting elements are
invalid.

 - Indicate pageEncoding information.

 - Indicate that a resource is a JSP document
(XML).

 - Prelude and Coda automatic includes.

 - Control whether the character sequence #\{
is allowed

 when used as a String literal.

 - Control whether template text containing
only

 whitespaces must be removed from the
response output.

 - Indicate the default contentType
information.

 - Indicate the default buffering model for
JspWriter

 - Control whether error should be raised for
the use of

 undeclared namespaces in a JSP page.



 </xsd:documentation>

 </xsd:annotation>



 <xsd:sequence>

 <xsd:group ref="javaee:descriptionGroup"/>

 <xsd:element name="url-pattern"

 type="javaee:url-patternType"

 maxOccurs="unbounded"/>

 <xsd:element name="el-ignored"

 type="javaee:true-falseType"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 Can be used to easily set the isELIgnored

 property of a group of JSP pages. By
default, the

 EL evaluation is enabled for Web
Applications using

 a Servlet 2.4 or greater web.xml, and
disabled

 otherwise.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>

 <xsd:element name="page-encoding"

 type="javaee:string"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 The valid values of page-encoding are those
of the

 pageEncoding page directive. It is a

 translation-time error to name different
encodings

 in the pageEncoding attribute of the page
directive

 of a JSP page and in a JSP configuration
element

 matching the page. It is also a
translation-time

 error to name different encodings in the
prolog

 or text declaration of a document in XML
syntax and

 in a JSP configuration element matching the
document.

 It is legal to name the same encoding
through

 mulitple mechanisms.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>

 <xsd:element name="scripting-invalid"

 type="javaee:true-falseType"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 Can be used to easily disable scripting in a

 group of JSP pages. By default, scripting is

 enabled.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>

 <xsd:element name="is-xml"

 type="javaee:true-falseType"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 If true, denotes that the group of resources

 that match the URL pattern are JSP
documents,

 and thus must be interpreted as XML
documents.

 If false, the resources are assumed to not

 be JSP documents, unless there is another

 property group that indicates otherwise.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>

 <xsd:element name="include-prelude"

 type="javaee:pathType"

 minOccurs="0"

 maxOccurs="unbounded">

 <xsd:annotation>

 <xsd:documentation>



 The include-prelude element is a
context-relative

 path that must correspond to an element in
the

 Web Application. When the element is
present,

 the given path will be automatically
included (as

 in an include directive) at the beginning of
each

 JSP page in this jsp-property-group.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>

 <xsd:element name="include-coda"

 type="javaee:pathType"

 minOccurs="0"

 maxOccurs="unbounded">

 <xsd:annotation>

 <xsd:documentation>



 The include-coda element is a
context-relative

 path that must correspond to an element in
the

 Web Application. When the element is
present,

 the given path will be automatically
included (as

 in an include directive) at the end of each

 JSP page in this jsp-property-group.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>

 <xsd:element
name="deferred-syntax-allowed-as-literal"

 type="javaee:true-falseType"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 The character sequence #\{ is reserved for
EL expressions.

 Consequently, a translation error occurs if
the #\{

 character sequence is used as a String
literal, unless

 this element is enabled (true). Disabled
(false) by

 default.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>

 <xsd:element
name="trim-directive-whitespaces"

 type="javaee:true-falseType"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 Indicates that template text containing only
whitespaces

 must be removed from the response output. It
has no

 effect on JSP documents (XML syntax).
Disabled (false)

 by default.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>

 <xsd:element name="default-content-type"

 type="javaee:string"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 The valid values of default-content-type are
those of the

 contentType page directive. It specifies the
default

 response contentType if the page directive
does not include

 a contentType attribute.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>

 <xsd:element name="buffer"

 type="javaee:string"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 The valid values of buffer are those of the

 buffer page directive. It specifies if
buffering should be

 used for the output to response, and if so,
the size of the

 buffer to use.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>

 <xsd:element
name="error-on-undeclared-namespace"

 type="javaee:true-falseType"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 The default behavior when a tag with unknown
namespace is used

 in a JSP page (regular syntax) is to
silently ignore it. If

 set to true, then an error must be raised
during the translation

 time when an undeclared tag is used in a JSP
page. Disabled

 (false) by default.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="taglibType">

 <xsd:annotation>

 <xsd:documentation>



 The taglibType defines the syntax for
declaring in

 the deployment descriptor that a tag library
is

 available to the application. This can be
done

 to override implicit map entries from TLD
files and

 from the container.



 </xsd:documentation>

 </xsd:annotation>



 <xsd:sequence>

 <xsd:element name="taglib-uri"

 type="javaee:string">

 <xsd:annotation>

 <xsd:documentation>



 A taglib-uri element describes a URI
identifying a

 tag library used in the web application. The
body

 of the taglib-uri element may be either an

 absolute URI specification, or a relative
URI.

 There should be no entries in web.xml with
the

 same taglib-uri value.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>



 <xsd:element name="taglib-location"

 type="javaee:pathType">

 <xsd:annotation>

 <xsd:documentation>



 the taglib-location element contains the
location

 (as a resource relative to the root of the
web

 application) where to find the Tag Library

 Description file for the tag library.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>



 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

 </xsd:complexType>



</xsd:schema>





=== XML Schema for JSP 2.1 Deployment Descriptor

The Servlet 2.5 deployment descriptor schema
includes the definitions that appear in this section.

This is the same XML Schema as
_http://java.sun.com/xml/ns/javaee/jsp_2_1.xsd_ , except for some
formatting changes to extract comments and make them more readable.



<?xml version="1.0" encoding="UTF-8"?>

<xsd:schema
xmlns="http://www.w3.org/2001/XMLSchema"


targetNamespace="http://java.sun.com/xml/ns/javaee"


xmlns:javaee="http://java.sun.com/xml/ns/javaee"

 xmlns:xsd="http://www.w3.org/2001/XMLSchema"

 elementFormDefault="qualified"

 attributeFormDefault="unqualified"

 version="2.1">

===  <xsd:annotation>

===  <xsd:documentation>

 @(#)jsp_2_1.xsds 1.5 08/11/05

===  </xsd:documentation>

===  </xsd:annotation>

===  <xsd:annotation>

===  <xsd:documentation>

 This is the XML Schema for the JSP 2.1
deployment descriptor

 types. The JSP 2.1 schema contains all the
special

 structures and datatypes that are necessary
to use JSP files

 from a web application.

 

 The contents of this schema is used by the
web-app_2_5.xsd

 file to define JSP specific content.

===  </xsd:documentation>

===  </xsd:annotation>

===  <xsd:annotation>

===  <xsd:documentation>

 The following conventions apply to all Java
EE

 deployment descriptor elements unless
indicated otherwise.

 

 - In elements that specify a pathname to a
file within the

 same JAR file, relative filenames (i.e.,
those not

 starting with "/") are considered relative
to the root of

 the JAR file’s namespace. Absolute filenames
(i.e., those

 starting with "/") also specify names in the
root of the

 JAR file’s namespace. In general, relative
names are

 preferred. The exception is .war files where
absolute

 names are preferred for consistency with the
Servlet API.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:include schemaLocation="javaee_5.xsd"/>

=== <!-- **************************************************** -->

===  <xsd:complexType name="jsp-configType">

===  <xsd:annotation>

===  <xsd:documentation>

 The jsp-configType is used to provide global
configuration

 information for the JSP files in a web
application. It has

 two subelements, taglib and
jsp-property-group.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="taglib"

 type="javaee:taglibType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 <xsd:element name="jsp-property-group"

 type="javaee:jsp-property-groupType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="jsp-fileType">

===  <xsd:annotation>

===  <xsd:documentation>

 The jsp-file element contains the full path
to a JSP file

 within the web application beginning with a
`/’.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:simpleContent>

 <xsd:restriction base="javaee:pathType"/>

 </xsd:simpleContent>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="jsp-property-groupType">

===  <xsd:annotation>

===  <xsd:documentation>

 The jsp-property-groupType is used to group
a number of

 files so they can be given global property
information.

 All files so described are deemed to be JSP
files. The

 following additional properties can be
described:

 

 - Control whether EL is ignored.

 - Control whether scripting elements are
invalid.

 - Indicate pageEncoding information.

 - Indicate that a resource is a JSP document
(XML).

 - Prelude and Coda automatic includes.

 - Control whether the character sequence #\{
is allowed

 when used as a String literal.

 - Control whether template text containing
only

 whitespaces must be removed from the
response output.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:group ref="javaee:descriptionGroup"/>

 <xsd:element name="url-pattern"

 type="javaee:url-patternType"

 maxOccurs="unbounded"/>

 <xsd:element name="el-ignored"

 type="javaee:true-falseType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Can be used to easily set the isELIgnored

 property of a group of JSP pages. By
default, the

 EL evaluation is enabled for Web
Applications using

 a Servlet 2.4 or greater web.xml, and
disabled

 otherwise.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="page-encoding"

 type="javaee:string"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The valid values of page-encoding are those
of the

 pageEncoding page directive. It is a

 translation-time error to name different
encodings

 in the pageEncoding attribute of the page
directive

 of a JSP page and in a JSP configuration
element

 matching the page. It is also a
translation-time

 error to name different encodings in the
prolog

 or text declaration of a document in XML
syntax and

 in a JSP configuration element matching the
document.

 It is legal to name the same encoding
through

 mulitple mechanisms.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="scripting-invalid"

 type="javaee:true-falseType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Can be used to easily disable scripting in a

 group of JSP pages. By default, scripting is

 enabled.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="is-xml"

 type="javaee:true-falseType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 If true, denotes that the group of resources

 that match the URL pattern are JSP
documents,

 and thus must be interpreted as XML
documents.

 If false, the resources are assumed to not

 be JSP documents, unless there is another

 property group that indicates otherwise.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="include-prelude"

 type="javaee:pathType"

 minOccurs="0"

 maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 The include-prelude element is a
context-relative

 path that must correspond to an element in
the

 Web Application. When the element is
present,

 the given path will be automatically
included (as

 in an include directive) at the beginning of
each

 JSP page in this jsp-property-group.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="include-coda"

 type="javaee:pathType"

 minOccurs="0"

 maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 The include-coda element is a
context-relative

 path that must correspond to an element in
the

 Web Application. When the element is
present,

 the given path will be automatically
included (as

 in an include directive) at the end of each

 JSP page in this jsp-property-group.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element
name="deferred-syntax-allowed-as-literal"

 type="javaee:true-falseType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The character sequence #\{ is reserved for
EL expressions.

 Consequently, a translation error occurs if
the #\{

 character sequence is used as a String
literal, unless

 this element is enabled (true). Disabled
(false) by

 default.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element
name="trim-directive-whitespaces"

 type="javaee:true-falseType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Indicates that template text containing only
whitespaces

 must be removed from the response output. It
has no

 effect on JSP documents (XML syntax).
Disabled (false)

 by default.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="taglibType">

===  <xsd:annotation>

===  <xsd:documentation>

 The taglibType defines the syntax for
declaring in

 the deployment descriptor that a tag library
is

 available to the application. This can be
done

 to override implicit map entries from TLD
files and

 from the container.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="taglib-uri"

 type="javaee:string">

===  <xsd:annotation>

===  <xsd:documentation>

 A taglib-uri element describes a URI
identifying a

 tag library used in the web application. The
body

 of the taglib-uri element may be either an

 absolute URI specification, or a relative
URI.

 There should be no entries in web.xml with
the

 same taglib-uri value.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="taglib-location"

 type="javaee:pathType">

===  <xsd:annotation>

===  <xsd:documentation>

 the taglib-location element contains the
location

 (as a resource relative to the root of the
web

 application) where to find the Tag Library

 Description file for the tag library.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

</xsd:schema>





=== [[a3717]]XML Schema for JSP 2.0 Deployment Descriptor

The Servlet 2.4 deployment descriptor schema
includes the definitions that appear in this Appendix.

This is the same XML Schema as
_http://java.sun.com/xml/ns/j2ee/jsp_2_0.xsd_ , except for some
formatting changes to extract comments and make them more readable.



<?xml version="1.0" encoding="UTF-8"?>

<xsd:schema
xmlns="http://www.w3.org/2001/XMLSchema"


targetNamespace="http://java.sun.com/xml/ns/j2ee"

 xmlns:j2ee="http://java.sun.com/xml/ns/j2ee"

 xmlns:xsd="http://www.w3.org/2001/XMLSchema"

 elementFormDefault="qualified"

 attributeFormDefault="unqualified"

 version="2.0">

===  <xsd:annotation>

===  <xsd:documentation>

 This is the XML Schema for the JSP 2.0
deployment descriptor

 types. The JSP 2.0 schema contains all the
special

 structures and datatypes that are necessary
to use JSP files

 from a web application.

 

 The contents of this schema is used by the
web-app_2_4.xsd

 file to define JSP specific content.

===  </xsd:documentation>

===  </xsd:annotation>

===  <xsd:annotation>

===  <xsd:documentation>

 The following conventions apply to all J2EE

 deployment descriptor elements unless
indicated otherwise.

 

 - In elements that specify a pathname to a
file within the

 same JAR file, relative filenames (i.e.,
those not

 starting with "/") are considered relative
to the root of

 the JAR file’s namespace. Absolute filenames
(i.e., those

 starting with "/") also specify names in the
root of the

 JAR file’s namespace. In general, relative
names are

 preferred. The exception is .war files where
absolute

 names are preferred for consistency with the
Servlet API.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:include schemaLocation="j2ee_1_4.xsd"/>

=== <!-- **************************************************** -->

===  <xsd:complexType name="jsp-configType">

===  <xsd:annotation>

===  <xsd:documentation>

 The jsp-configType is used to provide global
configuration

 information for the JSP files in a web
application. It has

 two subelements, taglib and
jsp-property-group.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="taglib"

 type="j2ee:taglibType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 <xsd:element name="jsp-property-group"

 type="j2ee:jsp-property-groupType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="jsp-fileType">

===  <xsd:annotation>

===  <xsd:documentation>

 The jsp-file element contains the full path
to a JSP file

 within the web application beginning with a
`/’.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:simpleContent>

 <xsd:restriction base="j2ee:pathType"/>

 </xsd:simpleContent>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="jsp-property-groupType">

===  <xsd:annotation>

===  <xsd:documentation>

 The jsp-property-groupType is used to group
a number of

 files so they can be given global property
information.

 All files so described are deemed to be JSP
files. The

 following additional properties can be
described:

 

 - Control whether EL is ignored

 - Control whether scripting elements are
invalid

 - Indicate pageEncoding information.

 - Indicate that a resource is a JSP document
(XML)

 - Prelude and Coda automatic includes.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:group ref="j2ee:descriptionGroup"/>

 <xsd:element name="url-pattern"

 type="j2ee:url-patternType"

 maxOccurs="unbounded"/>

 <xsd:element name="el-ignored"

 type="j2ee:true-falseType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Can be used to easily set the isELIgnored

 property of a group of JSP pages. By
default, the

 EL evaluation is enabled for Web
Applications using

 a Servlet 2.4 or greater web.xml, and
disabled

 otherwise.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="page-encoding"

 type="j2ee:string"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The valid values of page-encoding are those
of the

 pageEncoding page directive. It is a

 translation-time error to name different
encodings

 in the pageEncoding attribute of the page
directive

 of a JSP page and in a JSP configuration
element

 matching the page. It is also a
translation-time

 error to name different encodings in the
prolog

 or text declaration of a document in XML
syntax and

 in a JSP configuration element matching the
document.

 It is legal to name the same encoding
through

 mulitple mechanisms.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="scripting-invalid"

 type="j2ee:true-falseType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Can be used to easily disable scripting in a

 group of JSP pages. By default, scripting is

 enabled.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="is-xml"

 type="j2ee:true-falseType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 If true, denotes that the group of resources

 that match the URL pattern are JSP
documents,

 and thus must be interpreted as XML
documents.

 If false, the resources are assumed to not

 be JSP documents, unless there is another

 property group that indicates otherwise.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="include-prelude"

 type="j2ee:pathType"

 minOccurs="0"

 maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 The include-prelude element is a
context-relative

 path that must correspond to an element in
the

 Web Application. When the element is
present,

 the given path will be automatically
included (as

 in an include directive) at the beginning of
each

 JSP page in this jsp-property-group.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="include-coda"

 type="j2ee:pathType"

 minOccurs="0"

 maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 The include-coda element is a
context-relative

 path that must correspond to an element in
the

 Web Application. When the element is
present,

 the given path will be automatically
included (as

 in an include directive) at the end of each

 JSP page in this jsp-property-group.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="taglibType">

===  <xsd:annotation>

===  <xsd:documentation>

 The taglibType defines the syntax for
declaring in

 the deployment descriptor that a tag library
is

 available to the application. This can be
done

 to override implicit map entries from TLD
files and

 from the container.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="taglib-uri"

 type="j2ee:string">

===  <xsd:annotation>

===  <xsd:documentation>

 A taglib-uri element describes a URI
identifying a

 tag library used in the web application. The
body

 of the taglib-uri element may be either an

 absolute URI specification, or a relative
URI.

 There should be no entries in web.xml with
the

 same taglib-uri value.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="taglib-location"

 type="j2ee:pathType">

===  <xsd:annotation>

===  <xsd:documentation>

 the taglib-location element contains the
location

 (as a resource relative to the root of the
web

 application) where to find the Tag Library

 Description file for the tag library.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

</xsd:schema>



=== APPENDIX

Tag Library Descriptor
Formats

This appendix includes the XML Schema and
DTD files for tag library descriptors using each version of the JSP
specification (from JSP 1.1 to current). All JSP 2.2 containers are
required to be able to parse and accept all TLD formats described in
this appendix. The formats are listed in order from most recent to least
recent.

=== [[a3944]]XML Schema for TLD, JSP 2.1

The following is an XML Schema file
describing a Tag Library Descriptor in a JSP 2.1 format. This is the
same XSD as
_http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd_ , except
for some formatting changes to extract comments and make them more
readable. Some of the types used in this XSD are defined in the Java EE
Platform Specification (see Related Documents in the Preface for a link
to this specification).

The schema is preceeded by a set of diagrams
that graphically illustrate the element structure of the schema. The
symbols ‘+’, ‘*’, ‘|’, ‘(’ and ‘)’ have the same meaning as in DTD. In
the event of a discrepancy between these diagrams and the schema, the
schema prevails.

This schema differs from the JSP 2.0 version
by supporting deferred expressions. The _<attribute>_ element now
supports three new sub-elements: _<deferred-value>_ ,
_<deferred-method>_ , and _<method-signature>._



image:sp-19.png[image]

=== TLD Schema Element Structure



image:sp-20.png[image]

=== TLD Schema Element Structure - listener



image:sp-21.png[image]



=== TLD Schema Element Structure - tag





image:sp-22.png[image]

=== TLD Schema Element Structure - tag-file



image:sp-23.png[image]

=== TLD Schema Element Structure - function

<?xml version="1.0" encoding="UTF-8"?>

<xsd:schema


targetNamespace="http://java.sun.com/xml/ns/javaee"


xmlns:javaee="http://java.sun.com/xml/ns/javaee"

 xmlns:xsd="http://www.w3.org/2001/XMLSchema"

 elementFormDefault="qualified"

 attributeFormDefault="unqualified"

 version="2.1">

===  <xsd:annotation>

===  <xsd:documentation>

 @(#)web-jsptaglibrary_2_1.xsds 1.1

===  </xsd:documentation>

===  </xsd:annotation>

===  <xsd:annotation>

===  <xsd:documentation>

 This is the XML Schema for the JSP
Taglibrary

 descriptor. All Taglibrary descriptors must

 indicate the tag library schema by using the
Taglibrary

 namespace:

 

 http://java.sun.com/xml/ns/javaee

 

 and by indicating the version of the schema
by

 using the version element as shown below:

 

 <taglib
xmlns="http://java.sun.com/xml/ns/javaee"


xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

 xsi:schemaLocation="..."

 version="2.1">

 ...

 </taglib>

 

 The instance documents may indicate the
published

 version of the schema using
xsi:schemaLocation attribute

 for Java EE namespace with the following
location:

 


http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:include schemaLocation="javaee_5.xsd"/>

=== <!-- **************************************************** -->

===  <xsd:element name="taglib" type="javaee:tldTaglibType">

===  <xsd:annotation>

===  <xsd:documentation>

 The taglib tag is the document root.

 The definition of taglib is provided

 by the tldTaglibType.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:unique name="tag-name-uniqueness">

===  <xsd:annotation>

===  <xsd:documentation>

 The taglib element contains, among other
things, tag and

 tag-file elements.

 The name subelements of these elements must
each be unique.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:selector
xpath="javaee:tag|javaee:tag-file"/>

 <xsd:field xpath="javaee:name"/>

 </xsd:unique>

 <xsd:unique name="function-name-uniqueness">

===  <xsd:annotation>

===  <xsd:documentation>

 The taglib element contains function
elements.

 The name subelements of these elements must
each be unique.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:selector xpath="javaee:function"/>

 <xsd:field xpath="javaee:name"/>

 </xsd:unique>

 </xsd:element>

=== <!-- **************************************************** -->

===  <xsd:complexType name="body-contentType">

===  <xsd:annotation>

===  <xsd:documentation>

 Specifies the type of body that is valid for
a tag.

 This value is used by the JSP container to
validate

 that a tag invocation has the correct body
syntax and

 by page composition tools to assist the page
author

 in providing a valid tag body.

 

 There are currently four values specified:

 

 tagdependent The body of the tag is
interpreted by the tag

 implementation itself, and is most likely

 in a different "language", e.g embedded SQL

 statements.

 

 JSP The body of the tag contains nested JSP

 syntax.

 

 empty The body must be empty

 

 scriptless The body accepts only template
text, EL

 Expressions, and JSP action elements. No

 scripting elements are allowed.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:simpleContent>

 <xsd:restriction base="javaee:string">

 <xsd:enumeration value="tagdependent"/>

 <xsd:enumeration value="JSP"/>

 <xsd:enumeration value="empty"/>

 <xsd:enumeration value="scriptless"/>

 </xsd:restriction>

 </xsd:simpleContent>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="extensibleType" abstract="true">

===  <xsd:annotation>

===  <xsd:documentation>

 The extensibleType is an abstract base type
that is used to

 define the type of extension-elements.
Instance documents

 must substitute a known type to define the
extension by

 using xsi:type attribute to define the
actual type of

 extension-elements.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="functionType">

===  <xsd:annotation>

===  <xsd:documentation>

 The function element is used to provide
information on each

 function in the tag library that is to be
exposed to the EL.

 

 The function element may have several
subelements defining:

 

 description Optional tag-specific
information

 

 display-name A short name that is intended
to be

 displayed by tools

 

 icon Optional icon element that can be used

 by tools

 

 name A unique name for this function

 

 function-class Provides the name of the Java
class that

 implements the function

 

 function-signature Provides the signature,
as in the Java

 Language Specification, of the Java

 method that is to be used to implement

 the function.

 

 example Optional informal description of an

 example of a use of this function

 

 function-extension Zero or more extensions
that provide extra

 information about this function, for tool

 consumption

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:group ref="javaee:descriptionGroup"/>

 <xsd:element name="name"

 type="javaee:tld-canonical-nameType">

===  <xsd:annotation>

===  <xsd:documentation>

 A unique name for this function.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="function-class"

 type="javaee:fully-qualified-classType">

===  <xsd:annotation>

===  <xsd:documentation>

 Provides the fully-qualified class name of
the Java

 class containing the static method that
implements

 the function.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="function-signature"

 type="javaee:string">

===  <xsd:annotation>

===  <xsd:documentation>

 Provides the signature, of the static Java
method that is

 to be used to implement the function. The
syntax of the

 function-signature element is as follows:

 

 FunctionSignature ::= ReturnType S
MethodName S?

 ’(’ S? Parameters? S? ’)’

 

 ReturnType ::= Type

 

 MethodName ::= Identifier

 

 Parameters ::= Parameter

 | ( Parameter S? ’,’ S? Parameters )

 

 Parameter ::= Type

 

 Where:

 

 * Type is a basic type or a fully qualified

 Java class name (including package name),

 as per the ’Type’ production in the Java

 Language Specification, Second Edition,

 Chapter 18.

 

 * Identifier is a Java identifier, as per

 the ’Identifier’ production in the Java

 Language Specification, Second

 Edition, Chapter 18.

 

 Example:

 

 java.lang.String nickName( java.lang.String,
int )

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="example"

 type="javaee:xsdStringType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The example element contains an informal
description

 of an example of the use of this function.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="function-extension"

 type="javaee:tld-extensionType"

 minOccurs="0"

 maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 Function extensions are for tool use only
and must not

 affect the behavior of a container.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tagFileType">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines an action in this tag library that
is implemented

 as a .tag file.

 

 The tag-file element has two required
subelements:

 

 description Optional tag-specific
information

 

 display-name A short name that is intended
to be

 displayed by tools

 

 icon Optional icon element that can be used

 by tools

 

 name The unique action name

 

 path Where to find the .tag file
implementing this

 action, relative to the root of the web

 application or the root of the JAR file for
a

 tag library packaged in a JAR. This must

 begin with /WEB-INF/tags if the .tag file

 resides in the WAR, or /META-INF/tags if the

 .tag file resides in a JAR.

 

 example Optional informal description of an

 example of a use of this tag

 

 tag-extension Zero or more extensions that
provide extra

 information about this tag, for tool

 consumption

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:group ref="javaee:descriptionGroup"/>

 <xsd:element name="name"

 type="javaee:tld-canonical-nameType"/>

 <xsd:element name="path"

 type="javaee:pathType"/>

 <xsd:element name="example"

 type="javaee:xsdStringType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The example element contains an informal
description

 of an example of the use of a tag.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="tag-extension"

 type="javaee:tld-extensionType"

 minOccurs="0"

 maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 Tag extensions are for tool use only and
must not affect

 the behavior of a container.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tagType">

===  <xsd:annotation>

===  <xsd:documentation>

 The tag defines a unique tag in this tag
library. It has one

 attribute, id.

 

 The tag element may have several subelements
defining:

 

 description Optional tag-specific
information

 

 display-name A short name that is intended
to be

 displayed by tools

 

 icon Optional icon element that can be used

 by tools

 

 name The unique action name

 

 tag-class The tag handler class implementing

 javax.servlet.jsp.tagext.JspTag

 

 tei-class An optional subclass of

 javax.servlet.jsp.tagext.TagExtraInfo

 

 body-content The body content type

 

 variable Optional scripting variable
information

 

 attribute All attributes of this action that
are

 evaluated prior to invocation.

 

 dynamic-attributes Whether this tag supports
additional

 attributes with dynamic names. If

 true, the tag-class must implement the

 javax.servlet.jsp.tagext.DynamicAttributes

 interface. Defaults to false.

 

 example Optional informal description of an

 example of a use of this tag

 

 tag-extension Zero or more extensions that
provide extra

 information about this tag, for tool

 consumption

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:group ref="javaee:descriptionGroup"/>

 <xsd:element name="name"

 type="javaee:tld-canonical-nameType"/>

 <xsd:element name="tag-class"

 type="javaee:fully-qualified-classType">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines the subclass of
javax.serlvet.jsp.tagext.JspTag

 that implements the request time semantics
for

 this tag. (required)

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="tei-class"

 type="javaee:fully-qualified-classType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines the subclass of
javax.servlet.jsp.tagext.TagExtraInfo

 for this tag. (optional)

 

 If this is not given, the class is not
consulted at

 translation time.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="body-content"

 type="javaee:body-contentType">

===  <xsd:annotation>

===  <xsd:documentation>

 Specifies the format for the body of this
tag.

 The default in JSP 1.2 was "JSP" but because
this

 is an invalid setting for simple tag
handlers, there

 is no longer a default in JSP 2.0. A
reasonable

 default for simple tag handlers is
"scriptless" if

 the tag can have a body.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="variable"

 type="javaee:variableType"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="attribute"

 type="javaee:tld-attributeType"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="dynamic-attributes"

 type="javaee:generic-booleanType"

 minOccurs="0"/>

 <xsd:element name="example"

 type="javaee:xsdStringType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The example element contains an informal
description

 of an example of the use of a tag.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="tag-extension"

 type="javaee:tld-extensionType"

 minOccurs="0"

 maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 Tag extensions are for tool use only and
must not affect

 the behavior of a container.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tld-attributeType">

===  <xsd:annotation>

===  <xsd:documentation>

 The attribute element defines an attribute
for the nesting

 tag. The attribute element may have several
subelements

 defining:

 

 description a description of the attribute

 

 name the name of the attribute

 

 required whether the attribute is required
or

 optional

 

 rtexprvalue whether the attribute is a
runtime attribute

 

 type the type of the attributes

 

 fragment whether this attribute is a
fragment

 

 deferred-value present if this attribute is
to be parsed as a

 javax.el.ValueExpression

 

 deferred-method present if this attribute is
to be parsed as a

 javax.el.MethodExpression

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"

 type="javaee:descriptionType"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="name"

 type="javaee:java-identifierType"/>

 <xsd:element name="required"

 type="javaee:generic-booleanType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines if the nesting attribute is required
or

 optional.

 

 If not present then the default is "false",
i.e

 the attribute is optional.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:choice>

 <xsd:sequence>

 <xsd:sequence minOccurs="0">

 <xsd:element name="rtexprvalue"

 type="javaee:generic-booleanType">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines if the nesting attribute can have
scriptlet

 expressions as a value, i.e the value of the

 attribute may be dynamically calculated at
request

 time, as opposed to a static value
determined at

 translation time.

 If not present then the default is "false",
i.e the

 attribute has a static value

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="type"

 type="javaee:fully-qualified-classType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines the Java type of the attributes
value.

 If this element is omitted, the expected
type is

 assumed to be "java.lang.Object".

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:choice>

 <xsd:element name="deferred-value"

 type="javaee:tld-deferred-valueType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Present if the value for this attribute is
to be

 passed to the tag handler as a

 javax.el.ValueExpression. This allows for
deferred

 evaluation of EL expressions. An optional
subelement

 will contain the expected type that the
value will

 be coerced to after evaluation of the
expression.

 The type defaults to Object if one is not
provided.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="deferred-method"

 type="javaee:tld-deferred-methodType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Present if the value for this attribute is
to be

 passed to the tag handler as a

 javax.el.MethodExpression. This allows for
deferred

 evaluation of an EL expression that
identifies a

 method to be invoked on an Object. An
optional

 subelement will contain the expected method

 signature. The signature defaults to "void
method()"

 if one is not provided.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:choice>

 </xsd:sequence>

 <xsd:element name="fragment"

 type="javaee:generic-booleanType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 "true" if this attribute is of type

 javax.jsp.tagext.JspFragment, representing
dynamic

 content that can be re-evaluated as many
times

 as needed by the tag handler. If omitted or
"false",

 the default is still type="java.lang.String"

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:choice>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tld-canonical-nameType">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines the canonical name of a tag or
attribute being

 defined.

 

 The name must conform to the lexical rules
for an NMTOKEN.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:simpleContent>

 <xsd:restriction
base="javaee:xsdNMTOKENType"/>

 </xsd:simpleContent>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tld-deferred-methodType">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines information about how to provide the
value for a

 tag handler attribute that accepts a
javax.el.MethodExpression.

 

 The deferred-method element has one optional
subelement:

 

 method-signature Provides the signature, as
in the Java

 Language Specifies, that is expected for

 the method being identified by the

 expression.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="method-signature"

 type="javaee:string"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Provides the expected signature of the
method identified

 by the javax.el.MethodExpression.

 

 This disambiguates overloaded methods and
ensures that

 the return value is of the expected type.

 

 The syntax of the method-signature element
is identical

 to that of the function-signature element.
See the

 documentation for function-signature for
more details.

 

 The name of the method is for documentation
purposes only

 and is ignored by the JSP container.

 

 Example:

 

 boolean validate(java.lang.String)

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tld-deferred-valueType">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines information about how to provide the
value for a

 tag handler attribute that accepts a
javax.el.ValueExpression.

 

 The deferred-value element has one optional
subelement:

 

 type the expected type of the attribute

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="type"

 type="javaee:fully-qualified-classType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The fully-qualified name of the Java type
that is the

 expected type for this deferred expression.
If this

 element is omitted, the expected type is
assumed to be

 "java.lang.Object".

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tld-extensionType">

===  <xsd:annotation>

===  <xsd:documentation>

 The tld-extensionType is used to indicate

 extensions to a specific TLD element.

 

 It is used by elements to designate an
extension block

 that is targeted to a specific extension
designated by

 a set of extension elements that are
declared by a

 namespace. The namespace identifies the
extension to

 the tool that processes the extension.

 

 The type of the extension-element is
abstract. Therefore,

 a concrete type must be specified by the TLD
using

 xsi:type attribute for each
extension-element.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="extension-element"

 type="javaee:extensibleType"

 maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="namespace"

 use="required"

 type="xsd:anyURI"/>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tldTaglibType">

===  <xsd:annotation>

===  <xsd:documentation>

 The taglib tag is the document root, it
defines:

 

 description a simple string describing the
"use" of this

 taglib, should be user discernable

 

 display-name the display-name element
contains a

 short name that is intended to be displayed

 by tools

 

 icon optional icon that can be used by tools

 

 tlib-version the version of the tag library
implementation

 

 short-name a simple default short name that
could be

 used by a JSP authoring tool to create

 names with a mnemonic value; for example,

 the it may be used as the prefered prefix

 value in taglib directives

 

 uri a uri uniquely identifying this taglib

 

 validator optional TagLibraryValidator
information

 

 listener optional event listener
specification

 

 tag tags in this tag library

 

 tag-file tag files in this tag library

 

 function zero or more EL functions defined
in this

 tag library

 

 taglib-extension zero or more extensions
that provide extra

 information about this taglib, for tool

 consumption

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:group ref="javaee:descriptionGroup"/>

 <xsd:element name="tlib-version"

 type="javaee:dewey-versionType">

===  <xsd:annotation>

===  <xsd:documentation>

 Describes this version (number) of the
taglibrary.

 It is described as a dewey decimal.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="short-name"

 type="javaee:tld-canonical-nameType">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines a simple default name that could be
used by

 a JSP authoring tool to create names with a

 mnemonicvalue; for example, it may be used
as the

 preferred prefix value in taglib directives.
Do

 not use white space, and do not start with
digits

 or underscore.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="uri"

 type="javaee:xsdAnyURIType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines a public URI that uniquely
identifies this

 version of the taglibrary. Leave it empty if
it

 does not apply.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="validator"

 type="javaee:validatorType"

 minOccurs="0">

 </xsd:element>

 <xsd:element name="listener"

 type="javaee:listenerType"

 minOccurs="0" maxOccurs="unbounded">

 </xsd:element>

 <xsd:element name="tag"

 type="javaee:tagType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 <xsd:element name="tag-file"

 type="javaee:tagFileType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 <xsd:element name="function"

 type="javaee:functionType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 <xsd:element name="taglib-extension"

 type="javaee:tld-extensionType"

 minOccurs="0"

 maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 Taglib extensions are for tool use only and
must not

 affect the behavior of a container.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="version"

 type="javaee:dewey-versionType"

 fixed="2.1"

 use="required">

===  <xsd:annotation>

===  <xsd:documentation>

 Describes the JSP version (number) this
taglibrary

 requires in order to function (dewey
decimal)

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:attribute>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="validatorType">

===  <xsd:annotation>

===  <xsd:documentation>

 A validator that can be used to validate

 the conformance of a JSP page to using this
tag library is

 defined by a validatorType.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"

 type="javaee:descriptionType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 <xsd:element name="validator-class"

 type="javaee:fully-qualified-classType">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines the TagLibraryValidator class that
can be used

 to validate the conformance of a JSP page to
using this

 tag library.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="init-param"

 type="javaee:param-valueType"

 minOccurs="0" maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 The init-param element contains a name/value
pair as an

 initialization param.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="variable-scopeType">

===  <xsd:annotation>

===  <xsd:documentation>

 This type defines scope of the scripting
variable. See

 TagExtraInfo for details. The allowed values
are,

 "NESTED", "AT_BEGIN" and "AT_END".

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:simpleContent>

 <xsd:restriction base="javaee:string">

 <xsd:enumeration value="NESTED"/>

 <xsd:enumeration value="AT_BEGIN"/>

 <xsd:enumeration value="AT_END"/>

 </xsd:restriction>

 </xsd:simpleContent>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="variableType">

===  <xsd:annotation>

===  <xsd:documentation>

 The variableType provides information on the
scripting

 variables defined by using this tag. It is a
(translation

 time) error for a tag that has one or more
variable

 subelements to have a TagExtraInfo class
that returns a

 non-null value from a call to
getVariableInfo().

 

 The subelements of variableType are of the
form:

 

 description Optional description of this

 variable

 

 name-given The variable name as a constant

 

 name-from-attribute The name of an attribute
whose

 (translation time) value will

 give the name of the

 variable. One of name-given or

 name-from-attribute is required.

 

 variable-class Name of the class of the
variable.

 java.lang.String is default.

 

 declare Whether the variable is declared

 or not. True is the default.

 

 scope The scope of the scripting varaible

 defined. NESTED is default.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"

 type="javaee:descriptionType"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:choice>

 <xsd:element name="name-given"

 type="javaee:java-identifierType">

===  <xsd:annotation>

===  <xsd:documentation>

 The name for the scripting variable.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="name-from-attribute"

 type="javaee:java-identifierType">

===  <xsd:annotation>

===  <xsd:documentation>

 The name of an attribute whose

 (translation-time) value will give the name
of

 the variable.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:choice>

 <xsd:element name="variable-class"

 type="javaee:fully-qualified-classType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The optional name of the class for the
scripting

 variable. The default is java.lang.String.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="declare"

 type="javaee:generic-booleanType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Whether the scripting variable is to be
defined

 or not. See TagExtraInfo for details. This

 element is optional and "true" is the
default.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="scope"

 type="javaee:variable-scopeType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The element is optional and "NESTED" is the
default.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

</xsd:schema>





=== XML Schema for TLD, JSP 2.0

The following is an XML Schema file
describing a Tag Library Descriptor in a JSP 2.0 format. This is the
same XSD as _http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd_
, except for some formatting changes to extract comments and make them
more readable. Some of the types used in this XSD are defined in the
J2EE Platform Specification (see Related Documents in the Preface for a
link to this specification).

The schema is preceeded by a set of diagrams
that graphically illustrate the element structure of the schema. The
symbols ‘+’, ‘*’, ‘|’, ‘(’ and ‘)’ have the same meaning as in DTD. In
the event of a discrepancy between these diagrams and the schema, the
schema prevails.



image:sp-24.png[image]

=== TLD Schema Element Structure



image:sp-25.png[image]

=== TLD Schema Element Structure - listener



image:sp-26.png[image]

=== TLD Schema Element Structure - tag



image:sp-27.png[image]

=== TLD Schema Element Structure - tag-file



image:sp-28.png[image]

=== TLD Schema Element Structure - function



<?xml version="1.0" encoding="UTF-8"?>

<xsd:schema


targetNamespace="http://java.sun.com/xml/ns/j2ee"

 xmlns:j2ee="http://java.sun.com/xml/ns/j2ee"

 xmlns:xsd="http://www.w3.org/2001/XMLSchema"

 elementFormDefault="qualified"

 attributeFormDefault="unqualified"

 version="2.0">

===  <xsd:annotation>

===  <xsd:documentation>

 This is the XML Schema for the JSP
Taglibrary

 descriptor. All Taglibrary descriptors must

 indicate the tag library schema by using the
Taglibrary

 namespace:

 

 http://java.sun.com/xml/ns/j2ee

 

 and by indicating the version of the schema
by

 using the version element as shown below:

 

 <taglib
xmlns="http://java.sun.com/xml/ns/j2ee"


xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

 xsi:schemaLocation="..."

 version="2.0">

 ...

 </taglib>

 

 The instance documents may indicate the
published

 version of the schema using
xsi:schemaLocation attribute

 for J2EE namespace with the following
location:

 


http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:include schemaLocation="j2ee_1_4.xsd"/>

=== <!-- **************************************************** -->

===  <xsd:element name="taglib" type="j2ee:tldTaglibType">

===  <xsd:annotation>

===  <xsd:documentation>

 The taglib tag is the document root.

 The definition of taglib is provided

 by the tldTaglibType.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:unique name="tag-name-uniqueness">

===  <xsd:annotation>

===  <xsd:documentation>

 The taglib element contains, among other
things, tag and

 tag-file elements.

 The name subelements of these elements must
each be unique.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:selector
xpath="j2ee:tag|j2ee:tag-file"/>

 <xsd:field xpath="j2ee:name"/>

 </xsd:unique>

 <xsd:unique name="function-name-uniqueness">

===  <xsd:annotation>

===  <xsd:documentation>

 The taglib element contains function
elements.

 The name subelements of these elements must
each be unique.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:selector xpath="j2ee:function"/>

 <xsd:field xpath="j2ee:name"/>

 </xsd:unique>

 </xsd:element>

=== <!-- **************************************************** -->

===  <xsd:complexType name="body-contentType">

===  <xsd:annotation>

===  <xsd:documentation>

 Specifies the type of body that is valid for
a tag.

 This value is used by the JSP container to
validate

 that a tag invocation has the correct body
syntax and

 by page composition tools to assist the page
author

 in providing a valid tag body.

 

 There are currently four values specified:

 

 tagdependent The body of the tag is
interpreted by the tag

 implementation itself, and is most likely

 in a different "language", e.g embedded SQL

 statements.

 

 JSP The body of the tag contains nested JSP

 syntax.

 

 empty The body must be empty

 

 scriptless The body accepts only template
text, EL

 Expressions, and JSP action elements. No

 scripting elements are allowed.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:simpleContent>

 <xsd:restriction base="j2ee:string">

 <xsd:enumeration value="tagdependent"/>

 <xsd:enumeration value="JSP"/>

 <xsd:enumeration value="empty"/>

 <xsd:enumeration value="scriptless"/>

 </xsd:restriction>

 </xsd:simpleContent>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="extensibleType" abstract="true">

===  <xsd:annotation>

===  <xsd:documentation>

 The extensibleType is an abstract base type
that is used to

 define the type of extension-elements.
Instance documents

 must substitute a known type to define the
extension by

 using xsi:type attribute to define the
actual type of

 extension-elements.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="functionType">

===  <xsd:annotation>

===  <xsd:documentation>

 The function element is used to provide
information on each

 function in the tag library that is to be
exposed to the EL.

 

 The function element may have several
subelements defining:

 

 description Optional tag-specific
information

 

 display-name A short name that is intended
to be

 displayed by tools

 

 icon Optional icon element that can be used

 by tools

 

 name A unique name for this function

 

 function-class Provides the name of the Java
class that

 implements the function

 

 function-signature Provides the signature,
as in the Java

 Language Specification, of the Java

 method that is to be used to implement

 the function.

 

 example Optional informal description of an

 example of a use of this function

 

 function-extension Zero or more extensions
that provide extra

 information about this function, for tool

 consumption

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:group ref="j2ee:descriptionGroup"/>

 <xsd:element name="name"

 type="j2ee:tld-canonical-nameType">

===  <xsd:annotation>

===  <xsd:documentation>

 A unique name for this function.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="function-class"

 type="j2ee:fully-qualified-classType">

===  <xsd:annotation>

===  <xsd:documentation>

 Provides the fully-qualified class name of
the Java

 class containing the static method that
implements

 the function.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="function-signature"

 type="j2ee:string">

===  <xsd:annotation>

===  <xsd:documentation>

 Provides the signature, of the static Java
method that is

 to be used to implement the function. The
syntax of the

 function-signature element is as follows:

 

 FunctionSignature ::= ReturnType S
MethodName S?

 ’(’ S? Parameters? S? ’)’

 

 ReturnType ::= Type

 

 MethodName ::= Identifier

 

 Parameters ::= Parameter

 | ( Parameter S? ’,’ S? Parameters )

 

 Parameter ::= Type

 

 Where:

 

 * Type is a basic type or a fully qualified

 Java class name (including package name),

 as per the ’Type’ production in the Java

 Language Specification, Second Edition,

 Chapter 18.

 

 * Identifier is a Java identifier, as per

 the ’Identifier’ production in the Java

 Language Specification, Second

 Edition, Chapter 18.

 

 Example:

 

 java.lang.String nickName( java.lang.String,
int )

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="example"

 type="j2ee:xsdStringType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The example element contains an informal
description

 of an example of the use of this function.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="function-extension"

 type="j2ee:tld-extensionType"

 minOccurs="0"

 maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 Function extensions are for tool use only
and must not affect

 the behavior of a container.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tagFileType">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines an action in this tag library that
is implemented

 as a .tag file.

 

 The tag-file element has two required
subelements:

 

 description Optional tag-specific
information

 

 display-name A short name that is intended
to be

 displayed by tools

 

 icon Optional icon element that can be used

 by tools

 

 name The unique action name

 

 path Where to find the .tag file
implementing this

 action, relative to the root of the web

 application or the root of the JAR file for
a

 tag library packaged in a JAR. This must

 begin with /WEB-INF/tags if the .tag file

 resides in the WAR, or /META-INF/tags if the

 .tag file resides in a JAR.

 

 example Optional informal description of an

 example of a use of this tag

 

 tag-extension Zero or more extensions that
provide extra

 information about this tag, for tool

 consumption

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:group ref="j2ee:descriptionGroup"/>

 <xsd:element name="name"

 type="j2ee:tld-canonical-nameType"/>

 <xsd:element name="path"

 type="j2ee:pathType"/>

 <xsd:element name="example"

 type="j2ee:xsdStringType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The example element contains an informal
description

 of an example of the use of a tag.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="tag-extension"

 type="j2ee:tld-extensionType"

 minOccurs="0"

 maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 Tag extensions are for tool use only and
must not affect

 the behavior of a container.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tagType">

===  <xsd:annotation>

===  <xsd:documentation>

 The tag defines a unique tag in this tag
library. It has one

 attribute, id.

 

 The tag element may have several subelements
defining:

 

 description Optional tag-specific
information

 

 display-name A short name that is intended
to be

 displayed by tools

 

 icon Optional icon element that can be used

 by tools

 

 name The unique action name

 

 tag-class The tag handler class implementing

 javax.servlet.jsp.tagext.JspTag

 

 tei-class An optional subclass of

 javax.servlet.jsp.tagext.TagExtraInfo

 

 body-content The body content type

 

 variable Optional scripting variable
information

 

 attribute All attributes of this action that
are

 evaluated prior to invocation.

 

 dynamic-attributes Whether this tag supports
additional

 attributes with dynamic names. If

 true, the tag-class must implement the

 javax.servlet.jsp.tagext.DynamicAttributes

 interface. Defaults to false.

 

 example Optional informal description of an

 example of a use of this tag

 

 tag-extension Zero or more extensions that
provide extra

 information about this tag, for tool

 consumption

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:group ref="j2ee:descriptionGroup"/>

 <xsd:element name="name"

 type="j2ee:tld-canonical-nameType"/>

 <xsd:element name="tag-class"

 type="j2ee:fully-qualified-classType">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines the subclass of
javax.serlvet.jsp.tagext.JspTag

 that implements the request time semantics
for

 this tag. (required)

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="tei-class"

 type="j2ee:fully-qualified-classType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines the subclass of
javax.servlet.jsp.tagext.TagExtraInfo

 for this tag. (optional)

 

 If this is not given, the class is not
consulted at

 translation time.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="body-content"

 type="j2ee:body-contentType">

===  <xsd:annotation>

===  <xsd:documentation>

 Specifies the format for the body of this
tag.

 The default in JSP 1.2 was "JSP" but because
this

 is an invalid setting for simple tag
handlers, there

 is no longer a default in JSP 2.0. A
reasonable

 default for simple tag handlers is
"scriptless" if

 the tag can have a body.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="variable"

 type="j2ee:variableType"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="attribute"

 type="j2ee:tld-attributeType"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="dynamic-attributes"

 type="j2ee:generic-booleanType"

 minOccurs="0"/>

 <xsd:element name="example"

 type="j2ee:xsdStringType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The example element contains an informal
description

 of an example of the use of a tag.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="tag-extension"

 type="j2ee:tld-extensionType"

 minOccurs="0"

 maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 Tag extensions are for tool use only and
must not affect

 the behavior of a container.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tld-attributeType">

===  <xsd:annotation>

===  <xsd:documentation>

 The attribute element defines an attribute
for the nesting

 tag. The attributre element may have several
subelements

 defining:

 

 description a description of the attribute

 

 name the name of the attribute

 

 required whether the attribute is required
or

 optional

 

 rtexprvalue whether the attribute is a
runtime attribute

 

 type the type of the attributes

 

 fragment whether this attribute is a
fragment

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"

 type="j2ee:descriptionType"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="name"

 type="j2ee:java-identifierType"/>

 <xsd:element name="required"

 type="j2ee:generic-booleanType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines if the nesting attribute is required
or

 optional.

 

 If not present then the default is "false",
i.e

 the attribute is optional.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:choice>

 <xsd:sequence>

 <xsd:element name="rtexprvalue"

 type="j2ee:generic-booleanType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines if the nesting attribute can have
scriptlet

 expressions as a value, i.e the value of the

 attribute may be dynamically calculated at
request

 time, as opposed to a static value
determined at

 translation time.

 

 If not present then the default is "false",
i.e the

 attribute has a static value

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="type"

 type="j2ee:fully-qualified-classType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines the Java type of the attributes
value. For

 static values (those determined at
translation time)

 the type is always java.lang.String.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:element name="fragment"

 type="j2ee:generic-booleanType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 "true" if this attribute is of type

 javax.jsp.tagext.JspFragment, representing
dynamic

 content that can be re-evaluated as many
times

 as needed by the tag handler. If omitted or
"false",

 the default is still type="java.lang.String"

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:choice>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tld-canonical-nameType">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines the canonical name of a tag or
attribute being

 defined.

 

 The name must conform to the lexical rules
for an NMTOKEN.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:simpleContent>

 <xsd:restriction
base="j2ee:xsdNMTOKENType"/>

 </xsd:simpleContent>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tld-extensionType">

===  <xsd:annotation>

===  <xsd:documentation>

 The tld-extensionType is used to indicate

 extensions to a specific TLD element.

 

 It is used by elements to designate an
extension block

 that is targeted to a specific extension
designated by

 a set of extension elements that are
declared by a

 namespace. The namespace identifies the
extension to

 the tool that processes the extension.

 

 The type of the extension-element is
abstract. Therefore,

 a concrete type must be specified by the TLD
using

 xsi:type attribute for each
extension-element.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="extension-element"

 type="j2ee:extensibleType"

 maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="namespace"

 use="required"

 type="xsd:anyURI"/>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="tldTaglibType">

===  <xsd:annotation>

===  <xsd:documentation>

 The taglib tag is the document root, it
defines:

 

 description a simple string describing the
"use" of this

 taglib, should be user discernable

 

 display-name the display-name element
contains a

 short name that is intended to be displayed

 by tools

 

 icon optional icon that can be used by tools

 

 tlib-version the version of the tag library
implementation

 

 short-name a simple default short name that
could be

 used by a JSP authoring tool to create

 names with a mnemonic value; for example,

 the it may be used as the prefered prefix

 value in taglib directives

 

 uri a uri uniquely identifying this taglib

 

 validator optional TagLibraryValidator
information

 

 listener optional event listener
specification

 

 tag tags in this tag library

 

 tag-file tag files in this tag library

 

 function zero or more EL functions defined
in this

 tag library

 

 taglib-extension zero or more extensions
that provide extra

 information about this taglib, for tool

 consumption

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:group ref="j2ee:descriptionGroup"/>

 <xsd:element name="tlib-version"

 type="j2ee:dewey-versionType">

===  <xsd:annotation>

===  <xsd:documentation>

 Describes this version (number) of the
taglibrary.

 It is described as a dewey decimal.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="short-name"

 type="j2ee:tld-canonical-nameType">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines a simple default name that could be
used by

 a JSP authoring tool to create names with a

 mnemonicvalue; for example, it may be used
as the

 preferred prefix value in taglib directives.
Do

 not use white space, and do not start with
digits

 or underscore.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="uri"

 type="j2ee:xsdAnyURIType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines a public URI that uniquely
identifies this

 version of the taglibrary. Leave it empty if
it

 does not apply.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="validator"

 type="j2ee:validatorType"

 minOccurs="0">

 </xsd:element>

 <xsd:element name="listener"

 type="j2ee:listenerType"

 minOccurs="0" maxOccurs="unbounded">

 </xsd:element>

 <xsd:element name="tag"

 type="j2ee:tagType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 <xsd:element name="tag-file"

 type="j2ee:tagFileType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 <xsd:element name="function"

 type="j2ee:functionType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 <xsd:element name="taglib-extension"

 type="j2ee:tld-extensionType"

 minOccurs="0"

 maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 Taglib extensions are for tool use only and
must not affect

 the behavior of a container.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="version"

 type="j2ee:dewey-versionType"

 fixed="2.0"

 use="required">

===  <xsd:annotation>

===  <xsd:documentation>

 Describes the JSP version (number) this
taglibrary

 requires in order to function (dewey
decimal)

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:attribute>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="validatorType">

===  <xsd:annotation>

===  <xsd:documentation>

 A validator that can be used to validate

 the conformance of a JSP page to using this
tag library is

 defined by a validatorType.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"

 type="j2ee:descriptionType"

 minOccurs="0"

 maxOccurs="unbounded"/>

 <xsd:element name="validator-class"

 type="j2ee:fully-qualified-classType">

===  <xsd:annotation>

===  <xsd:documentation>

 Defines the TagLibraryValidator class that
can be used

 to validate the conformance of a JSP page to
using this

 tag library.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="init-param"

 type="j2ee:param-valueType"

 minOccurs="0" maxOccurs="unbounded">

===  <xsd:annotation>

===  <xsd:documentation>

 The init-param element contains a name/value
pair as an

 initialization param.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="variable-scopeType">

===  <xsd:annotation>

===  <xsd:documentation>

 This type defines scope of the scripting
variable. See

 TagExtraInfo for details. The allowed values
are,

 "NESTED", "AT_BEGIN" and "AT_END".

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:simpleContent>

 <xsd:restriction base="j2ee:string">

 <xsd:enumeration value="NESTED"/>

 <xsd:enumeration value="AT_BEGIN"/>

 <xsd:enumeration value="AT_END"/>

 </xsd:restriction>

 </xsd:simpleContent>

===  </xsd:complexType>

=== <!-- **************************************************** -->

===  <xsd:complexType name="variableType">

===  <xsd:annotation>

===  <xsd:documentation>

 The variableType provides information on the
scripting

 variables defined by using this tag. It is a
(translation

 time) error for a tag that has one or more
variable

 subelements to have a TagExtraInfo class
that returns a

 non-null value from a call to
getVariableInfo().

 

 The subelements of variableType are of the
form:

 

 description Optional description of this

 variable

 

 name-given The variable name as a constant

 

 name-from-attribute The name of an attribute
whose

 (translation time) value will

 give the name of the

 variable. One of name-given or

 name-from-attribute is required.

 

 variable-class Name of the class of the
variable.

 java.lang.String is default.

 

 declare Whether the variable is declared

 or not. True is the default.

 

 scope The scope of the scripting varaible

 defined. NESTED is default.

===  </xsd:documentation>

===  </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"

 type="j2ee:descriptionType"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:choice>

 <xsd:element name="name-given"

 type="j2ee:java-identifierType">

===  <xsd:annotation>

===  <xsd:documentation>

 The name for the scripting variable.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="name-from-attribute"

 type="j2ee:java-identifierType">

===  <xsd:annotation>

===  <xsd:documentation>

 The name of an attribute whose

 (translation-time) value will give the name
of

 the variable.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:choice>

 <xsd:element name="variable-class"

 type="j2ee:fully-qualified-classType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The optional name of the class for the
scripting

 variable. The default is java.lang.String.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="declare"

 type="j2ee:generic-booleanType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 Whether the scripting variable is to be
defined

 or not. See TagExtraInfo for details. This

 element is optional and "true" is the
default.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 <xsd:element name="scope"

 type="j2ee:variable-scopeType"

 minOccurs="0">

===  <xsd:annotation>

===  <xsd:documentation>

 The element is optional and "NESTED" is the
default.

===  </xsd:documentation>

===  </xsd:annotation>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="id" type="xsd:ID"/>

===  </xsd:complexType>

</xsd:schema>



=== DTD for TLD, JSP 1.2

The following is a DTD describing a Tag
Library Descriptor file in JSP 1.2 format. This is the same DTD as
"http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd", except for some
formatting changes to extract comments and make them more readable: __

<!-- +
This is the DTD defining the JavaServer Pages 1.2 Tag Library descriptor
(.tld) (XML) file format/syntax. +
A Tag Library is a JAR file containing a valid instance of a Tag Library
Descriptor file, along with the appropriate implementation classes and
other resources required to implement the actions defined therein. When
deployed inside a JAR file, the tag library descriptor files must be in
the META-INF directory, or a subdirectory of it. When deployed directly
into a web application, the tag library descriptor files must always be
in the WEB-INF directory, or some subdirectory of it. +
Packaged tag libraries must have at least one tag library descriptor
file. The JSP 1.1 specification allowed for only a single TLD, in
META-INF/taglib.tld, but in JSP 1.2 multiple tag libraries are
allowed. +
Use is subject to license terms. +
-->

<!NOTATION WEB-JSPTAGLIB.1_2 PUBLIC “-//Sun
Microsystems, Inc.//DTD JSP Tag Library 1.2//EN”>

<!-- +
All JSP 1.2 tag library descriptors must include a DOCTYPE of the
following form:

<!DOCTYPE taglib PUBLIC "-//Sun Microsystems,
Inc.//DTD JSP Tag Library 1.2//EN"
"http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd"> +
-->

<!-- +
The taglib element is the document root, it defines: +
 +
tlib-version the version of the tag library implementation +
jsp-version the version of JSP the tag library depends upon +
short-name a simple default name that could be used by a JSP authoring
tool to create names with a mnemonic value; for example, the it may be
used as the prefered prefix value in taglib directives +
uri a uri uniquely identifying this taglib +
display-name the display-name element contains a short name that is
intended to be displayed by tools +
small-icon optional small-icon that can be used by tools +
large-icon optional large-icon that can be used by tools +
description a simple string describing the “use” of this taglib, should
be user discernable +
validator optional TagLibraryValidator information +
listener optional event listener specification +
-->

<!ELEMENT taglib (tlib-version, jsp-version,
short-name, uri?, display-name?, small-icon?, large-icon?, description?,
validator?, listener*, tag+) >

<!ATTLIST taglib +
id ID #IMPLIED +
xmlns CDATA #FIXED “http://java.sun.com/JSP/TagLibraryDescriptor”> +
<!-- +
The value of the tlib-version element describes this version (number) of
the taglibrary. This element is mandatory. +
 +
#PCDATA ::= [0-9]*\{ “.”[0-9] }0..3 +
-->

<!ELEMENT tlib-version (#PCDATA)

<!-- +
The value of the jsp-version element describes the JSP version (number)
this taglibrary requires in order to function. This element is
mandatory. The value that should be used for JSP 1.2 is "1.2" (no
quotes). +
 +
#PCDATA ::= [0-9]*\{ “.”[0-9] }0..3 +
-->

<!ELEMENT jsp-version (#PCDATA) >

<!-- +
The value of the short-name element is a name that could be used by a
JSP authoring tool to create names with a mnemonic value; for example,
it may be used as the prefered prefix value in taglib directives. +
 +
Do not use white space, and do not start with digits or underscore. +
 +
#PCDATA ::= NMTOKEN +
-->

<!ELEMENT short-name (#PCDATA) >

<!-- +
The value of the uri element is a public URI that uniquely identifies
the exact semantics of this taglibrary. +
-->

<!ELEMENT uri (#PCDATA) >

<!-- +
The value of the description element is an arbitrary text string
describing the tag library. +
-->

<!ELEMENT description (#PCDATA) >

<!-- +
The validator element provides information on an optional validator that
can be used to validate the conformance of a JSP page to using this tag
library. +
-->

<!ELEMENT validator (validator-class,
init-param*, description?) >

<!-- +
The validator-class element defines the TagLibraryValidator class that
can be used to validate the conformance of a JSP page to using this tag
library. +
-->

<!ELEMENT validator-class (#PCDATA) >

<!-- +
The init-param element contains a name/value pair as an initialization
param. +
-->

<!ELEMENT init-param (param-name,
param-value, description?)>

<!-- +
The param-name element contains the name of a parameter. +
-->

<!ELEMENT param-name (#PCDATA)>

<!-- +
The param-value element contains the value of a parameter. +
-->

<!ELEMENT param-value (#PCDATA)>

<!-- +
The listener element defines an optional event listener object to be
instantiated and registered automatically. +
-->

<!ELEMENT listener (listener-class) >

<!-- +
The listener-class element declares a class in the application that must
be registered as a web application listener bean. +
 +
See the Servlet 2.3 specification for details. +
-->

<!ELEMENT listener-class (#PCDATA) >

<!-- +
The tag element defines an action in this tag library. The tag element
has one attribute, id. +
The tag element may have several subelements defining: +
name The unique action name +
tag-class The tag handler class implementing
javax.servlet.jsp.tagext.Tag +
tei-class An optional subclass of
javax.servlet.jsp.tagext.TagExtraInfo +
body-content The body content type +
display-name A short name that is intended to be displayed by tools +
small-icon Optional small-icon that can be used by tools +
large-icon Optional large-icon that can be used by tools +
description Optional tag-specific information +
variable Optional scripting variable information +
attribute All attributes of this action +
example Optional informal description of an example of a use of this
action. +
-->

<!ELEMENT tag (name, tag-class, tei-class?,
body-content?, display-name?, small-icon?, large-icon?, description?,
variable*, attribute*, example?) >

<!-- +
The tag-class element indicates the subclass of
javax.serlvet.jsp.tagext.Tag that implements the request time semantics
for this tag. This element is required. +
 +
#PCDATA ::= fully qualified Java class name +
-->

<!ELEMENT tag-class (#PCDATA) >

<!-- +
The tei-class element indicates the subclass of
javax.servlet.jsp.tagext.TagExtraInfo for this tag. The class is
instantiated at translation time. This element is optional. +
 +
#PCDATA ::= fully qualified Java class name +
-->

<!ELEMENT tei-class (#PCDATA) >

<!-- +
The body-content element provides provides information on the content of
the body of this tag. This element is primarily intended for use by page
composition tools. +
There are currently three values specified: +
 +
tagdependent The body of the tag is interpreted by the tag
implementation itself, and is most likely in a different “langage”, e.g
embedded SQL statements. +
JSP The body of the tag contains nested JSP syntax +
empty The body must be empty +
This element is optional; the default value is JSP +
 +
#PCDATA ::= tagdependent | JSP | empty +
-->

<!ELEMENT body-content (#PCDATA) >

<!-- +
The display-name element contains a short name that is intended to be
displayed by tools. +
-->

<!ELEMENT display-name (#PCDATA) >

<!-- +
The large-icon element contains the name of a file containing a large
(32 x 32) icon image. The icon can be used by tools. The file name is a
relative path within the tag library. +
The image must be either in the JPEG or GIF format, and the file name
must end with the suffix “.jpg” or “.gif” respectively. +
-->

<!ELEMENT large-icon (#PCDATA) >

<!-- +
The small-icon element contains the name of a file containing a small
(16 x 16) icon image. The icon can be used by tools. The file name is a
relative path within the tag library. +
The image must be either in the JPEG or GIF format, and the file name
must end with the suffix “.jpg” or “.gif” respectively. +
-->

<!ELEMENT small-icon (#PCDATA) >

<!-- +
The example element provides an informal description of an example of
the use of a tag. +
-->

<!ELEMENT example (#PCDATA) >

<!-- +
The variable element provides information on the scripting variables
defined by this tag. +
 +
It is a (translation time) error for an action that has one or more
variable subelements to have a TagExtraInfo class that returns a
non-null object. +
 +
The subelements of variable are of the form: +
 +
name-given The variable name as a constant +
name-from-attribute The name of an attribute whose (translation time)
value will give the name of the variable. One of name-given or
name-from-attribute is required. +
variable-class Name of the class of the variable. java.lang.String is
default. +
declare Whether the variable is declared or not. True is the default. +
scope The scope of the scripting variable defined. NESTED is default. +
-->

<!ELEMENT variable ( (name-given |
name-from-attribute), variable-class?, declare?, scope?, description?) >

<!-- +
The name-given element provides the name for the scripting variable. +
 +
One of name-given or name-from-attribute is required. +
-->

<!ELEMENT name-given (#PCDATA) >

<!-- +
The value of the name-from-attribute element is the name of an attribute
whose (translation-time) value will give the name of the variable. +
 +
One of name-given or name-from-attribute is required. +
-->

<!ELEMENT name-from-attribute (#PCDATA) >

<!-- +
The variable-class element is the name of the class for the scripting
variable. +
 +
This element is optional; the default is java.lang.String. +
-->

<!ELEMENT variable-class (#PCDATA) >

<!-- +
The value of the declare element indicates whether the scripting
variable is to be defined or not. See TagExtraInfo for details. +
 +
This element is optional and is the default is true. +
-->

<!ELEMENT declare (#PCDATA) >

<!-- +
The value of the scope element describes the scope of the scripting
variable. +
 +
See TagExtraInfo for details. +
 +
This element is optional and the default value is the string “NESTED”.
The other legal values are “AT_BEGIN” and “AT_END”. +
-->

<!ELEMENT scope (#PCDATA) >

<!-- +
The attribute element defines an attribute for the nesting tag. +
 +
The attributre element may have several subelements defining: +
name the name of the attribute +
attribute whether the attribute is required or optional +
rtexpravalue whether the attribute is a runtime attribute +
type the type of the attributes +
description a description of the attribute +
-->

<!ELEMENT attribute (name, required? ,
rtexprvalue?, type?, description?) >

<!-- +
The name element defines the canonical name of a tag or attribute being
defined +
 +
#PCDATA ::= NMTOKEN +
-->

<!ELEMENT name (#PCDATA) >

<!-- +
The value of the required element indicates if the nesting attribute is
required or optional. This attribute is optional and its default value
is false. +
 +
#PCDATA ::= true | false | yes | no +
-->

<!ELEMENT required (#PCDATA) >

<!-- +
The value of the rtexpvalue element indicates if the value of the
attribute may be dynamically calculated at request time, as opposed to a
static value determined at translation time. This attribute is optional
and its default value is false +
 +
#PCDATA ::= true | false | yes | no +
-->

<!ELEMENT rtexprvalue (#PCDATA) >

<!-- +
The value of the type element describes the Java type of the attributes
value. +
 +
For static values (those determined at translation time) the type is
always java.lang.String. +
-->

<!ELEMENT type (#PCDATA) >

<!-- ID attributes -->

<!ATTLIST tlib-version id ID #IMPLIED>

<!ATTLIST jsp-version id ID #IMPLIED>

<!ATTLIST short-name id ID #IMPLIED>

<!ATTLIST uri id ID #IMPLIED>

<!ATTLIST description id ID #IMPLIED>

<!ATTLIST example id ID #IMPLIED>

<!ATTLIST tag id ID #IMPLIED>

<!ATTLIST tag-class id ID #IMPLIED>

<!ATTLIST tei-class id ID #IMPLIED>

<!ATTLIST body-content id ID #IMPLIED>

<!ATTLIST attribute id ID #IMPLIED>

<!ATTLIST name id ID #IMPLIED>

<!ATTLIST required id ID #IMPLIED>

<!ATTLIST rtexprvalue id ID #IMPLIED>

<!ATTLIST param-name id ID #IMPLIED>

<!ATTLIST param-value id ID #IMPLIED>

<!ATTLIST listener id ID #IMPLIED>

<!ATTLIST listener-class id ID #IMPLIED>

=== DTD for TLD, JSP 1.1

The following is a DTD describing a Tag
Library Descriptor file in JSP 1.1 format. This is the same DTD as
_http://java.sun.com/dtd/web-jsptaglibrary_1_1.dtd_ , except for some
formatting changes to extract comments and make them more readable:

<!-- +
This is the DTD defining the JavaServer Pages 1.1 Tag Library descriptor
(.tld) (XML) file format/syntax. +
 +
A Tag Library is a JAR file containing a valid instance of a Tag Library
Descriptor (taglib.tld) file in the META-INF subdirectory, along with
the appropriate implementing classes, and other resources required
toimplement the tags defined therein. +
 +
Use is subject to license terms. +
-->

<!-- +
The taglib tag is the document root, it defines: +
tlibversion the version of the tag library implementation +
jspversion the version of JSP the tag library depends upon +
shortname a simple default short name that could be used by a JSP
authoring tool to create names with a mnemonic value; for example, the
it may be used as the prefered prefix value in taglib directives +
uri a uri uniquely identifying this taglib +
info a simple string describing the “use” of this taglib, should be user
discernable +
-->

<!ELEMENT taglib (tlibversion, jspversion?,
shortname, uri?, info?, tag+) >

<!ATTLIST taglib id ID #IMPLIED +
xmlns CDATA #FIXED +
“http://java.sun.com/dtd/web-jsptaglibrary_1_1.dtd” +
>

<!-- +
Describes this version (number) of the taglibrary (dewey decimal) +
 +
#PCDATA ::= [0-9]*\{ “.”[0-9] }0..3 +
-->

<!ELEMENT tlibversion (#PCDATA) >

<!-- +
Describes the JSP version (number) this taglibrary requires in order to
function (dewey decimal) +
 +
The default is 1.1 +
 +
#PCDATA ::= [0-9]*\{ “.”[0-9] }0..3 +
-->

<!ELEMENT jspversion (#PCDATA) >

<!-- +
Defines a short (default) shortname to be used for tags and variable
names used/created by this tag library. Do not use white space, and do
not start with digits or underscore. +
 +
#PCDATA ::= NMTOKEN +
-->

<!ELEMENT shortname (#PCDATA) >

<!-- +
Defines a public URI that uniquely identifies this version of the
taglibrary Leave it empty if it does not apply. +
-->

<!ELEMENT uri (#PCDATA) >

<!-- +
Defines an arbitrary text string descirbing the tag library +
-->

<!ELEMENT info (#PCDATA) >

<!-- +
The tag defines a unique tag in this tag library, defining: +
- the unique tag/element name +
- the subclass of javax.servlet.jsp.tagext.Tag implementation class +
- an optional subclass of javax.servlet.jsp.tagext.TagExtraInfo +
- the body content type (hint) +
- optional tag-specific information +
- any attributes +
-->

<!ELEMENT tag (name, tagclass, teiclass?,
bodycontent?, info?, attribute*) >

<!-- +
Defines the subclass of javax.serlvet.jsp.tagext.Tag that implements the
request time semantics for this tag. (required) +
 +
#PCDATA ::= fully qualified Java class name +
-->

<!ELEMENT tagclass (#PCDATA) >

<!-- +
Defines the subclass of javax.servlet.jsp.tagext.TagExtraInfo for this
tag. (optional) +
 +
If this is not given, the class is not consulted at translation time. +
 +
#PCDATA ::= fully qualified Java class name +
-->

<!ELEMENT teiclass (#PCDATA) >

<!-- +
Provides a hint as to the content of the body of this tag. Primarily
intended for use by page composition tools. +
 +
There are currently three values specified: +
tagdependent The body of the tag is interpreted by the tag
implementation itself, and is most likely in a different “langage”, e.g
embedded SQL statements. +
JSP The body of the tag contains nested JSP syntax +
empty The body must be empty. The default (if not defined) is JSP +
 +
#PCDATA ::= tagdependent | JSP | empty +
-->

<!ELEMENT bodycontent (#PCDATA) >

<!-- +
The attribute tag defines an attribute for the nesting tag +
 +
An attribute definition is composed of: +
- the attributes name (required) +
- if the attribute is required or optional (optional) +
- if the attributes value may be dynamically calculated at runtime by a
scriptlet expression (optional) +
-->

<!ELEMENT attribute (name, required? ,
rtexprvalue?) >

<!-- +
Defines the canonical name of a tag or attribute being defined +
 +
#PCDATA ::= NMTOKEN +
-->

<!ELEMENT name (#PCDATA) >

<!-- +
Defines if the nesting attribute is required or optional. +
 +
#PCDATA ::= true | false | yes | no +
 +
If not present then the default is “false”, i.e the attribute is
optional. +
-->

<!ELEMENT required (#PCDATA) >

<!-- +
Defines if the nesting attribute can have scriptlet expressions as a
value, i.e the value of the attribute may be dynamically calculated at
request time, as opposed to a static value determined at translation
time. +
 +
#PCDATA ::= true | false | yes | no +
 +
If not present then the default is “false”, i.e the attribute has a
static value +
-->

<!ELEMENT rtexprvalue (#PCDATA) >

<!ATTLIST tlibversion id ID #IMPLIED>

<!ATTLIST jspversion id ID #IMPLIED>

<!ATTLIST shortname id ID #IMPLIED>

<!ATTLIST uri id ID #IMPLIED>

<!ATTLIST info id ID #IMPLIED>

<!ATTLIST tag id ID #IMPLIED>

<!ATTLIST tagclass id ID #IMPLIED>

<!ATTLIST teiclass id ID #IMPLIED>

<!ATTLIST bodycontent id ID #IMPLIED>

<!ATTLIST attribute id ID #IMPLIED>

<!ATTLIST name id ID #IMPLIED>

<!ATTLIST required id ID #IMPLIED>

<!ATTLIST rtexprvalue id ID #IMPLIED>

 __ 

=== APPENDIX

[[a5854]]Page Encoding Detection

This appendix details the algorithm
containers are required to use in order to determine the character
encoding for a JSP page or tag file. See link:jsp.html#a1339[See
Internationalization Issues.] for details on where this algorithm is
used. The algorithm is designed to maximize convenience to the page
author, while preserving backwards compatibility with previous versions
of the JSP specification.

=== [[a5856]]Detection Algorithm for JSP pages

The following is a complete though
unoptimized algorithm for determining the character encoding for a JSP
file. JSP containers may use an optimized version of this algorithm, but
it must detect the same encoding as the algorithm in all cases.

. Decide whether the source file is a JSP
page in standard syntax or a JSP document in XML syntax.
. If there is a _<is-xml>_ element in a
_<jsp-property-group>_ that names this file, then if it has the value "
_true_ ", the file is a JSP document, and if it has the value " _false_
", the file is not a JSP document.
. Otherwise, if the file name has the
extension " _jspx_ ", the file is a JSP document.
. Otherwise, try to find a _<jsp:root>_
element in the file.
. Determine the initial encoding from the
first four bytes of the file, as described in appendix F.1 of the XML
1.0 specification. For the byte sequence " _3C 3F 78 6D_ ", use
_ISO-8859-1_ ; for the byte sequence " _4C 6F A7 94_ ", use _IBM037_ ;
for all other cases, use the _UTF-*_ or _UCS-*_ encoding given in the
appendix.
. Read the file using the initial encoding
and search for a _<jsp:root>_ element. If the element is found and is
the top element, the file is a JSP document in XML syntax
. Otherwise, the file is a JSP page in
standard syntax.

=== Reset the file.

=== If the file is a JSP page in standard syntax: +
 +
3.1 If the file is not preceded by a BOM:

. Check whether there is a JSP configuration
element _<page-encoding>_ whose URL pattern matches this file.
. Read the file using the initial encoding
and search for a _pageEncoding_ attribute in a page declaration. The
specification requires the attribute to be found only if it is not
preceded by non-ASCII characters, so simplified implementations are
allowed.
. Report an error if there are a
_<page-encoding>_ configuration element whose URL pattern matches this
file and a _pageEncoding_ attribute, and the two name different
encodings.
. If there is a _<page-encoding>_
configuration element whose URL pattern matches this file, the page
character encoding is the one named in this element.
. Otherwise, if there is a _pageEncoding_
attribute, the page character encoding is the one named in this
attribute.
. Otherwise, read the file using the initial
encoding and search for a charset value within a _contentType_ attribute
in a page declaration. If it exists, the page character encoding is the
one named in this charset value. The specification requires the
attribute to be found only if it is not preceded by non-ASCII
characters, so simplified implementations are allowed.
. Otherwise, the page character encoding is
_ISO-8859-1_ .

=== 3.2 If the file is preceded by a BOM:

. Read the file using the encoding indicated
by the BOM, and search for a pageEncoding attribute in a page
declaration.
. Report an error if any of the following
conditions are met:
. There is a <page-encoding> configuration
element whose URL pattern matches this page and whose encoding does not
match the encoding indicated by the BOM.
. There is a pageEncoding page directive
attribute whose encoding does not match the encoding indicated by the
BOM.

=== If the file is a JSP document in XML syntax, use these steps.

. Determine the page character encoding as
described in appendix F.1 of the XML 1.0 specification. Note whether the
encoding was named in the encoding attribute of the XML prolog or just
derived from the initial bytes.
. Check whether there is a JSP configuration
element _<page-encoding>_ whose URL pattern matches this file.
. Read the file using the detected encoding
and search for a _pageEncoding_ attribute in a _<jsp:directive.page>_
element.
. Report an error if any of the following
conditions is met:
. The XML prolog names an encoding and there
is _<page-encoding>_ configuration element whose URL pattern matches
this file and which names a different encoding.
. The XML prolog names an encoding and there
is a _pageEncoding_ attribute which names a different encoding.
. There are a _<page-encoding>_ configuration
element whose URL pattern matches this file and a _pageEncoding_
attribute, and the two name different encodings.

=== Reset the file and read it using the page character encoding. __

=== Detection Algorithm for Tag Files

The following details the algorithm for
determining the character

encoding for a tag file. JSP containers may
use an optimized version

of this algorithm, but it must detect the
same encoding as the algorithm

in all cases.

. Determine whether the source file is a tag
file in standard or XML syntax.
. If the file name has the extension "tagx",
the file is a tag file in XML syntax. Otherwise, it is a tag file in
standard syntax.

=== If the file is a tag file in standard syntax, use these steps:

=== 2.1 If the file is not preceded by a BOM:

. Read the file using the initial default
encoding and search for a _pageEncoding_ attribute in a tag directive.
The specification requires the attribute to be found only if it is not
preceded by non-ASCII characters.
. If there is a _pageEncoding_ attribute, the
page character encoding is the one named in this attribute.
. Otherwise, the page character encoding is
_ISO-8859-1_ .
. Reset the file and read it using the page
character encoding.

=== 2.2 If the file is preceded by a BOM:

. Read the file using the encoding indicated
by the BOM, and search for a pageEncoding attribute in a tag directive.
. Report an error if there is a pageEncoding
tag directive attribute whose encoding does not match the encoding
indicated by the BOM.

=== If the file is a JSP document in XML syntax, use these steps.

. Determine the page character encoding as
described in appendix F.1 of the XML 1.0 specification.
. Read the file using the detected encoding.

=== APPENDIX

[[a5908]]Changes

This appendix lists the changes in the
JavaServer Pages specification. This appendix is non-normative.

=== Changes between JSP 2.3 and JSP 2.2

* Added link:jsp-1.html#a13[See JSP
2.3 Relation to JSP 2.2.]
* In link:jsp.html#a1164[See
Resolution of Variables and their Properties.], added
link:jsp.html#a1169[See The ELresolver returned by
ExpressionFactory.getStreamELResolver()..] and
link:jsp.html#a1170[See javax.el.StaticFieldResolver.].
* In link:jsp.html#a2885[See JSP Page
Model.], add the following paragraph.

The JSP container must render a JSP page for
the HTTP methods GET, POST, and HEAD, with identical responses. The
behavior of the JSP container is undefined for other methods.

=== Changes between JSP 2.2 and JSP 2.1 Final Release

* Added JSP.3.3.9 Declaring Default Content
Type.
* Added JSP.3.3.10 Setting Default Buffer
Size.
* Added JSP.3.3.11 Raising Errors for
Undeclared Namespaces
* Table JSP.5-7 Added an omit attribute to
<jsp:attribute>
* Changed the last sentence of second
paragraph of Section JSP.3.3 from

The exception is the _page-encoding_
property, which applies separately to each JSP file matched by its URL
pattern.



to



The exception is the _page-encoding and
ix-xml_ property, which applies separately to each JSP file matched by
its URL pattern.



* Change the last sentence of entry 1 of the
semantics section of JSP.5.1 from

The inspection is done synchronized per scope
namespace to avoid non-deterministic behavior.



to



For application and session scope, the
inspection is done synchronized per scope namespace to avoid
non-deterministic behavior.



* Changed the first sentence of the second
paragraph of JSP.5.6 from

When doing _jsp:include_ or _jsp:forward_ ,
the included page or forwarded page will see the original request
object, with the original parameters augmented with the new parameters,
with new values taking precedence over existing values when applicable.



to



When doing _jsp:include_ or _jsp:forward_ ,
the included page or forwarded page will see the original request
object, with the original parameters augmented with the new parameters,
in the order of appearance, with new values taking precedence over
existing values when applicable.



* Changed the last sentence of alias
description in Table JSP.8-4 from

A translation error must occur if the value
of _alias_ is the same as the value of a _name_ attribute of an
_attribute_ directive or the _name-given_ attribute of a _variable_
directive in the same translation unit.



to



A translation error must occur if the value
of _alias_ is the same as the value of a _name_ attribute of an
_attribute_ directive or the _alias or name-given_ attribute of a
_variable_ directive in the same translation unit.



* Added to the 7th prargraph of the package
description for javax.servlet.jsp.tagext in Part II, after "1.Classic
Tag Handlers/Properties"

To prevent confusion, a tag handler with an
empty body must not reuse any previous tag handler with a non-empty
body.



* In the package description for
javax.servlet.jsp.tagext in Part II, under the topic " Invocation of a
JSP Fragment",corrected the second to last sentence of step 1, from "the
scoped attribute is removed from the tag file’s page scope." to "the
scoped attribute is removed from the calling page’spage scope."
* Clarified javadocs for
TagLibraryValidator’s uri parameter.
* Fixed errors in the examples in JSP.10.3.3,
JSP.10.3.4, and JSP.10.3.5.
* Fixed an error in the example in
JSP.1.12.2.
* Fixed errors in the examples in JSP.8.3.

=== Changes between JSP 2.1 Proposed Final Draft 2 and JSP 2.1 Final Release

* Added to the end of Section JSP.1.4.3
("Using JSPs as Error Pages"):

A JSP container must detect if a JSP error
page is self-referencing and throw

a translation error.



* Section JSP.7.1.11 (""): Changed last
paragraph from:

Finally, note that injection is not supported
on JSP pages or tag files.

This is because all the information
represented by injection annotations

needs to be kown at deployment time. If an
annotation is included in a

JSP page or tag file, it won’t be seen at
deployment time (unless the JSP

was being precompiled during deployment).



to



Resource injection is not supported for JSP
pages or tag files.



* Added to the end of JSP.8.3 ("Semantics of
Tag Files"):

If a tag file in XML syntax contains a
jsp:root element, the value of its

"version" attribute must match the tag file’s
JSP version. See Section

JSP.8.4.2 ("Packaging in a JAR") and Section
JSP.8.4.3 ("Packaging Directly

in a Web Application") for how the JSP
version of a tag file is

determined.



* Added to Section "Backwards Compatibility
with JSP 2.0":

In a tag file, #\{expr} in template text is
handled according to the tag file’s JSP

version: If the tag file’s JSP version is 2.0
or less, #\{expr} in template

text will not cause any error. If the tag
file’s JSP version is equal to or

greater than 2.1, #\{expr} in template text
must cause an error, unless it

has been escaped or the tag file contains a

deferredSyntaxAllowedAsLiteral tag directive
attribute set to TRUE. See

Section JSP.8.4.2 ("Packaging in a JAR") and
Section JSP.8.4.3 ("Packaging

Directly in a Web Application") for how the
JSP version of a tag file is

determined.



* Changed the signature of the
getAttributeNamesInScope method in javax.servlet.jsp.JspContext from

abstract public Enumeration
getAttributeNamesInScope(int scope);

to

abstract public Enumeration<String>
getAttributeNamesInScope(int scope);

=== Changes between JSP 2.1 Proposed Final Draft and JSP 2.1 Proposed Final Draft 2

=== Resource Injection

* Augmented
link:JSP_Tag_Extensions.html#UNKNOWN[] to clarify exactly which
annotations are supported.

=== JSP document syntax and the DOCTYPE prologue

* There are some peculiarities involved to be
able to validate a JSP Document according to a DTD. Augmented
link:jsp.html#a1849[See JSP Document Validation.] and
link:jsp.html#a1971[See Example: Using Custom Actions and Tag
Files.] to clarify these peculiarities.

=== Page Character Encoding

* Clarified the page character encoding
algorithms to take into account tag files in both JSP and XML syntax.
link:jsp.html#a1351[See Page Character Encoding.] and Appendix
D, "Page Encoding Detection" have been updated.

=== EL Resolvers

* Clarified that all ELResolvers added via
JspApplicationContext.addELResolver() are processed in the same order in
which they were registered. See link:jsp.html#a1164[See
Resolution of Variables and their Properties.].

=== JSP Version of Tag Files

* Clarified how the JSP version of tag files
is determined: Tag files packaged in a JAR file inherit the JSP version
from the referencing TLD. For tag files packaged directly in a web
application, the JSP version defaults to 2.0 and may be configured from
the JSP version of a TLD with the reserved name implicit.tld placed in
the same directory as the tag files. The implicit.tld may also be used
to configure the tlib-version of an implicit tag library. See
link:JSP_Tag_Files.html#UNKNOWN[] and
link:jsp.html#a2356[See Packaging Directly in a Web
Application.].

=== Unsupported Tag Directive and Attribute Directive Attributes in Pre-2.1 Tag Files

* Specifying the
deferredSyntaxAllowedAsLiteral tag directive attribute (see
link:jsp.html#a2399[See The tag Directive.]), and the
deferredValue, deferredValueType, deferredMethod, and
deferredMethodSignature attribute directive attributes (see
link:jsp.html#a2435[See The attribute Directive.]) in a tag file
whose JSP version is less than 2.1 must cause a translation error.

=== Static Attribute

* link:jsp.html#a1078[See Static
Attribute.] has been clarified.

=== Changes between JSP 2.1 Public Review and JSP 2.1 Proposed Final Draft

=== Resource Injection

* In a Java EE environment, tag handlers and
event listeners may now satisfy external resource dependencies through
the process of "Resource Injection". See
link:JSP_Tag_Extensions.html#UNKNOWN[].

=== Deferred expressions in tag files

* In order to support deferred expressions in
tag files, the following changes were made:
* Added method _createValueExpression_ to
_javax.el.ExpressionFactory._
* Updated Section 2.3.5 "Dynamic Attribute or
Deferred Expression".
* Updated Sections JSP.8.3 "Semantics of Tag
Files" and JSP.8.5.2 "The attribute Directive".

=== Deferred expressions for dynamic attributes

The javadoc of package
javax.servlet.jsp.tagext now clarifies how deferred expressions are
supported as dynamic attributes.

=== ResourceBundleELResolver

* We now support the concept of a
ResourceBundle EL Resolver to allow internationalization via the EL. See
javax.el.ResourceBundleResolver and link:jsp.html#a1164[See
Resolution of Variables and their Properties.].

=== Clarified required support for JSR-45 ("Debugging Support for Other Languages")

* Updated link:jsp.html#a2984[See
Debugging Requirements.] to be consistent with
link:jsp.html#a253[See Debugging JSP Pages.] where it is stated
that support for JSR-45 is required.

=== Byte Order Mark and Page Encoding

The JSP spec now supports Byte Order Marks
(BOM) as authoritative page encoding declarations for JSP pages in
standard syntax. link:jsp.html#a1351[See Page Character
Encoding.] and link:jsp.html#a5856[See Detection Algorithm for
JSP pages.] have been updated.

=== TagAttributeInfo

Now supports a getter on to return the string
specified for the <description> subelement of <attribute> (must have
been an oversight in previous versions of the specification). See also
link:jsp.html#a6087[See TLD schema now supports deferred
expressions as attributes.].

=== Taglib map order of precedence

* In link:jsp.html#a2142[See TLD
resource path.], added the Java EE platform tag libraries at the highest
level for the order of precedence.

=== Generics

* Since JSP 2.1 requires J2SE 5.0, we’ve
modified the APIs that can take advantage of generics. These include:
_javax.servlet.jsp.tagext.TagLibraryValidator:setInitParameters(),
javax.servlet.jsp.tagext.TagData:getAttributes(),
javax.servlet.jsp.tagext.TagSupport:getValues(),
javax.servlet.jsp.tagext.SimpleTagSupport:findAncestorWithClass()_ .

=== Various Clarifications

* In "Section JSP 2.4, Implict Objects",
_header_ and _HeaderValues_ are obtained from calls to
_HttpServletRequest_ (not _ServletRequest_ ).
* Clarified the definition of element "type"
in the TLD schema. As stated in section 1.14.2.1, String values are
converted to a target type using the conversions defined in table 1-11.
So rtexprvalue=false attributes do not always have a type of
java.lang.String.
* In Table JSP.1-8 "Page Directive
Attributes", clarified that for attribute "language", the only defined
and required scripting language value for this attribute is java (all
lowercase, case sensitive).
* The body-content constants in
javax.servlet.jsp.tagext.TagInfo have been updated to be consistent with
the enumeration values in the TLD schema. +
[https://jsp-spec-public.dev.java.net/issues/show_bug.cgi?id=149]
* For the _import_ attribute in Table JSP 1-8
"Page Directive atttributes", clarified that no other packages may be
part of the default import list.

=== Changes between JSP 2.1 EDR and JSP 2.1 Public Review

=== Backwards Compatibility with JSP 2.0

In EDR, backwards compatibility with JSP 2.0
was triggered via the version of the deployment descriptor. Backwards
compatibility is now triggered via the container itself and the
jsp-version associated with a tag library. See
link:jsp-1.html#a28[See Backwards Compatibility with JSP
2.0.].

=== Faces Action Attribute and MethodExpression

In Faces, the _action_ attribute accepts both
a String literal or a _MethodExpression_ . When migrating to JSF 1.2, if
the attribute's type is set as _MethodExpression_ , an error would be
reported if a String literal is specified because a String literal
cannot evaluate to a valid _javax.el.MethodExpression_ .

To solve this issue, the specification of
_MethodExpression_ has been expanded to also support String
literal-expressions. Changes have been made to
link:jsp.html#a1071[See Expressions and Attribute Values.] to
describe what happens now when a tag handler attribute is of type
_javax.el.MethodExpression_ .

=== Additional element for the TLD

The _<attribute>_ element of the TLD now
allows subelements _<rtexprvalue>_ and _<deferred-value>_ to be
specified jointly. This is useful for tags such as _<c:forEach>_ that
want to support both request-time expression values (e.g.
_$\{model.list}_ ) as well as deferred values (e.g. _#\{model.list}_ )
to enable the mapping of iteration attributes as EL variables that can
then be used by nested Faces tags.

Chapter 2 on the Expression Language has been
reworked in an attempt to better describe how EL expressions are
processed according to their _type category_ .

=== New JspId attribute

Some tag handlers can benefit from being
assigned a unique identifier within a page. The new interface
_javax.servlet.jsp.tagext.JspIdConsumer_ makes this possible.

=== Removing whitespaces from template text

It is now possible to have extraneous
whitespaces removed from template text through element
_trim-directive-whitespaces_ of JSP Property Groups (See
link:jsp.html#a1316[See Removing whitespaces from template
text.]), or the page and tag file directive attribute
_trimDirectiveWhitespaces_ (See link:jsp.html#a770[See The page
Directive.], link:jsp.html#a2399[See The tag Directive.]).

=== Response Status Code for JSP error page

In link:jsp.html#a614[See Using JSPs
as Error Pages.], clarified how the response status code of a JSP error
page is set.

=== Comments in JSP Documents

In link:jsp.html#a619[See
Comments.], clarified how comments are processed in JSP documents (XML
syntax).

=== Byte Order Mark and Page Encoding

In link:jsp.html#a1351[See Page
Character Encoding.], clarified that Byte Order Marks are not supported
as authoritative page encoding declarations for JSP pages in standard
syntax. However, maybe this should be reconsidered for JSP 2.1. For
anyone with an opinion on this topic, please share your thoughts at
https://jsp-spec-public.dev.java.net/issues/show_bug.cgi?id=133

=== TagLibraryInfo

Allow for deferred ("lazy") parsing of TLDs
by removing requirement that underlying TLD must be parsed during
constructor invocation. Added _getTaglibraryInfos()_ method, which
allows inspection of all "foreign" taglibs imported into translation
unit.

=== SimpleTag and <body-content>

In link:jsp.html#a2059[See Simple Tag
Handlers.], an error now needs to be reported only if the offending tag
(body content specified as JSP for a SimpleTag) is actually being
referenced in a JSP page. This will allow for optimizations.

=== JspApplicationContext.addResolver()

To make it easier for the Faces
implementation, modified the constraint on calling _addResolver()_ to
take effect after the application has received any request from the
client, instead of after the application has been initialized.

=== Duplicate tag files

In link:jsp.html#a2356[See Packaging
Directly in a Web Application.], clarified the fact that tag files can
have a _.tag_ or _.tagx_ extension and that if two tag files have the
same name except for the extension (e.g. _a.tag_ and _a.tagx_ ), the tag
library is considered invalid.

=== Table 1-9

A translation error must occur if the value
does not start with _/WEB-INF/tags_ , and not _WEB-INF/tags/_ .

=== Restructuring of API chapters

The high level descriptions of the APIs have
been consolidated in each package’s package.html file. This means that
they will now also be part of the independently generated javadocs.

=== Changes between JSP 2.0 Final and JSP 2.1 EDR1

The JSP and JSF expert groups have
collaborated together to unify the JSP 2.0 and Faces 1.1 Expressions
Languages. The result is the new _unified_ Expression Language (EL 2.1).

The support in JSP 2.1 of the new unified
Expression Language triggered numerous modifications to the
specification. These modifications are summarized in the bullet items
below.

=== New specification document for the Expression Language

While the expression language is still
defined within the JSP 2.1 specification, it however now has its own
independent specification document. This makes the intent clear that the
Expression Language is generally applicable to a variety of technologies
and does not carry a dependency on the JSP specification.

=== Backwards Compatibility and Migration Guidelines

Backwards compatibility considerations with
respect to JSP 2.0 as wells as migration guidelines from JSP 2.0 to JSP
2.1 are described in the Prefacelink:jsp-1.html#a11[See
Preface.]. Section link:jsp.html#a1238[See Deactivating EL
Evaluation.] also addresses the issue of backwards compatibility through
deactivation of EL evaluation.

=== Chapter 2 - Expression Language

The chapter on the Expression Language has
been substantially modified to focus strictly on the integration of the
unified EL within the JSP 2.1 environment. EL specific content has been
moved to the EL specification document.

=== New class _javax.servlet.jsp.JspApplicationContext_

The new class _JspApplicationContext_ stores
application-scoped information relevant to JSP containers. It supports
the integration of the unified Expression Language by allowing other
frameworks to register _ELResolvers_ , and by providing access to a
factory to create EL expression objects. See
link:javax.servlet.jsp.html#UNKNOWN[].

=== New method _getJspApplicationContext_ on _JspFactory_

{empty}This new method allows an application
or framework to get access to the _JspApplicationContext_ . See
link:javax.servlet.jsp.html#UNKNOWN[]

=== Major changes to the _javax.servlet.jsp.el_ API

All of the classes and interfaces of the
_javax.servlet.jsp.el_ API have been deprecated. The APIs defined by the
unified Expression Language ( _javax.el_ ) should be used as of JSP 2.1.
Two new classes, _ImplicitObjectELResolver_ and
_ScopedAttributeELREsolver_ , have been added to implement variable
resolution rules that must be supported by a JSP container with the new
unified Expression Language. See link:javax.servlet.jsp.el.html#UNKNOWN[].

=== New method _getELContext_ on _JspContext_

This new method returns the _ELContext_
associated with a _JspContext_ . The _ELContext_ embeds the _ELResolver_
that must be provided for the evaluation of EL expressions that appear
in a JSP page or tag file. See link:javax.servlet.jsp.html#UNKNOWN[] and
link:jsp.html#a1164[See Resolution of Variables and their
Properties.].

=== New rules for tag handler attributes

Tag handlers must now handle attribute values
according to the new _Expression_ objects of the unified Expression
Language. See link:JSP_Expression_Language.html#UNKNOWN[].

=== [[a6087]]TLD schema now supports deferred expressions as attributes

If a tag attribute wishes to accept a
deferred expression, it must declare that it wishes to do so in the TLD.
This is supported with three new elements: _<deferred-value>_ ,
_<deferred-method>_ , and _<method-signature>_ . See
link:jsp.html#a3944[See XML Schema for TLD, JSP 2.1.].

=== Syntax of EL expressions

The new unified EL supports both $\{expr} and
#\{expr} syntaxes for EL expressions. The specification has been
modified in many places to state the fact that EL expressions can be
written using both constructs $\{expr} or #\{expr}. Escaping rules for
$\{} have also been extended to #\{}. See:

{empty}link:jsp.html#a284[See
Element Syntax.]

{empty}link:jsp.html#a388[See JSP
Syntax Grammar.]

link:jsp.html#a639[See Quoting and
Escape Conventions.].

{empty}isELIgnored in
link:jsp.html#a789[See Page Directive Attributes.]

{empty}link:jsp.html#a2756[See
Request-Time Attribute Expressions.]

{empty}link:jsp.html#a2793[See
Template Text and XML Elements.]

=== Constraints on the use of $\{} and #\{}

While the unified EL API parses and evaluates
$\{expr} and #\{expr} the same way, additional restrictions are placed
on the usage of these delimiters in JSP pages. See
link:JSP_Expression_Language.html#UNKNOWN[].

=== Escaping EL expressions

JSP 2.0 already provides for escaping _$\{}_
expressions using _\$\{}_ . An additional escape sequence _\#\{}_ has
been added so that page authors can escape _#\{}_ expressions. See:



=== Changes between JSP 2.0 PFD3 and JSP 2.0 Final

* Minor typos and clarifications.
* API Changes:
* Changed
_javax.servlet.jsp.tagext.JspFragment_ from an interface to an abstract
class. Made _JspFragment.invoke()_ abstract.
* Added _JspFragment.getJspContext()_ method.
* Added section on compatibility and porting
issues between JSP 1.2 and JSP 2.0 to Preface.
* Minor clarifications to JSR-45 line number
mapping guidelines.
* Clarified use of _<jsp:output>_ in tag
files.
* Added _doctype-root-element_ ,
_doctype-public_ and _doctype-system_ properties to _<jsp:output>_ for
outputting DOCTYPE in JSP XML sytnax.
* Requires that the JSP stratum is the
default, for JSR-45 debugging.
* Added I18N detection algorithm appendix.
* Added element structure diagrams for TLD
schema.
* Removed requirement on ordering of
attribute setter calls, except for +
_<jsp:attribute>_ .
* Clarified that a TLD is invalid if it
specifies " _JSP_ " as the _<body-content>_ for a SimpleTag extension.
* Made the JSR-45 requirement optional.
* Clarified ranges of EL integer and floating
point literals.
* Clarified semantics for cross-syntax
translation-time includes (between standard and XML syntaxes). Added
three examples to illustrate these semantics.
* Loosened checking for duplicate _page_
directive attributes and duplicate _taglib_ directive declarations to
make static includes more useful. Duplicates are now okay so long as the
values are identical in both places.
* Re-enabled preludes and codas for JSP
Documents (XML syntax).
* Removed special behavior of the _id_
attribute for custom tags. Virtually no containers implement this
feature and it was thought solidifying this requirement in JSP 2.0 would
berak applications.
* Clarified that the _uri_ passed to
_TagLibraryValidator.validate()_ is the _uri_ in the XML View, not
necessarily the value of the _uri_ attribute in the _taglib_ directive.

=== Changes between JSP 2.0 PFD2 and JSP 2.0 PFD3

* Minor typos and clarifications.
* Added _\$_ as a way to quote _$_ in
template text and attribute values, both in standard and XML syntaxes.
This enabled quoting of EL expressions. Quoting of _$_ is disabled for
pages where EL is ignored, for backwards compatibility. Described the
XML view for quoting EL expressions.
* Changes to the API:
*  _NullPointerException_ must be thrown for
null name in various methods.
* Allow _null_ passed as default prefix in EL
API to indicate a prefix is required.
*  _SimpleTagSupport_ : Made _jspBody_ and
_jspContext_ fields private. Made _getJspBody()_ and _getJspContext()_
accessors protected.
*  _ExpressionEvaluator_ : Changed so that
only one EL expression can be parsed or evaluated at a time, with no
intermixed static text. Removed _defaultPrefix_ parameters and changed
so that _FunctionMappers_ can mutate between
_ExpressionEvaluator.parseExpression()_ and _Expression.evaluate()_ .
* Updated javadocs for _JspWriter_ to
indicate that the resulting text is written to the buffer or underlying
writer directly, and not converted to the platform’s default encoding
first, which would make no sense in this context.
* Changes to Tag Library Descriptor (TLD):
* Added _descriptionGroup_ , _example_ and
extension elements to _<tag-file>_ .
* Moved definitions of _j2ee:extensibleType_
and _j2ee:tld-extensionType_ to _web-jsptaglibrary_2_0.xsd_ .
* Added _function-extension_ element.
* Updated _tag-name-uniqueness_ to check for
uniqueness across name elements both in _tag_ and _tag-file_ elements.
Removed _tag-file-name-uniqueness_ .
* Removed capital versions of _TAGDEPENDENT_
, _EMPTY_ , and _SCRIPTLESS_ enumerations in _body-contentType_ .
* Reformatted indentation.
* Added example of how to write a schema for
a TLD extension.
* Changes to the Expression Language (EL):
* Clarified that the container must check EL
syntax at translation time.
* Removed rules for escaping EL expression
output. in EL chapter.
* Added conditional operator (A ? B : C).
* Added coercion rules for target type _Long_
.
* The _empty_ operator can now be applied to
any _Collection_ .
* In all cases, omitting the prefix of a
function now means the function is associated with the default
namespace.
* EBNF Grammar Changes:
* Better handling for syntax errors for
unmatched action tags
* Added logic to handle quoting EL
expressions.
* Changed conversion rules for attribute
values for the empty String "" to match EL semantics.
* Removed synchronization of variables from
the page to the tag file, but kept synchronization from tag file to
page. This is consistent with classic tags.
* Changed the default value for the
_rtexprvalue_ attribute of the _attribute_ directive to _true_ .
* I18N Changes:
* During a _<jsp:forward>_ or _<jsp:include>_
the container is now required to encode the parameters using the
character encoding from the request object.
* Character encoding is now determined for
each file separately, even if one file includes another using the
include directive.
* Changed the semantics of _<is-xml>_ so that
a value of false simply indicates the resource is not a JSP document,
but rather a JSP page.
* Changed _.jspx_ extension to only work with
a Servlet 2.4 or greater web.xml.
* Synchronized behavior of error pages with
the Servlet specification.
* Changed _dynamic-attributes_ attribute of
the _tag_ directive to specify the name of a _Map_ to place the dynamic
attributes into, instead of placing them directly in the page scope.
Dynamic attributes with a _uri_ are ignored.
* Added _alias_ attribute and
_name-from-attribute_ mechanism for tag files.
* Clarified behavior of Tag Library
Validators when namespaces are redefined in JSP documents.
* Added non-normative guidelines for JSR-45
line number mapping.
* Clarified that DTD validation of JSP
Documents must be done by containers.
* Clarified that in JSP Documents the prefix
" _jsp_ " is not fixed for the namespace +
_http://java.sun.com/JSP/Page_ .
* Clarified that, if ’a’ is not a custom
action, _<a href="%= url %">_ does not contain a request-time attribute
value whereas _<a href="$\{url}">_ does.

=== Changes between JSP 2.0 PFD and JSP 2.0 PFD2

* Minor typos and clarifications.
* Clarified handling of non-String types when
using _<jsp:attribute>_ .
* Clarified that JSP Configuration settings
do not apply to tag files.
* Changed the way EL expressions and
Scripting is enabled/disabled:
* Removed _isScriptingEnabled_ attribute from
page/tag directive.
* Changed _<scripting-enabled>_ JSP
Configuration element to +
_<scripting-invalid>_
* Changed _<el-enabled>_ JSP Configuration
element to _<el-ignored>_
* Changed _isELEnabled_ to _isELIgnored_ .
* Clarified that EL expressions can be used
to provide request-time attribute values as well.
* Added a grammar for the
_<function-signature>_ element in the TLD.
* Clarified expected container behavior for
various illegal JSP code.
* Clarified JSP Configuration URL Patterns
are as defined in the Servlet specification.
* Clarified that for _<jsp:invoke>_ , an
_IllegalStateException_ must occur if _scope_ is _session_ and the
calling page does not participate in a session.
* Clarified that invalid tag libraries must
trigger a translation error.
* API Changes, including:
* Various javadoc clarifications to enhance
testability.
* Added new _pushBody( java.io.Writer )_ to
_JspContext_ .
* Moved _popBody()_ from PageContext to
_JspContext_ .
* Removed _ELException.toString()_
* Adjusted semantics of
_SimpleTagSupport.findAncestorWithClass()_ so that it uses the return
value of _TagAdapter.getAdaptee()_ when comparing class types, and for
the final return value.
* Clarified _SkipPageException_ should not be
manually thrown in JSP Pages.
* Removed _TagLibraryInfo.getTagdir()_ and
corresponding protected attribute, as it can never return anything
useful. Also removed the JSP 2.0 version of the constructor, since it
only differed by its _tagdir_ parameter.
* Removed _pContext_ parameter from
_VariableResolver.resolveVariable()_ .
* Changed _ExpressionEvaluator_ from an
interface to an abstract class.
* Changed _Expression_ from an interface to
an abstract class.
* Removed _PAGE_SCOPE_ , _REQUEST_SCOPE_ ,
_SESSION_SCOPE_ and _APPLICATION_SCOPE_ constants from _JspContext_ as
they are duplicated in _PageContext_ .
* Various changes to schema for JSP portion
of web.xml and to schema for TLDs.
* Made it illegal to refer to classes in the
unnamed (a.k.a. default) package, since JDK 1.4 has stopped supporting
this.
* Reduced J2SE requirement to J2SE 1.3 for
standalone containers and J2SE 1.4 for J2EE 1.4 containers. Made Unicode
3.0 and JSR-45 optional when running in J2SE 1.3 and required when
running in J2SE 1.4.
* JSR-45 SourceDebugAttribute extensions must
now be generated for tag files as well.
* Internationalization Changes:
* Renamed the "Localization" chapter to
"Internationalization", and rewrote it for clarity, to provide more
up-to-date information on JSTL, and to refer to the Servlet
specification for details of the _ServletResponse_ behavior.
* If the _contentType_ charset defaults to
_ISO-8859-1_ , it isn’t passed on to the _ServletResponse_ , so that
implicit character encoding specifications can still override it in
Servlet 2.4.
* The page character encoding of documents in
XML syntax is now always detected in the XML specification. The
_pageEncoding_ attribute and/or _page-encoding_ configuration element
may be given, but must not disagree with the XML prolog.
* XML views are encoded in _UTF-8_ , and
their _pageEncoding_ attribute is set to reflect this. Their
_contentType_ attribute is set to reflect the _contentType_ that the
container will pass to the _ServletResponse_ .
* Moved details about XML view of tag files
to "JSP and XML" chapter.
* Changed the way variable synchronization
works in Tag Files and simple tag handlers:
* Removed the _Map_ parameter from
_JspFragment.invoke()_ .
* Removed all _JspFragment_ logic dealing
with preparing and restoring the page scope.
* Disallowed the use of _<jsp:param>_ in
_<jsp:invoke>_ and _<jsp:doBody>_
* Removed fragment attribute from the
_variable_ directive (and from the _variable_ element in the TLD).
Variables can no longer be scoped to a specific fragment.
* It is now a translation-time error to have
a _variable_ directive with a _name-given_ attribute having the same
value as the _name_ attribute of an _attribute_ directive, for a given
tag file translation unit.
* Variables appear as page-scoped attributes
local to the tag file, and are synchronized with the calling
_JspContext_ at various points, depending on the scope of the variable.
* Clarified that scripting variables are
still declared for _SimpleTag_ variables.
* Clarified what implicit objects are
available to tag files.
* Removed the _value_ attribute of the
_<jsp:body>_ standard action.
* Added glossary entries for tag file, JSP
fragment, named attribute, JSP segment, classic tag handler, simple tag
handler, dynamic attribute, and JSP configuration.
* Added _<jsp:element>_ standard action to
standard syntax as well.
* Expression Language
* Clarified behavior of EL functions whose
implementations are declared to return _void_ .
* Specified expected behavior when an EL
function throws an exception.
* Specified that the result of an EL
expression in template text is quoted, to help in preventing cross-site
scripting attacks.
* Made rules for coercing A to Number type N
more specific.
* Added special handling for all operators
for _BigInteger_ and _BigDecimal_ types.
* Specified stricter rules for tag handler
instance reuse to improve compatibility.
* Changed behavior of _JspException_ being
thrown from dynamic attributes to be handled as though the exception
came from another setter method, instead of having come from
_doStartTag()_ or _doEndTag()_ .
* Clarified how dynamic attributes behave
with respect to namespaces.
* Relaxed the need to call _setParent( null
)_ on Simple Tag Handlers.
* Clarified that classic tag invocations with
empty bodies will not cause body methods to be invoked, even if the body
content type for the tag is something other than "empty".
* Some clarifications on how implicit taglib
maps are constructed.
* EBNF Grammar Changes:
* Fixed EBNF for _Params_ , _Fallback_
productions to allow for _<jsp:body>_ to appear inside.
* Clarified that _<jsp:body>_ cannot be used
to specify the body of _<jsp:body>_ or _<jsp:attribute>_ and that
_<jsp:attribute>_ cannot be used to specify an attribute of
_<jsp:attribute>_ .
* Clarified that XML-style attributes, such
as those used in directives, can be separated from each other by
whitespace.
* Added _<jsp:output>_ and _<jsp:text>_ to
grammar.
* Corrected definition of _<jsp:param>_ .
* Fixed EBNF for _<jsp:text>_ ,
_<jsp:scriptlet>_ , _<jsp:expression>_ and _<jsp:declaration>_ so that
CDATA sections are now allowed.
* Added _mayscript_ attribute to
_<jsp:plugin>_ tag.
* Clarified _<jsp-property-group>_ matching
logic and how URL pattern overlaps are resolved between
_<jsp-property-group>_ and _<serlvet-mapping>_ elements.
* Clarified that a primitive cannot be used
as the type of an attribute in tag files.
* Clarified that the default for the
_language_ attribute of the _page_ directive is +
_java_ .
* Moved _<jsp:element>_ and _<jsp:text>_ to
Standard Actions chapter. Added _<jsp:output>_ to Standard Actions
chapter.
* Split XML chapter into two chapters - one
on JSP Documents and one on XML Views of JSP Pages and JSP Documents.
Rewrote large portions of JSP Documents chapter.
* Changed semantics of _SimpleTag_ so that if
a body is not present, _setJspBody()_ is not called (instead of passing
_null_ ).
* Added XML syntax for tag files (.tagx).
* Made preludes and codas illegal for JSP
Documents (XML syntax).

=== Changes between JSP 2.0 PFD1a and JSP 2.0 PFD

* Synchronized Standard Actions Chapter with
JSP 1.2 Errata B.
* Clarifications in the Localization Chapter
to make encoding table clearer.
* Changed _TagAdapter_ to reduce confusion
for container vendors.
* EL Function implementations no longer need
to be in a non-abstract class.
* Updated BNF for EL to include functions.
* Removed the restriction that the _value_
attribute of _<jsp:body>_ cannot be used for Classic Tag Handlers.
* Various typographical edits and
clarifications (scattered).
* In _<jsp:doBody>_ , made it illegal to
specify a _<jsp:param>_ with the same name as a variable with a scope of
_AT_BEGIN_ or _NESTED_ .
* Provided a brief, non-normative overview of
the _SimpleTag_ lifecycle in the _SimpleTag_ javadocs for the
convenience of developers.
* Added new _include()_ method to
_PageContext_ , with _flush_ parameter.
* Removed _name_ attribute from _tag_
directive.
* Changed semantics of tag file packaging,
and modified XML Schema accordingly.
* Improved access to error information in
error pages by adding _javax.servlet.error.exception_ and providing
access to other attributes via the EL.
* Filled in many missing javadoc entries in
the JSP API.
* Clarified that, for tag files, if an
optional attribute is declared but not passed in, no page-scoped
variable is created (used to say value is _null_ , which is illegal).
* Added TLD Deployment extensions to Tag
Extensions chapter and TLD. These extensions are only for tool
consumption.
* Cleaned up description of coercion rules in
Expression Language chapter.
* Clarified that Dynamic Attributes must be
considered to accept request-time expression values.
* Modified the concept of JSP documents. In
JSP 1.2 we had two quite separate syntaxes and, for instance, elements
like <jsp:expression> were not available in classic JSP syntax. In JSP
2.0 the same basic syntax is available everywhere, but a JSP page can be
tagged as being an XML document and thus can benefit from XML concepts
like well-formedness, validity, and entity definitions.
* Added configuration property <is-xml> to
indicate that a JSP page is to be treated as an XML document (JSP
Document).
* Incorporated new XML syntax details in the
Core Syntax and in the JSP documents chapter. Renamed Chapter 6 from JSP
Documents to JSP and XML.
* XML syntax versions of all JSP elements are
now also available in JSP pages that are not JSP documents - this is a,
backward compatible, extension from the JSP 1.2 semantics.
* Added default interpretation of extension
".jspx" to mean a JSP document (and thus, an XML document).
* Added a <jsp:element> element to
dynamically generate XML elements.
* Clarified that when a <jsp:useBean> element
is used in an scriptless page, or in an scriptless context (as in the
body of an action so indicated), there are no Java scripting variables
created but instead an EL variable is created.
* Clarified that EL expressions are available
in all attributes of both standard and custom actions that accept run
time expressions.
* Changed _<jsp:invoke>_ and _<jsp:doBody>_
to accept _var_ attribute to store fragment output as a _String_ .
Changed semantics of _varReader_ so that _$\{reader}_ no longer echoes
the contents of the _Reader_ and no longer resets the stream. The
_Reader_ can be passed to a custom action for further processing.
* Can now use _<jsp:attribute>_ for any
standard or custom action attribute, and can now use scriptlets and
expressions in the body of _<jsp:attribute>_ where it makes sense.
* Removed _fragment-input_ directive and
replaced with a new _fragment_ attribute for the _variable_ directive.
Removed _<fragment-attribute>_ and _<fragment-input>_ elements in the
TLD and replaced them with new _<attribute>_ subelement called
_<fragment>_ , and new _<variable>_ subelement called _<fragment>_ .
Updated APIs for tag info accordingly.
* Clarified that the implicit objects
available to JSP pages under the EL are always available through the
given names.
* The EL Evaluator API has continued to
evolve. Among the changes there is now a FunctionMapper abstraction, and
parsing errors are now reported through an ELParseException. The
VariableResolver Interface now is obtained from the JspContext and
abstracts its context.

=== Changes between JSP 2.0 PD2 and JSP 2.0 PFD1a

* Removed restriction that containers must
not reuse _JspFragment_ instances.
* Added _javax.servlet.jsp.tagext.JspTag_ to
the API chapter.
* Fixed EBNF for _Params_ , _Fallback_
productions.
* Fixed some minor typos (scattered).
* Added uniqueness constraints to XML Schema
for _tag/name_ , _tag-file/name_ and _function/name_ .
* Added _SkipPageException_ as an exception
for indicating a page is to be skipped in _JspFragments_ and Simple Tag
Handlers. Replaces _SKIP_PAGE_ and _EVAL_PAGE_ constants (only for
Simple Tag Handlers - Classic Tag Handlers still use those constants).
* Clarified _<jsp:attribute>_ can be used to
specify only request-time expression attributes, and can be used for
standard actions, and custom actions implemented using either Classic
Tag Handlers or Simple Tag Handlers. Also clarified the _<jsp:body>
value_ attribute can only be used for Simple Tag Handlers and that
_<jsp:attribute>_ can be used to specify a fragment even for Classic Tag
Handlers.
* Modified the page scope handling for Jsp
Fragments and Tag Files to be much cleaner. Removed _peekPageScope()_ ,
_pushPageScope()_ and _popPageScope()_ . Instead, fragments are assumed
to share the page scope with its containing page, and tag files are
required to create a Jsp Context Wrapper.
* Removed
_javax.servlet.jsp.tagext.AttributeNotSupportedException_ , and replaced
it with a simple _JspException_ which is just as effective.
* Added two constructors to _JspTagException_
to allow specification of the root cause.
* Made _jspContext_ and _jspBody_ fields
protected in _SimpleTagSupport._

=== Changes between JSP 2.0 PD1 and JSP 2.0 PD2

NOTE: JSP 2.0 PD2 was not released publicly.

* Updated I18N chapter to indicate Unicode
3.0 support and new details URL.
* Now requires JSR-45 strata name to be JSP.
* Clarified _trim_ attribute of
_<jsp:attribute>_ is to be used at translation time.
* Fixed some minor typos (scattered).
* Renamed < _el-evaluation_ > _web.xml_
element to < _el-enabled_ >
* Reorganized new features. Created a
cohesive chapter about Tag Files. Simple Tag Handler details were moved
to Tag Extensions and to the API chapter. Standard Action description
was moved to Standard Action chapter.
* Added a root interface _JspTag_ to cover
_Tag_ and _SimpleTag_ .
* Moved all TLD DTDs to a single "Tag Library
Descriptor Schemas" Appendix and added the new JSP 2.0 XML Schema to
that appendix.
* Added JSP 2.0 XML Schema, which is imported
by the Servlet 2.4 Web Application Deployment Descriptor.
* Updated page directive table and grammar to
include isScriptingEnabled and isELEnabled.
* Added language, import, isScriptingEnabled
and isELEnabled attributes to tag directive.
* Applied fixes to EBNF grammar based on JSP
2.0 Preview EA1 experience
* Clarified that jsp:id is now required and
added TagExtraInfo.validate() and requirement that container call it
instead of TagExtraInfo.isValid().
* Reorganized slightly the EL chapter to
emphasize the parts of the language that do not depend on JSP details.
Also removed the description of the API in that chapter: the
javadoc-generated chapter is more complete.
* Function names now need to be unique within
a tag library; arity is not used to disambiguate functions. This was
done to simplify the EL language and the decision can be revisited in
later releases based on usage experience.
* Some refinements to the EL API: a new
method was added that accepts a VariableResolver instead of a
JspContext, and the prefix/shortname map has been split into two
separate maps.

=== Changes between JSP 2.0 CD2 and JSP 2.0 PD1

* Moved all the JSP configuration description
into its own chapter.
* Reordered the EBNF description to be at the
end of JSP 1.3.
* Restored some pieces in the Syntax chapter
that were lost in an editing operation. The only substantive piece was
the description of the _<include-prelude>_ and _<include-coda>_
elements, which are now in the JSP configuration chapter.
* Added details on how to implement functions
in EL.

=== Changes between JSP 2.0 CD1 and JSP 2.0 CD2

=== Between CD2c and CD2

* Upgraded major version from JSP 1.3 to JSP
2.0, added section to the Preface explaining change.
* Added directive examples to JSP Fragments
chapter.
* Moved section describing passing attribute
values via _<jsp:attribute>_ and _<jsp:body>_ to syntax chapter and
moved definitions of these two standard actions to Standard Actions
chapter, from JSP Fragments chapter.
* Added optional scope attribute to
_<jsp:invoke>_ and _<jsp:doBody>_ .
* Improved and simplified the way tag files
are packaged. One can now package tag files in JARs or place them in a
subdirectory of /WEB-INF/tags/ and access them without specifying a uri.
* Changed _SimpleTag_ to not extend _Tag_ .
Added _TagAdapter_ to handle tag collaboration, and removed dependency
on _PageContext_ in _SimpleTag_ . These changes help make _SimpleTag_
usable in environments other than Servlet request/response.
* Changed fragment invocation via
_<jsp:invoke>_ and _<jsp:doBody>_ to be able to expose their result as a
_java.io.Reader_ object instead of a _String_ . This is expected to be
more efficient.
* Added _<include-prelude>_ and
_<include-coda>_ elements to _<jsp-properties-group>. Added a
description in the Syntax Chapter._
* Added a _getExpressionEvaluator()_ method
to _JspContext_ (and, thus, to _PageContext_ ).
* Added better description of JSP
configuration information to different chapters.
* Added to-do notes on EL to Syntax chapter,
sketching where the information will go.
* Renamed _elEvaluation_ property of _page_
directive. The new name is _isELEnabled_ , to be consistent with other
properties.

=== Between CD2b and CD2c

* Fixed syntax table so that flush is
optional in _<jsp:include>_ standard action.
* Integrated EL grammar with JSP EBNF.
* Clarified _doEndTag()_ description when
_SKIP_PAGE_ is returned.
* Added _dynamic-attributes_ element in tag
directive to describe a tag file that accepts dynamic attributes.
* Added _SimpleTag_ , _JspFragment_ ,
_DynamicAttributes_ , _AttributeNotSupportedException_ ,
_ExpressionEvaluator_ , and _VariableResolver_ classes to API. Added new
API chapter for _javax.servlet.jsp.el_ package.
* Added _isScriptingEnabled_ directive and
_scripting-enabled_ JSP configuration element.
* Renamed _jsp-group_ JSP configuration
element to _jsp-properties-group_ . Clarified conflict resolution rules.
* Clarified direction with EL function -
details still to come.
* Added a chapter for EL API.
* Added description of _page-encoding_ JSP
configuration element to Localization chapter.

=== Between CD2a and CD2b

* Reordered "Users of JSP Technology" and
"Basic Concepts" in the Overview section.
* Added <jsp-config> element to web.xml as a
parent element for <taglib>. Added <jsp-group> as a new subelement to
describe properties for a group of JSP pages that are described using
<url-pattern> and other elements. Currently the only other element is
<el-evaluation>, which can be used to describe whether EL evaluation is
active or not by default.
* Modified the default rules for EL
evaluation. Now, EL evaluation is always off, but it is very easy to add
evaluation on through a <jsp-group> element.
* Various EBNF fixes
* Fixed some typos in Example Scenario in
JSP_Fragments chapter
* Clarified issues on <jsp:forward> from
within a tag file?
* Clarified issues on <jsp:attribute> and
whitespace

=== Changes between CD1 and CD2a

* Added a part structure to the specification
description. This helps provide guideance to the readers.
* Added a mechanism to pass attributes whose
names are not known until runtime to tag handlers (Dynamic Attributes).
* Added getPageContext() to SimpleTag.
* Adjustment to i18n table to make
defaultInputEncoding the default output encoding if unspecified.
* Moved EBNF description from Fragments
chapter to Core Syntax.
* Improved EBNF description of
<jsp:attribute> and <jsp:body>. Also, easier to read valid standard
action attribute sets.

=== Changes between JSP 2.0 ED1 and JSP 2.0 CD1

This is the first Community Draft of the JSP
2.0 specification.

=== JSP Fragments, .tag Files, and Simple Tag Handlers

* A new chapter on JSP fragments and
supporting technologies such as the .tag mechanism and simple tag
handlers:
* JSP fragments allow a portion of JSP code
to be encapsulated into a Java object which can be passed around and
evaluated zero or more times.
* The .tag mechanism allows page authors to
use JSP syntax to write Custom Actions.
* Simple tag handlers integrates tightly with
JSP fragments and allows for a much easier and more natural invocation
protocol for tag extensions.

=== Expression Language Added

* Added the Expression Language chapter,
equivalent to that released in the JSP Standard Tag Library (JSTL)
Public Draft, Appendix A.
* Updated the Expression Language chapter,
including preliminary information on the API to invoke the EL evaluator.

=== EBNF Fixes

Various fixes to the EBNF, to handle
CustomAction translation errors correctly. Improved readability by
adding ATTR[] construct, to allow easier expression of XML-style
attributes that can appear in any order.

=== I18N Clarifications

Incorporated JSP 1.2 errata_a. Clarified when
container can call _setContentType()_ and how it is possible to
dynamically affect content type and character encoding from within a
page or custom action.

=== Other Changes

* Updated Status, Preface, Changes chapters.
* Made support for jsp:id mandatory.
* Various typographical fixes.

=== Changes Between JSP 1.2 Final Draft and JSP 2.0 ED1

This is the first expert draft of the JSP 2.0
specification.

=== Typographical Fixes and Version Numbers

Various typographical fixes that do not
change any specification requirements, and version number updates for
JSP 2.0. Various things were fixed from JSP 1.2 such as missing page
numbers, repeated table numbers, etc.

=== Added EBNF Grammar for JSP Standard Syntax

A new section was added to the Syntax Chapter
that presents a simple EBNF grammar for the standard (i.e. non-XML) JSP
syntax. The grammar is intended to provide a concise syntax overview and
to resolve any syntax ambiguities present in the specification.

=== Added Users of JavaServer Pages Section

A new section was added to the Overview
Chapter that describes the various classes of users that make use of JSP
technology, describing their role, the technology they’re familiar with,
and the sections of this specifications that are relevant to them.

=== Added Placeholders for Expression Language and Custom Actions Using JSP

Two new chapters were added in anticipation
of the new Expression Language and Custom Actions Using JSP features.

=== Added Requirement for Debugging Support

A new section was added to the JSP Container
Chapter requiring support for JSR-045 ("Debugging Support for Other
Languages"). The precompilation protocol was also updated.

=== Changes Between PFD 2 and Final Draft

This is the final version approved by JCP
Executive Comittee; the document was updated to reflect that status. All
change bars were reset.

=== Added jsp:id mechanism

A new mechanism was added to allow willing
JSP containers to provide improved translation-time error information
from TagLibraryValidator classes. The signature of
TagLibraryValidator.validate() was modified slightly, and a new
ValidationMessage class was added. These objects act through a new
attribute, jsp:id, which is optionally supported by a JSP container and
exposed only through the XML view of a JSP page.
link:JSP_XML_Views.html#UNKNOWN[], link:JSP_Tag_Extensions.html#56836[]
(link:JSP_Tag_Extensions.html#UNKNOWN[]) and
link:javax.servlet.jsp.tagext.html#UNKNOWN[]
(link:javax.servlet.jsp.tagext.html#UNKNOWN[]) were affected.

=== Other Small Changes

* Made height & width be rtexprs.
link:JSP_StandardActions.html#UNKNOWN[] was affected.
* Added attribute value conversion from
String literal to short and Short, and corrected conversion for char and
Character in link:JSP_Syntax.html#UNKNOWN[].
* Corrected a statement on the allowed return
values for doStartTag() for Tag, IterationTag and BodyTag.. PFD2
incorrectly indicated that "emtpy" tags could only return SKIP_BODY; the
correct statement is that tags whose body-content is "empty" can only
return SKIP_BODY.

=== Clarification of role of id

The mandated interpretations of the "id"
attribute in Section JSP 2.13.3 (that id represents page-wide unique
ids) and the "scope" attribute in Section JSP 2.13.4 (regarding the
scope for the introduced variable) were not enforced by most (perhaps
all?) containers, and were inconsistent with prevalent practices in
custom tag library development. Essentially these sections were being
interpreted as localized statements about the jsp:useBean standard
action. This has been made explicit and the sections were moved to
link:JSP_StandardActions.html#UNKNOWN[] to reflect that.

Sections JSP.2.13.3 and JSP.2.13.4, and
Chapter 4 were affected.

=== Clarifications on Multiple Requests and Threading

* Clarify that TLV instances need be thread
safe. This affected link:javax.servlet.jsp.tagext.html#UNKNOWN[].
* Clarify that a tag handler instance is
actively processing only one request at a time; this happens naturally
if the tag handler is instantiated afresh through new() invocations, but
it requires spelling once tag handler pooling is introduced. This
clarification affected link:javax.servlet.jsp.tagext.html#UNKNOWN[].

=== Clarifications on JSP Documents

Several clarifications in
link:JSP_Documents.html#UNKNOWN[].

* Reafirmed that, in a JSP page in XML
syntax, the URI for jsp core actions is important, not the prefix.
* Clarify that <?xml ... ?> is not required
(as indicated by the XML spec).
* Clarified further the interpretation of
whitespace on JSP documents.

=== Clarifications on Well Known Tag Libraries

Clarified that a tag library author may
indicate, through the description comment, that a tag handler may expose
at runtime only some subset of the information described through the tag
handler implementation class. This is useful for specialized
implementations of well-known tag libraries like the JSP standard tag
library. This clarification affected the description of the tag element
in link:JSP_Tag_Extensions.html#UNKNOWN[] and the description of
_Tag.setParent()_ and _TagSupport.findAncestorWithClass()_ .

Removed the last paragraph on
link:JSP_Tag_Extensions.html#UNKNOWN[]; we don’t have any plans to remove
the well-know URI mechanism.

In general cleaned up the presentation of the
computation of the taglib map between a URI and a TLD resource path; the
previous version was clunky.

=== Clarified Impact of Blocks

Clarified further the legal uses and the role
of block constructs within scriptlets and nested actions. This affected
small portions of Sections link:JSP_Syntax.html#UNKNOWN[],
link:JSP_Scripting.html#UNKNOWN[], link:JSP_Scripting.html#85789[] and
link:javax.servlet.jsp.tagext.html#UNKNOWN[].

=== Other Small Clarifications

* Reafirmed more explicitly that the location
of icons is relative to TLD file. link:JSP_Tag_Extensions.html#UNKNOWN[]
was affected.
* Removed non-normative comment about JSR-045
in link:JSP_Syntax.html#UNKNOWN[].
* Removed the comment on errorPages needing
to be JSP pages, they can also be static objects. This affects
link:JSP_Syntax.html#UNKNOWN[].
* Reaffirmed that event listeners in a tag
library are registered before the application is started. This affects
link:JSP_Tag_Extensions.html#UNKNOWN[].
* Clarify when the use of quoting conventions
is required for attribute values. Clarified that request-time attribute
values follow the same rules. This affects link:JSP_Syntax.html#UNKNOWN[],
link:JSP_Syntax.html#UNKNOWN[] and link:JSP_Syntax.html#22326[].
* Clarified the interpretation of relative
specifications for include directives and jsp:include and jsp:forward
actions. This affected link:JSP_Syntax.html#UNKNOWN[],
link:JSP_Syntax.html#UNKNOWN[], link:JSP_StandardActions.html#39949[] and
link:JSP_StandardActions.html#UNKNOWN[]
* Corrected the inconsistency on the
precompilation protocol in link:JSP_Engine.html#UNKNOWN[] regarding whether
the requests are delivered to the page or not; they are not.
* Clarified that the <type> subelement of
<attribute> in the TLD file should match that of the underlying JavaBean
component property.
* Spelled out the use of
ClassLoader.getResource() to get at data from a TagLibraryValidator
class.

=== Changes Between 1.2 PFD 1b and PFD 2

Change bars are used in almost all chapters
to indicate changes between PFD 1b and PFD 2. The exception are Chapters
link:javax.servlet.jsp.html#UNKNOWN[] and
link:javax.servlet.jsp.tagext.html#UNKNOWN[] which are generated
automatically from the Java sources and have no change bars. Most
changes are semantical, but some of them are editorial.

=== Added elements to Tag Library Descriptor

The Tag Library Descriptor (TLD) was extended
with descriptive information that is useful to users of the tag library.
In particular, a TLD can now be massaged directly (e.g. using an XSLT
stylesheet) into an end-user document.

A new <example> element was added, as an
optional subelement of <tag>. The existing <description> element was
made a valid optional subelement of <variable>, <attribute> and
<validator>.

link:JSP_Tag_Extensions.html#UNKNOWN[] and
link:JSP_DD.html#UNKNOWN[] were affected. The TLD 1.2 DTD and Schemas were
also affected.

=== Changed the way version information is encoded into TLD

The mechanism used to provide version
information on the TLD was changed. In the PFD the version was encoded
into the namespace. In PFD2 the namespace is not intended to change
unless there are non-compatible changes, and the version is encoded into
the <jsp-version> element, which is now mandatory. The new URI for the
namespace is "http://java.sun.com/JSP/TagLibraryDescriptor".

link:JSP_Tag_Extensions.html#UNKNOWN[] and
link:JSP_DD.html#UNKNOWN[] were affected.

=== Assigning String literals to Object attributes

It is now possible to assign string literals
to an attribute that is defined as having type Object, as well as to a
property of type Object. The valid type conversions are now all
described in link:JSP_Syntax.html#UNKNOWN[], and used by reference in the
semantics of <jsp:setProperty>.

=== Clarification on valid names for prefix, action and attributes

We clarified the valid names for prefixes
used in taglib directives, element names used in actions, and attribute
names.

=== Clarification of details of empty actions

The JSP 1.1 specification distinguishes empty
from non-empty actions, although the description could be better.
Unfortunately, the JSP 1.2 PFD1 draft did not improve the description.
This draft improves the description by making it clear what methods are
invoked when.

Chapters link:jsp.html#a203[See
CHAPTER.]link:jsp.html#a204[See Core Syntax and Semantics.],
link:JSP_Tag_Extensions.html#UNKNOWN[] and
link:javax.servlet.jsp.tagext.html#UNKNOWN[] were affected.

=== Corrections related to XML syntax

We clarified several issues related to the
XML syntax for JSP pages and to the XML view of a JSP page. Most changes
are in link:JSP_Documents.html#UNKNOWN[].

* Removed an inexistant flush attribute in
the include directive at link:JSP_Documents.html#UNKNOWN[].
* Clarified that JSP comments in a JSP page
in JSP syntax are not preserved on the XML view of the page.
* Clarified that JSP pages in XML syntax
should have no DOCTYPE.
* Clarified the treatment of include
directives in the XML view of a JSP page.
* Clarified the format of the URIs to use in
xmlns attributes for taglib directives, and corrected
link:JSP_Schema_XML.html#UNKNOWN[See appendix.].

=== Other changes

We clarified several other inconsistencies or
mistakes

* Explicitly indicated which attributes are
reserved (link:JSP_Syntax.html#UNKNOWN[]) and which prefixes are reserved
(link:JSP_Syntax.html#UNKNOWN[]).
* Add a comment to the DTD for the TLD
indicating that a DOCTYPE is needed and what its value is. No changes to
the value.
* Removed the paragraph at the end of
link:JSP_Tag_Extensions.html#UNKNOWN[] that used to contain non-normative
comments on the future of "well kwown URIs".
* Corrected the description of the valid
values that can be passed to the flush attribute of the include action
in link:JSP_StandardActions.html#UNKNOWN[].
* Clarified that <jsp:param> can only appear
within <jsp:forward>, <jsp:include>, and <jsp:params>.
* Clarified that <jsp:params> and
<jsp:fallback> can only appear within <jsp:plugin>.
* Resolved a conflict in
link:JSP_StandardActions.html#UNKNOWN[] between the Servlet and the JSP
specification regarding how to treat modifications to headers in
included actions.
* Section 10.1.1 in PFD1 incorrectly
described the valid return values for doStartTag() in tag handlers that
implement the BodyTag interface. The correct valid values are SKIP_BODY,
EVAL_BODY_INCLUDE and EVAL_BODY_BUFFER. Section now indicates this.

=== Changes Between 1.2 PFD and 1.2 PFD 1b

PFD 1b is a draft that has mostly formating
and a few editorial changes. This draft is shown only to make it simpler
to correlate changes between later drafts and the previous drafts.

Change bars are used to indicate changes
between PFD 1 and PFD 1b.

=== Changes Between 1.2 PD1 and 1.2 PFD

The following changes ocurred between the
Public Draft 1 and the Proposed Final Draft versions of the JSP 1.2
specification.

=== Deletions

* Removed the resetCustomAttributes() method.

=== Additions

* Added constructors and methods to
JspException to support a rootCause (paralleling the ServletException).
* Added a
PageContext.handleException(Throwable) method.
* Added references to JSR-045 regarding
debugging support.
* Added new TryCatchFinally interface to
provide better control over exceptions in tag handlers.
* Added an implicit URI to TLD map for
packaged tag libraries. This also provides support for multiple TLDs
inside a single JAR file.
* Added pageEncoding attribute to page
directive.
* Added material to
link:JSP_I18N.html#UNKNOWN[].
* Added TagValidatorInfo class.
* Added link:JSP_Syntax.html#UNKNOWN[] with a
suggestion on extension convention for top and included JSP files.

=== Clarifications

* A tag handler object can be created with a
simple “new()”; it needs not be a fully fledged Beans, supporting the
complete behavior of the java.beans.Beans.instantiate() method.
* Removed the “recommendation” that the <uri>
element in a TLD be a URL to anything.
* Clarified that extension dependency
information in packaged tag libraries should be honored.
* Clarified invocation and lifecycle of
TagLibraryValidator.
* Clarified where TLDs may appear in a
packaged JAR file.
* Clarified when are response.getWriter().

=== Changes

* Moved a couple of chapters around
* Improved and clarified
link:JSP_Documents.html#UNKNOWN[].
* Moved the include directive back into
link:JSP_Syntax.html#UNKNOWN[].
* Renamed javax.servlet.jsp.tagext.PageInfo
to javax.servlet.jsp.tagext.PageData (for consistency with existing
TagData).
* Added initialization parameters to
TagLibraryInformation validation in TLD, adding a new <validator>
element, renaming <validatorclass> to <validator-class> for consistency,
and adding <init-param> as in the Servlet web.xml descriptor.
* Added method to pass the initialization
parameters to the validator class and removed the use of TagLibraryInfo.
Added prefix and uri String arguments to validate() method.
* Changed element names in TLD to
consistently follow convention. New names are <tag-class>. <tei-class>,
<tlib-version, <jsp-version>, <short-name> and <body-content>. <info>
was renamed <description>.

=== Changes Between 1.1 and 1.2 PD1

The following changes ocurred between the JSP
1.1 and JSP 1.2 Public Draft 1.

=== Organizational Changes

* Chapter 8 and 10 are now generated
automatically from the javadoc sources.
* Created a new document to allow longer
descriptions of uses of the technology.
* Created a new I18N chapter to capture
Servlet 2.3 implications and others (mostly empty for PD1).
* Removed Implementation Notes and Future
appendices, as they have not been updated yet.

=== New Document

We created a new, non-normative document,
“Using JSP Technology”. The document is still being updated to JSP 1.2
and Servlet 2.3. We moved to this document the following:

* Some of the non-normative Overview
material.
* All of the appendix on tag library
examples.
* Some of the material on the Tag Extensions
chapter.

=== Additions to API

* jsp:include can now indicate
“flush=’false’”.
* Made the XML view of a JSP page available
for input, and for validation.
* PropertyEditor.setAsText() can now be used
to convert from a literal string attribute value.
* New ValidatorClass and JspPage classes for
validation against tag libraries.
* New IteratorTag interface to support
iteration without BodyContent. Added two new constants
(EVAL_BODY_BUFFERED and EVAL_BODY_AGAIN) to help document better how the
tag protocol works; they are carefully designed so that old tag handlers
will still work unchanged, but the old name for the constant
EVAL_BODY_TAG is now deprecated.
* Added listener classes to the TLD.
* Added elements to the TLD to avoid having
to write TagExtraInfo classes in the most common cases.
* Added a resetCustomAttributes() method to
Tag interface.
* Added elements to the TLD for delivering
icons and descriptions to use in authoring tools.

=== Clarifications

* Incorporated errata 1.1_a and (in progress)
1.1_b.

=== Changes

* JSP 1.2 is based on Servlet 2.3, in
particular:
* JSP 1.2 is based on the Java 2 platform.

=== Changes Between 1.0 and 1.1

The JSP 1.1 specification builds on the JSP
1.0 specification. The following changes ocurred between the JSP 1.0
final specification and the JSP 1.1 final specification.

=== Additions

* Added a portable tag extension mechanism
with an XML-based Tag Library Descriptor, and a run-time stack of tag
handlers. Tag handers are based on the JavaBeans component model.
Adjusted the semantics of the uri attribute in taglib directives.
* Flush is now a mandatory attribute of
jsp:include, and the only valid value is “true”.
* Added parameters to jsp:include and
jsp:forward.
* Enabled the compilation of JSP pages into
Servlet classes that can be transported from one JSP container to
another. Added appendix with an example of this.
* Added a precompilation protocol.
* Added pushBody() and popBody() to
PageContext.
* Added JspException and JspTagException
classes.
* Consistent use of the JSP page, JSP
container, and similar terms.
* Added a Glossary as
link:jsp.html#a5908[See Changes.].
* Expanded Chapter 1 so as to cover 0.92’s
"model 1" and "model 2".
* Clarified a number of JSP 1.0 details.

=== Changes

* Use Servlet 2.2 instead of Servlet 2.1 (as
clarified in Appendix B), including distributable JSP pages.
* jsp:plugin no longer can be implemented by
just sending the contents of jsp:fallback to the client.
* Reserved all request parameters starting
with "jsp".

=== APPENDIX

[[a6526]]Glossary

This appendix is a glossary of the main
concepts mentioned in this specification. This appendix is
non-normative.

=== 

===  _action_

 An element in a JSP page that can act on
implicit objects and other server-side objects or can define new
scripting variables. Actions follow the XML syntax for elements with a
start tag, a body and an end tag; if the body is empty it can also use
the empty tag syntax. The tag must use a prefix.

===  _action, standard_

An action that is defined in the JSP
specification and is always available to a JSP file without being
imported.

===  _action, custom_

An action described in a portable manner by a
tag library descriptor and a collection of Java classes and imported
into a JSP page by a taglib directive.

===  _Application Assembler_

 __ A person that combines JSP pages, servlet
classes, HTML content, tag libraries, and other Web content into a
deployable Web application.

===  _classic tag handler_

 _A tag handler that implements the_
_javax.servlet.jsp.tagext.Tag_ _interface._

===  _component contract_

 _The contract between a component and its
container, including life cycle management of the component and the APIs
and protocols that the container must support._

===  _Component Provider_

A vendor that provides a component either as
Java classes or as JSP page source.

===  _distributed container_

 _A JSP container that can run a Web
application that is tagged as distributable and is spread across
multiple Java virtual machines that might be running on different
hosts._

===  _declaration_

 _A scripting element that declares methods,
variables, or both in a JSP page. Syntactically it is delimited by the_
_<%!_ _and_ _%>_ _characters._

===  _directive_

 _An element in a JSP page that gives an
instruction to the JSP container and is interpreted at translation time.
Syntactically it is delimited by the_ _<%@_ _and_ _%>_ _characters._

===  _dynamic attribute_

 _An attribute, passed to a custom action,
whose name is not explicitly declared in the tag library descriptor._

===  _element_

A portion of a JSP page that is recognized by
the JSP translator. An element can be a directive, an action, or a
scripting element.

=== EL expression

An element in a JSP page representing an
expression to be parsed and evaluated via the JSP Expression Language.
Syntactically it is delimited by the _$\{_ and _}_ characters.

===  _expression_

 _Either a scripting expression or an EL
expression._

===  _fixed template data_

 _Any portions of a JSP file that are not
described in the JSP specification, such as HTML tags, XML tags, and
text. The template data is returned to the client in the response or is
processed by a component._

===  _implicit object_

 _A server-side object that is defined by the
JSP container and is always available in a JSP file without being
declared. The implicit objects are_ _request_ , _response_ ,
_pageContext_ , _session_ , _application_ , _out_ , _config_ , _page_ ,
and _exception_ for scriptlets and scripting expressions. The implicit
objects are _pageContext_ , _pageScope_ , _requestScope_ ,
_sessionScope_ , _applicationScope_ , _param_ , _paramValues_ , _header_
, _headerValues_ , _cookie_ and _initParam_ for EL expressions _._

===  _JavaServer Pages technology_

An extensible Web technology that uses
template data, custom elements, scripting languages, and server-side
Java objects to return dynamic content to a client. Typically the
template data is HTML or XML elements, and in many cases the client is a
Web browser.

===  _JSP container_

A system-level entity that provides life
cycle management and runtime support for JSP and servlet components.

===  _JSP configuration_

The deployment-time process by which the JSP
container is declaratively configured using a deployment descriptor.

===  _JSP file_

A text file that contains JSP elements,
forming a complete JSP page or just a partial page that must be combined
with other JSP files to form a complete page. _Most top-level JSP files
have a_ _.jsp_ _extension, but other extensions can be configured as
well._

===  _JSP fragment_

 _A portion of JSP code, translated into an
implementation of the_ _javax.servlet.jsp.JspFragment_ _abstract class._

===  _JSP page_

One or more JSP files that form a
syntactically complete description for processing a request to create a
response.

 _JSP page, front_ A JSP page that receives
an HTTP request directly from the client. It creates, updates, and/or
accesses some server-side data and then forwards the request to a
presentation JSP page.

===  _JSP page, presentation_

 A JSP page that is intended for presentation
purposes only. It accesses and/or updates some server-side data and
incorporates fixed template data to create content that is sent to the
client.

===  _JSP page implementation class_

The Java programming language class, a
servlet, that is the runtime representation of a JSP page and which
receives the request object and updates the response object. The page
implementation class can use the services provided by the JSP container,
including both the servlet and the JSP APIs.

===  _JSP page implementation object_

 _The instance of the JSP page implementation
class that receives the_ _request_ _object and updates the_ _response_
_object._

===  _JSP segment_

 _A portion of JSP code defined in a separate
file, and imported into a page using the include directive._

===  _named attribute_

 _A standard or custom action attribute whose
value is defined using the <jsp:attribute> standard action._

===  _scripting element_

 _A declaration, scriptlet, or expression,
whose tag syntax is defined by the JSP specification, and whose content
is written according to the scripting language used in the JSP page. The
JSP specification describes the syntax and semantics for the case where
the language page attribute is_ __ _java_ _._

===  _scripting expression_

 _A scripting element that contains a valid
scripting language expression that is evaluated, converted to a String,
and placed into the implicit out object. Syntactically it is delimited
by the_ _<%=_ _and_ _%>_ _characters._

===  _scriptlet_

 _An scripting element containing any code
fragment that is valid in the scripting language used in the JSP page.
The JSP specification describes what is a valid scriptlet for the case
where the language page attribute is_ _java_ _._ _Syntactically a
scriptlet is delimited by the_ _<%_ _and_ _%>_ _characters._

===  _simple tag handler_

 _A tag handler that implements the_
_javax.servlet.jsp.tagext.SimpleTag_ _interface._

===  _tag_ __

 _A piece of text between a left angle
bracket and a right angle bracket that has a name, can have attributes,
and is part of an element in a JSP page. Tag names are known to the JSP
translator, either because the name is part of the JSP specification (in
the case of a standard action), or because it has been introduced using
a Tag Library (in the case of custom action)._

===  __ text-based document that uses fixed template data and JSP elements to define a custom action. The semantics of a tag file are realized at runtime by a tag handler. _tag library_

A collection of custom actions described by a
tag library descriptor and Java classes.

===  _tag library descriptor_

An XML document describing a tag library.

===  _Tag Library Provider_

A vendor that provides a tag library. Typical
examples may be a JSP container vendor, a development group within a
corporation, a component vendor, or a service vendor that wants to
provide easier use of their services.

===  _web application_

An application built for the Internet, an
intranet, or an extranet.

===  _web application, distributable_

 _A Web application that is written so that
it can be deployed in a Web container distributed across multiple Java
virtual machines running on the same host or different hosts. The
deployment descriptor for such an application uses the_ _distributable_
__ _element._

===  _Web Application Deployer_

 _A person who deploys a Web application in a
Web container, specifying at least the root prefix for the Web
application, and in a Java EE environment, the security and resource
mappings._

===  _web component_

 _A servlet class or JSP page that runs in a
JSP container and provides services in response to requests._

===  _Web Container Provider_

 A vendor that provides a servlet and JSP
container that support the corresponding component contracts.



'''''

[.footnoteNumber]# 1.# [[a6611]]Note that this is
independent of scripting language. This specification requires that
unhandled errors occurring in a scripting language environment used in a
JSP container implementation to be signalled to the JSP page
implementation class via the Java programming language exception
mechanism.

[.footnoteNumber]# 2.# [[a6612]]When the scripting
language is _java_ then _page_ is a synonym for _this_ in the body of
the page.

[.footnoteNumber]# 3.# [[a6613]]See syntax for
expression scriptlet _<%= ... %>_

[.footnoteNumber]# 4.# [[a6614]]Similarly, when
applying an XSLT transformation to a JSP document, XML fragments will be
plainly visible, while the content of _jsp:text_ elements will not
